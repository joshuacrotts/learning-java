\section{File I/O}

Presumably this section discusses file input and output syntax and semantics. While this is correct, we will also elaborate on reading data from different sources such as websites and even network connections through sockets. 

\subsection*{Primitive I/O Classes}

Reading and writing from a source, at its core, is nothing more than reading and writing bytes. Indeed, Java provides classes for reading and writing bytes from and to data sources via the \ttt{FileInputStream} and \ttt{FileOutputStream} classes. To read the bytes, i.e,. the contents, of a file with a given name, which we pass to the \ttt{FileInputStream} constructor. The \ttt{.read} method returns an integer representing the next byte available in the stream, opting to return $-1$ if there is no byte available. 

\example Let's write a program that reads data from a file and echos it to standard output.

\begin{cl}[FileInputStreamExample.java]{Reading File Data Example}
\begin{lstlisting}[language=MyJava]
class FileInputStreamExample {

  public static void main(String[] args) {
    FileInputStream fis = null;
    String inputFile = "file1.in";
    try {
      fis = new FileInputStream(inputFile);
      
      // Read in data byte-by-byte.
      int val = -1;
      while ((val = fis.read()) != -1) { System.out.print(val); }
    } catch (FileNotFoundException ex) {
      System.err.printf("main: could not find %s\n", inputFile);
    } catch (IOException ex) {
      System.err.printf("main: an I/O error occurred: %s\n", ex.getMessage());
    } finally {
      fis.close();
    } 
  } 
}
\end{lstlisting}
\end{cl}

Recall that in the previous section we mentioned checked exceptions, and deferred the discussion until generalized input and output. Now that we are here, we can refresh our memory and actually put them to use. A checked exception\index{checked exception} is an exception enforced at compile-time.We emphasize the word enforced because the exception is not handled until runtime, but we must place the code that may throw the checked exception within a \ttt{try/catch} block, as we did with the file input stream example. Namely, the \ttt{FileInputStream} constructor is defined to potentially throw a \ttt{FileNotFoundException}, \ttt{.read} is defined to potentially throw a generalized \ttt{IOException} is some type of input error occurs. Because \ttt{FileNotFoundException} is a subclass/subexception type of \ttt{IOException}, we could omit the distinct catch clause for this exception. 

When reading from an input source that is not \ttt{System.in}, it is imperative to always close the stream resource. So, after we read the data from our file input stream object \ttt{fis}, inside the \ttt{finally} block, we should invoke \ttt{.close} on the instance, which releases the allocated system resources and deems the file no longer available.\footnote{We can check whether an input stream is available via the \ttt{.available} method.} Expanding upon the \ttt{finally} block a bit more, we will say that it is a segment of code that \textit{always} executes, no matter if the preceding code threw an exception. The finally block is useful for releasing resources, e.g,. opened input streams, that otherwise may not be released. Many programmers often forget to close a resource, and then are left to wonder why a file is either corrupted, overwritten, or some other alternative. To remediate this problem, we can use the \textit{try-with-resources} construct, which autocloses the resource.\footnote{Not every resource can be autoclosed; the class of interest must explicitly implement the \ttt{AutoCloseable} interface to be wrapped inside a try-with-resources block.}

\example Let's use the try-with-resources block to copy the contents of one file to another. In essence, we will write a program that opens a file input stream and a file output stream, each to separate files. Upon reading one byte from the first, we write that byte to the second.

...


The file input and output stream classes read data as raw bytes from their source/destination streams. In most circumstances, we probably want to read characters from a data source or to a data destination. To do so, we can instead opt to use the \ttt{FileReader} class, which extends \ttt{Reader} rather than the \ttt{InputStream} class. Namely, \ttt{FileReader} is for reading text, whereas \ttt{FileInputStream} is for reading raw byte content of a file. Therefore a \ttt{FileReader} can read only textual files, i.e., files without an encoding, e.g., \ttt{.pdf}, \ttt{.docx}, and so forth.

\example Using \ttt{FileReader}, we will once again write an ``echo'' program, which reads data from its file source and outputs it to standard output. Of course, we may want to output data to a file, in which case we use the dual to \ttt{FileReader}, namely \ttt{FileWriter}. In summary, \ttt{FileWriter} provides several methods for writing strings and characters to a data destination. In this example we will also write some data to a test file, then examine its output based on the method invocations that we make. 

\begin{cl}[FileReaderWriterExample]{Examples of File Reader and Writer}
\begin{lstlisting}[language=MyJava]
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

class FileReaderWriterExamples {

  public static void main(String[] args) {
    try (FileReader fr = new FileReader("file1.in")) {
      int c = -1; 
      while ((c = fr.read()) != -1) { System.out.print((char) c); }
    } catch (IOException ex) {
      ex.printStackTrace();
    }

    try (FileWriter fw = new FileWriter("file2.out")) {
      fw.write("Here is a string");
      fw.write("\nHere is another string\n"); 
      fw.write(9);
      fw.write(71);
      fw.write(33);
    } catch (IOException ex) {
      ex.printStackTrace();
    }
  }
}

\end{lstlisting}
\end{cl}

If we open the \ttt{file2.out}, we see that it outputs \ttt{"Here is a string"} on one line, followed by \ttt{"Here is another string"} on the next line. Then, we might expect it to output the numeric strings \ttt{"9"}, \ttt{"71"}, and \ttt{"33"} all on the same line. The \ttt{write} method will coerce (valid) numbers into their ASCII character counterparts, meaning that the file contains the tab character, an uppercase \ttt{'G'}, and the exclamation point \ttt{'!'}. As we will soon demonstrate, working directly with \ttt{FileReader} and \ttt{FileWriter} is rarely advantageous. 

The problem with the file input and output stream classes, as well as the file reader and writer classes, is that they interact directly with the operating system using low-level operations. Constantly invoking these low-level operations is expensive on the CPU for various reasons, and these classes read/write byte-after-byte of data, which is horribly inefficient. The \ttt{BufferedReader} and \ttt{BufferedWriter} classes aim to alleviate this problem by instantiating buffers for data. Then, when the buffer is full, the data is flushed to either the source or destination. This way, the program makes fewer operating system-level calls, improving overall program performance. To read from a stream, as suggested, we use \ttt{BufferedReader}. Its constructor receives an instance of the \ttt{Reader} class, which may be one of several classes. For example, to read from a file, we wrap a \ttt{FileReader} inside the constructor of \ttt{BufferedReader}. Wrapping a \ttt{FileReader} inside a \ttt{BufferedReader} allows the buffered reader to interplay (using its optimization techniques) with the file reader, which in turn interacts with the operating system. To output data using buffered I/O, we use the analogous \ttt{BufferedWriter} class, which receives a \ttt{Writer} instance. 

\example Using \ttt{BufferedReader} and \ttt{BufferedWriter}, we will write a program that reads data from a file and outputs it to another file.

\begin{cl}[BufferedReaderWriterExample.java]{Buffered Reader and Writer Example}
\begin{lstlisting}[language=MyJava]
import java.io.BufferedReader;
import java.io.BufferedWriter;

class BufferedReaderWriterExample {

  public static void main(String[] args) {
    try (BufferedReader br = new BufferedReader(new FileReader("file1.in"));
         BufferedWriter bw = new BufferedWriter(new FileWriter("file1.out"))) {
      String line = null;
      while ((line = br.readLine()) != null) { bw.write(line + "\n"); }
    } catch (IOException ex) {
      ex.printStackTrace();
    }
  }
}
\end{lstlisting}
\end{cl}

The benefits of buffered I/O are not obvious to us as the programmers who use these classes. We can, however, directly compare the timed performance of buffered I/O to non-buffered I/O. The following code shows two implementations of reading the contents of a very large file and echoing them to another. We have two defined methods: \ttt{buffered} and \ttt{nonbuffered}, which utilize the \ttt{BufferedReader/Writer} and \ttt{FileInput/OutputStream} classes respectively. Upon testing, we see that the buffered variant takes around three seconds to finish, whereas the nonbuffered version took over four minutes!

\begin{cl}[PerformanceExamples.java]{Buffered versus Non-Buffered I/O Performance}
\begin{lstlisting}[language=MyJava]
import java.io.*;

class PerformanceExamples {
  
  private static void buffered() {
    try (BufferedReader br = new BufferedReader(new FileReader("huge-2m-file.txt"));
         BufferedWriter bw = new BufferedWriter(new FileWriter("bigfile.out"))) {
      int c = -1;
      while ((c = br.read()) != -1) { bw.write(c); }
    } catch (IOException ex) { ex.printStackTrace(); }
  }
  
  private static void nonbuffered() {
    try (FileInputStream br = (new FileInputStream("huge-2m-file.txt"));
         FileOutputStream bw = (new FileOutputStream("bigfile.out"))) {
      int c = -1;
      while ((c = br.read()) != -1) { bw.write(c); }
    } catch (IOException ex) { ex.printStackTrace(); }
  }
}
\end{lstlisting}
\end{cl}  

The classes that we have explored thus far are primarily for reading/writing either binary or text data. Perhaps we want to output values that are not strictly strings or raw bytes, e.g., integers, doubles, floats, and other primitives datatypes. To do so, we can instantiate a \ttt{PrintWriter} instance, which itself receives an instance of the \ttt{Writer} class. A concern for some programmers may be that we lose the benefits of buffered I/O, but this is not the case; the constructor for \ttt{PrintWriter} wraps the writer object that it receives in an instantiation of a \ttt{BufferedWriter} object. Therefore, we do not forgo any performance gains from buffered writing, while gaining the ability to write non-strictly-text data.

\example Using \ttt{PrintWriter}, let's output some arbitrary constants and formatted strings to a file.

\begin{cl}[PrintWriterExample.java]{Using the \ttt{PrintWriter} Class}
\begin{lstlisting}[language=MyJava]
import java.io.PrintWriter;

class PrintWriterExample {
  
  public static void main(String[] args) {
    try (PrintWriter pw = new PrintWriter(new FileWriter("file4.out"))) {
      pw.println(Math.PI);
      pw.println(false);
      pw.printf("This is a %s string with %c and %d and %f and %b\n", "formatted", '&', 42, Math.E, true);
    } catch (IOException ex) { ex.printStackTrace(); }
  }
}
\end{lstlisting}
\end{cl}

And thus the contents of \ttt{file4.out} are, as we might expect:

\begin{verbatim}
3.141592653589793
false
This is a formatted string with & and 42 and 2.718282 and true
\end{verbatim}

We now have methods for reading strings and raw bytes, as well as methods for outputting all primitives and formatted strings to data destinations. We still have one problem: how can we output the representation of an object? For example, take the \ttt{BigInteger} class; it has associated instance variables and fields that we also need to store. For this particular class, it might be tempting to store a stringified representation, but this is not an optimal solution because, what if a class has a field that itself is an object? We would need to recursively stringify the object, which is not a good idea. Instead, we can use the \ttt{ObjectOutputStream} and \ttt{ObjectInputStream} classes, which allow us to \textit{serialize} and \textit{deserialize} objects. Serialization is the process of converting an object into a stream of (transmittable) bytes, whereas deserialization is the opposite process. In summary, when we serialize objects, we save the object itself, alongside any relevant information about the object, e.g., its fields, instance variables, and so forth. Upon deserializing said object, we can restore the object to its original state, initializing its fields. Suppose, on the contrary,

\example Let's use \ttt{ObjectInput/OutputStream} classes to serialize an object of type \ttt{Player}, which has a name, score, health, and array of top scores. To designate that an object can be serialized, it must implement the \ttt{Serializable} interface. This interface is a \textit{marker interface}\index{marker interface}, meaning that it has no methods to implement. Instead, it is a flag that tells the compiler that the class can be serialized. Our example will also demonstrate the idea that classes can contain other class definitions, which is useful for grouping related classes together. The \ttt{ObjectStreamExample} class defines the private and static \ttt{Player} class as described above. Should we open the \ttt{player.out} file, we see that it contains incomprehensible data; this is because the data is intended to be read only by a program. 

\begin{cl}[ObjectStreamExample.java]{(De-)Serializing the \ttt{Player} Class}
\begin{lstlisting}[language=MyJava]
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Arrays;

class ObjectStreamExample {

  private static class Player {

    private String name;
    private int score;
    private int health;
    private double[] topScores;
    
    public Player(String name, int score, int health, double[] topScores) {
      this.name = name;
      this.score = score;
      this.health = health;
      this.topScores = topScores;
    }
    
    @Override
    public String toString() {
      return String.format("Player[name=%s, score=%d, health=%d, topScores=%s]", 
                           name, score, health, Arrays.toString(topScores));
    }
  }
}
\end{lstlisting}
\end{cl}

Suppose, on the contrary, that we store objects as strings in a file. This has two problems: first, as we said before, we would need to recursively serialize all compositional objects of the object that we are serializing. Second, we would need to write a parser to read the stringified object and reinitialize its fields. In essence, we have to reinvent worse versions of preexisting classes.

\example uhhhh \ttt{Scanner} examples...

At this point we have seen several methods and classes for reading data from different data sources. Let's now write a few more meaningful programs.

\example Reading even integers from a file and outputting them to another file...

\example Reading a file and outputting the number of lines, words, and characters...

\example Reading a file and outputting the number of occurrences of each word, ignoring case...

\example A program that receives multiple files through terminal arguments and combines them all into one file, throwing an exception if the extensions do not match...

\example Find/replace function... read a file and replace all occurrences of a word with another word... using terminal args

...


\example Let's write a simple TimeEcho server...

\example Serving multiple clients in the TimeEcho server...

\example Reading commands from multiple clients...

\example Chat server example


