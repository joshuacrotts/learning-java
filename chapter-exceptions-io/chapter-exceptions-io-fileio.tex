\section{File I/O}

Presumably this section discusses file input and output syntax and semantics. While this is correct, we will also elaborate on reading data from different sources such as websites and even network connections through sockets. 

\subsection*{Primitive I/O Classes}

Reading and writing from a source, at its core, is nothing more than reading and writing bytes. Indeed, Java provides classes for reading and writing bytes from and to data sources via the \ttt{FileInputStream} and \ttt{FileOutputStream} classes. To read the bytes, i.e,. the contents, of a file with a given name, which we pass to the \ttt{FileInputStream} constructor. The \ttt{.read} method returns an integer representing the next byte available in the stream, opting to return $-1$ if there is no byte available. 

\example Let's write a program that reads data from a file and echos it to standard output.

\begin{cl}[FileInputStreamExample.java]{Reading File Data Example}
\begin{lstlisting}[language=MyJava]
class FileInputStreamExample {

  public static void main(String[] args) {
    FileInputStream fis = null;
    String inputFile = "file1.in";
    try {
      fis = new FileInputStream(inputFile);
      
      // Read in data byte-by-byte.
      int val = -1;
      while ((val = fis.read()) != -1) { System.out.print(val); }
    } catch (FileNotFoundException ex) {
      System.err.printf("main: could not find %s\n", inputFile);
    } catch (IOException ex) {
      System.err.printf("main: an I/O error occurred: %s\n", ex.getMessage());
    } finally {
      fis.close();
    } 
  } 
}
\end{lstlisting}
\end{cl}

Recall that in the previous section we mentioned checked exceptions, and deferred the discussion until generalized input and output. Now that we are here, we can refresh our memory and actually put them to use. A checked exception\index{checked exception} is an exception enforced at compile-time.We emphasize the word enforced because the exception is not handled until runtime, but we must place the code that may throw the checked exception within a \ttt{try/catch} block, as we did with the file input stream example. Namely, the \ttt{FileInputStream} constructor is defined to potentially throw a \ttt{FileNotFoundException}, \ttt{.read} is defined to potentially throw a generalized \ttt{IOException} is some type of input error occurs. Because \ttt{FileNotFoundException} is a subclass/subexception type of \ttt{IOException}, we could omit the distinct catch clause for this exception. 

When reading from an input source that is not \ttt{System.in}, it is imperative to always close the stream resource. So, after we read the data from our file input stream object \ttt{fis}, inside the \ttt{finally} block, we should invoke \ttt{.close} on the instance, which releases the allocated system resources and deems the file no longer available.\footnote{We can check whether an input stream is available via the \ttt{.available} method.} Expanding upon the \ttt{finally} block a bit more, we will say that it is a segment of code that \textit{always} executes, no matter if the preceding code threw an exception. The finally block is useful for releasing resources, e.g,. opened input streams, that otherwise may not be released. Many programmers often forget to close a resource, and then are left to wonder why a file is either corrupted, overwritten, or some other alternative. To remediate this problem, we can use the \textit{try-with-resources} construct, which autocloses the resource.\footnote{Not every resource can be autoclosed; the class of interest must explicitly implement the \ttt{AutoCloseable} interface to be wrapped inside a try-with-resources block.}

\example Let's use the try-with-resources block to copy the contents of one file to another. In essence, we will write a program that opens a file input stream and a file output stream, each to separate files. Upon reading one byte from the first, we write that byte to the second.

...


The file input and output stream classes read data as raw bytes from their source/destination streams. In most circumstances, we probably want to read characters from a data source or to a data destination. To do so, we can instead opt to use the \ttt{FileReader} class, which extends \ttt{Reader} rather than the \ttt{InputStream} class. Namely, \ttt{FileReader} is for reading text, whereas \ttt{FileInputStream} is for reading raw byte content of a file. Therefore a \ttt{FileReader} can read only textual files, i.e., files without an encoding, e.g., \ttt{.pdf}, \ttt{.docx}, and so forth.

\example Using \ttt{FileReader}, we will once again write an ``echo'' program, which reads data from its file source and outputs it to standard output. Of course, we may want to output data to a file, in which case we use the dual to \ttt{FileReader}, namely \ttt{FileWriter}. In summary, \ttt{FileWriter} provides several methods for writing strings and characters to a data destination. In this example we will also write some data to a test file, then examine its output based on the method invocations that we make. 

\begin{cl}[FileReaderWriterExample]{Examples of File Reader and Writer}
\begin{lstlisting}[language=MyJava]
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

class FileReaderWriterExamples {

  public static void main(String[] args) {
    try (FileReader fr = new FileReader("file1.in")) {
      int c = -1; 
      while ((c = fr.read()) != -1) { System.out.print((char) c); }
    } catch (IOException ex) {
      ex.printStackTrace();
    }

    try (FileWriter fw = new FileWriter("file2.out")) {
      fw.write("Here is a string");
      fw.write("\nHere is another string\n"); 
      fw.write(9);
      fw.write(71);
      fw.write(33);
    } catch (IOException ex) {
      ex.printStackTrace();
    }
  }
}

\end{lstlisting}
\end{cl}

If we open the \ttt{file2.out}, we see that it outputs \ttt{"Here is a string"} on one line, followed by \ttt{"Here is another string"} on the next line. Then, we might expect it to output the numeric strings \ttt{"9"}, \ttt{"71"}, and \ttt{"33"} all on the same line. The \ttt{write} method will coerce (valid) numbers into their ASCII character counterparts, meaning that the file contains the tab character, an uppercase \ttt{'G'}, and the exclamation point \ttt{'!'}. As we will soon demonstrate, working directly with \ttt{FileReader} and \ttt{FileWriter} is rarely advantageous. 

The problem with the file input and output stream classes, as well as the file reader and writer classes, is that they interact directly with the operating system using low-level operations. Constantly invoking these low-level operations is expensive on the CPU for various reasons, and these classes read/write byte-after-byte of data, which is horribly inefficient. The \ttt{BufferedReader} and \ttt{BufferedWriter} classes aim to alleviate this problem by instantiating buffers for data. Then, when the buffer is full, the data is flushed to either the source or destination. This way, the program makes fewer operating system-level calls, improving overall program performance. To read from a stream, as suggested, we use \ttt{BufferedReader}. Its constructor receives an instance of the \ttt{Reader} class, which may be one of several classes. For instance, to read from a file, we wrap a \ttt{FileReader}  

\example Using \ttt{BufferedReader} and \ttt{BufferedWriter}...

\example Using \ttt{PrintWriter}...

\example \ttt{ObjectInput/OutputStream}...

\example \ttt{Scanner} examples...

\example Let's write a simple TimeEcho server...

\example Serving multiple clients in the TimeEcho server...

\example Reading commands from multiple clients...

\example Chat server example


