\section{Chapter Exercises}
\addcontentsline{toc}{section}{Exercises}

\exercise{2}{chapter-exceptions-io}{Design the \ttt{EchoOdds} class, which reads a file of line-separated integers specified by the user (using standard input), and writes only the odd numbers out to a file of the same name, just with the \ttt{.out} extension. If there is a non-number in the file, throw an \ttt{InputMismatchException}.} 

\textit{Example Run.} If the user types \ttt{"file1a.in"} into the running program, and \ttt{file1a.in} contains the following:

\begin{verbnobox}[\small]
5
100
25
17
2
4
0
-3848
13
    \end{verbnobox}

    then \ttt{file1a.out} is generated containing the following:
    \begin{verbnobox}[\small]
5
25
17
13
    \end{verbnobox}

\textit{Example Run.}  If the user types \ttt{"file1b.in"} into the running program, and \ttt{file1b.in} contains the following:

    \begin{verbnobox}[\small]
5
100
25
17
THIS_IS_NOT_AN_INTEGER!
4
0
-3848
13
    \end{verbnobox}

    then the program does not output a file because it throws an exception.

    \exercise{2}{chapter-exceptions-io}{Design the \ttt{Capitalize} class, which reads a file of strings (that are not necessarily line-separated) specified by the user (using standard input), and outputs the capitalized versions of the sentences to a file of the same name, just with the \ttt{.out} extension. You may assume that a sentence is a string that is terminated by a period and only a period. This problem is harder than it looks because you need to correctly print the string out to the file. If you use a splitting method, e.g., \ttt{.split}, you must remember to reinsert the period in the resulting string. There are many ways to solve this problem!}

    \textit{Example Run.} If the user types \ttt{"file2a.in"} into the running program, and \ttt{file2a.in} contains the following \textit{(note that if you copy and paste this input data, you will need to remove the newline before the \ttt{"hopefully"} token):}

    \begin{verbnobox}[\small]
hi, it's a wonderful day. i am doing great, how are you doing. it's 
hopefully fairly obvious as to what you need to do to solve this problem.
this is a sentence on another line.
this sentence should also be capitalized.
    \end{verbnobox}

    then \ttt{file2a.out} is generated containing the following:

    \begin{verbnobox}[\small]
Hi, it's a wonderful day. I am doing great, how are you doing. It's 
hopefully fairly obvious as to what you need to do to solve this problem.
This is a sentence on another line.
This sentence should also be capitalized.
    \end{verbnobox}

    \exercise{2}{chapter-exceptions-io}{Design the \ttt{SpellChecker} class, which reads two files: \ttt{"dictionary.txt"} and a file specified by the user (through standard input). The specified flie contains a single sentence that may or may not have misspelled words. Your job is to check each word in the file and determine whether or not they are spelled correctly, according to the dictionary of words. If it is not spelled correctly, wrap it inside brackets \ttt{[]}. Output the modified sentences to a file of the same name, just with the \ttt{.out} extension instead. You may assume that words are space-separated and that no punctuation exist. Hint: use a \ttt{HashSet}! Another hint: words that are different cases are not misspelled; e.g., \ttt{"Hello"} is spelled the same as \ttt{"hello"}; how can your program check this?}

    \textit{Example Run.} Assuming \ttt{dictionary.txt} contains a list of words, if the user types \ttt{"file3a.in"} into the running program, and \ttt{file3a.in} contains the following:

    \begin{verbnobox}[\small]
Hi hwo are you donig I am dioing jsut fine if I say so mysefl but I 
will aslo sya that I am throughlyy misssing puncutiation
    \end{verbnobox}

    then \ttt{file3a.out} is generated containing the following:

    \begin{verbnobox}[\small]
Hi [hwo] are you [donig] I am [dioing] [jsut] fine if I say so 
[mysefl] but I will [aslo] [sya] that I am [thoroughlyy] [misssing] 
[puncutiation]
    \end{verbnobox}

\exercise{2}{chapter-exceptions-io}{A common use for file input and output is data analysis. Design a class \ttt{StatisticsDescriptor} that has the following methods:}
\begin{itemize}
    \item \ttt{void read(String fileName)}, which reads in a list of numbers from a file into a collection. These numbers can be integers or floating-point values.
    \item \ttt{double mean()}, which returns the mean of the dataset.
    \item \ttt{double stddev()}, which returns the standard deviation of the dataset.
    \item \ttt{double quantile(double q)}, which receives a quantile value $q \in [0, 1]$ and returns the value such that there are $q$, as a percentage, values below said value. As an example, if our dataset contains \ttt{3, 2, 1, 4, 5, 10, 20}, and we call \ttt{quantile(0.30)}, then we return $2.8$ to indicate that $30\%$ of the values in the dataset are below $2.8$. 
    \item \ttt{double median()}, which returns the median, or the middle value, of the dataset.
    \item \ttt{double mode()}, which returns the mode, or the most-frequent value, of the dataset.
    \item \ttt{double range()}, which returns the range, or the difference between the maximum and minimum values of the dataset.
    \item \ttt{List<Double> outliers()}, which returns the numbers that are outliers of the dataset. We consider a value an outlier if it is greater than three standard deviations away from the mean. Refer to the formula for z-score calculation in the exercises from Chapter~\ref{chapter-testingandjava}.
    \item \ttt{void output(String fileName)}, which outputs all of the above statistics to the file specified by the parameter (the order is irrelevant). You should output these as a series of ``key-value'' pairs separated by an equals sign, e.g., \ttt{mean=X}. Put each pair on a separate line.
\end{itemize}

For all methods (except \ttt{read}), if the data has yet to be read, throw an \ttt{IllegalStateException}. 

\exercise{2}{chapter-exceptions-io}{You are teaching an introductory programming course and you want to keep a seating chart for your students. A seating chart is an arrangement of numbers $1..n$, the location in the classroom of which is defined by the instructor. Numbers that are lower in the range are closer to the front of the room. Design the \ttt{SeatingChart} class, which has the following methods:}

\begin{itemize}
    \item \ttt{SeatingChart()} is the constructor, which initializes the seating chart to be empty. The seating chart is represented as a \ttt{List<Student>}, where \ttt{Student} is a private and static class, inside \ttt{SeatingChart}, that you design. Students should have a name, a seat number, and an accommodation parameter. The seat number is an integer, and the accommodation parameter is a boolean.

    \item \ttt{void read(String fileName)} reads in a list of students from a file into the seating chart. The file contains a list of students, one per line, with their name. A student also has an optional accommodation parameter, which means they should sit in a seat closer to the front of the room. The file is comma-separated, and if the student has an accommodation, it is represented by \ttt{true} after the student's name.
    \begin{verbnobox}[\small]
Alice
Bob,true
Charlie
    \end{verbnobox}
    \item \ttt{void scramble()} scrambles the seating chart. That is, it randomly shuffles the students in the seating chart. This also accounts for the accommodations, so that students with accommodations are closer to the front of the room.
    \item \ttt{void alphabetize()} sorts the seating chart alphabetically by the students' names. This mode does not account for accommodations, and is strictly alphabetical.
    \item \ttt{List<Student> getStudents()} returns the seating chart as a list of students.
    \item \ttt{List<Student> getAccommodationStudents()} returns the students with accommodations as a list.
    \item \ttt{void output(String fileName)} outputs the seating chart to a file specified by the parameter. The file should contain the students' names and their seat numbers, one per line, separated by a comma. The output list should be in the order of the seating chart.
\end{itemize}

\exercise{3}{chapter-exceptions-io}{A maze is a grid of cells, each of which is either open or blocked. We can move from one free cell to another if they are adjacent. Design the \ttt{MazeSolver} class, which has the following methods:}

\begin{itemize}
    \item \ttt{MazeSolver(String fileName)} is the constructor, which reads a description of a maze from a file. The file contains a grid of characters, where \ttt{`.'} represents an open cell and \ttt{`\#'} represents a blocked cell. The file is formatted such that each line is the same length. Read the data into a \ttt{char[][]} instance variable. You may assume that the maze dimensions are on the first line of the file, separated by a space.

    \item \ttt{char[][] solve()} returns a \ttt{char[][]} that represents the solution to the maze. The solution should be the same as the input maze, but with the path from the start to the end marked with \ttt{`*'} characters. The start is the top-left cell, and the end is the bottom-right cell. If there is no solution, return \ttt{null}.

    We can use a backtracking algorithm to solve this problem: start at a cell and mark it as visited. Then, recursively try to move to each of its neighbors, marking the path with a \ttt{`*'} character. If you reach the maze exit, then return \ttt{true}. Otherwise, backtrack and try another path. By ``backtrack,'' we mean that you should remove the \ttt{`*'} character from the path. If you have tried all possible paths from a cell and none of them lead to the exit, then return \ttt{false}. We provide a skeleton of the class below.

    \item \ttt{void output(String fileName, char[][] soln)} outputs the given solution to the maze to a file specified by the parameter. Refer to the above descriptoin for the format of the output file and the input \ttt{char[][]} solution.

\begin{cl}[]{}
\begin{lstlisting}[language=MyJava]
class MazeSolver {

  private final char[][] MAZE;

  public MazeSolver(String fileName) { /* TODO read maze from file. */ }

  /**
   * Recursively solves the maze, returning a solution if it exists, and 
   * null otherwise. We use a simple backtracking algorithm in the helper.
   * @return a solution to the maze, or null if it does not exist.
   */
  public char[][] solve() {
    char[][] soln = new char[MAZE.length][MAZE[0].length];
    return this.solveHelper(0, 0, soln) ? soln : null;
  }

  /**
   * Recursively solves the maze, returning true if we ever reach
   * the exit. We try all possible paths from the current cell, if
   * they are reachable. If a path ends up being a dead end, we backtrack
   * and try another path.
   * @param r - the row of the current cell.
   * @param c - the column of the current cell.
   * @param sol - the current solution to the maze.
   * @return true if we are at the exit, false otherwise.
   */
  private boolean solveHelper(int r, int c, char[][] sol) { /* TODO. */ }
}
\end{lstlisting}
\end{cl}
\end{itemize}

\exercise{3}{chapter-exceptions-io}{A binary relation $\mathcal{R}$ is a subset of the cartesian product of two sets $A$ and $B$. That is, $\mathcal{R} \subseteq A \times B$ such that $A \times B = \{\langle{x, y}\rangle \mid x \in A \text{ and } y \in B\}$. There are several ways that we can describe binary relations, including reflexive, symmetric, transitive, antisymmetric, asymmetric, irreflexive, and serial.}

Design the generic \ttt{BinaryRelation<T, U>} class to represent a mathematical binary relation. It should store a \ttt{Set<Pair<String, String>{>}}, where the inner pair is the associated tuples of the set. Its constructor should instantiate the set instance variable. 

Then, design the following methods:

\begin{itemize}
    \item \ttt{void addTuple(T x, U y)} receives two values $x$ and $y$ of types $T$ and $U$ respectively, and adds them as a tuple to the underlying set.
    
    \item \ttt{boolean isReflexive()} returns true if the relation is reflexive. A relation $\mathcal{R}$ is reflexive if, for all $x \in S$, $\langle{x, x}\rangle \in \mathcal{R}$.
    
    \item \ttt{boolean isSymmetric()} returns true if the relation is symmetric. A relation $\mathcal{R}$ is symmetric if, for all $x, y \in S$, $\langle{x, y}\rangle \in \mathcal{R}$ and $\langle{y, x}\rangle \in \mathcal{R}$.
    
    \item \ttt{boolean isTransitive()} returns true if the relation is reflexive. A relation $\mathcal{R}$ is transitive if, for all $x, y, z \in S$, if $\langle{x, y}\rangle \in \mathcal{R}$ and $\langle{y, z}\rangle \in \mathcal{R}$, then $\langle{x, z}\rangle \in \mathcal{R}$.
    
    \item \ttt{boolean isEquivalence()} returns true if the relation is an equivalence relation. A relation $\mathcal{R}$ is an equivalence relation if it is reflexive, symmetric, and transitive.

    \item \ttt{boolean isIrreflexive()} returns true if the relation is irreflexive. A relation $\mathcal{R}$ is irreflexive if, for all $x \in S$, $\langle{x, x}\rangle \not\in \mathcal{R}$.
    
    \item \ttt{boolean isAntisymmetric()} returns true if the relation is antisymmetric. A relation $\mathcal{R}$ is antisymmetric if, for all $x, y \in S$, if $\langle{x, y}\rangle \in \mathcal{R}$ and $\langle{y, x}\rangle \in \mathcal{R}$, then $x \neq y$.
    
    \item \ttt{boolean isAsymmetric()} returns true if the relation is asymmetric. A relation is asymmetric if it is both antisymmetric and irreflexive.

    \item \ttt{boolean isSerial()} returns true if the relation is serial. A relation $\mathcal{R}$ is serial if, for all $x \in S$, there exists a $y \in S$ such that $\langle{x, y}\rangle \in \mathcal{R}$.

    \item \ttt{Set<Pair<String, String>{>} reflexiveClosure()} returns a set representing the reflexive closure of a binary relation, which is $\mathcal{R} \cup r(\mathcal{R})$, where $r$ returns a reflexive set over $S$.
    
    \item \ttt{Set<Pair<String, String>{>} isSymmetricClosure()} returns a set representing the symmetric closure of a binary relation, which is $\mathcal{R} \cup s(\mathcal{R})$, where $r$ returns a symmetric set over $S$.

    \item \ttt{Set<Pair<String, String>{>} transitiveClosure()} returns a set representing the transitive closure of a binary relation, which is $\mathcal{R} \cup t(\mathcal{R})$, where $t$ returns a transitive set over $S$.
\end{itemize}

As an added optimization, we should cache whether the current relation is one of these properties when prompted. If we do not add a pair to the relation, then it makes little sense to recompute whether or not is, say, reflexive. Implement this as an optimization, however you wish, into the class.

\exercise{2}{chapter-exceptions-io}{Recall the \ttt{Optional} class and its purpose. In this exercise you will reimplement its behavior with the \ttt{IMaybe} interface with two subtypes \ttt{Just} and \ttt{Nothing}, representing the existence and absence of a value, respectively. Design the generic \ttt{IMaybe} interface, which contains the following three metohds: \ttt{T get()}, \ttt{boolean isJust()}, and \ttt{boolean isNothing()}. The constructors of these subtypes receive either an object of type \ttt{T} or no parameter, depending on whether it is a \ttt{Just} or a \ttt{Nothing}. Throw an \ttt{UnsupportedOperationException} when trying to get the value from an instance of \ttt{Nothing}}.

\exercise{2}{chapter-exceptions-io}{Redo the ``\ttt{Maybe}'' exercise, only this time implement it as an abstract class/subclass hierarchy. That is, \ttt{Maybe} should be an abstract class containing three abstract methods: \ttt{T get()}, \ttt{boolean isJust()}, and \ttt{boolean isNothing()}. The \ttt{Just} and \ttt{Nothing} classes should be subclasses of \ttt{Maybe} and override these methods accordingly. Do not create constructors for these classes. Instead, create static factory methods \ttt{Just.of(T t)} and \ttt{Nothing.of()} that return an instance of the appropriate class.}
