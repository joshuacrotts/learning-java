\section{Exercises}

\myexercise{2}{chapter-exceptions-io}{Design the \ttt{EchoOdds} class, which reads a file of line-separated integers specified by the user (using standard input), and writes only the odd numbers out to a file of the same name, just with the \ttt{.out} extension. If there is a non-number in the file, throw an \ttt{InputMismatchException}.} 

\emph{Example Run.} If the user types \ttt{"file1a.in"} into the running program, and \ttt{file1a.in} contains the following:

\begin{verbnobox}[\small]
5
100
25
17
2
4
0
-3848
13
    \end{verbnobox}

    then \ttt{file1a.out} is generated containing the following:
    \begin{verbnobox}[\small]
5
25
17
13
    \end{verbnobox}

\emph{Example Run.}  If the user types \ttt{"file1b.in"} into the running program, and \ttt{file1b.in} contains the following:

    \begin{verbnobox}[\small]
5
100
25
17
THIS_IS_NOT_AN_INTEGER!
4
0
-3848
13
    \end{verbnobox}

    then the program does not output a file because it throws an exception.

    \myexercise{2}{chapter-exceptions-io}{Design the \ttt{Capitalize} class, which contains one \ttt{static} method: \ttt{void capitalize(String in)}. The \ttt{capitalize} method reads a file of sentences (that are not necessarily line-separated), and outputs the capitalized versions of the sentences to a file of the same name, just with the \ttt{.out} extension (you must remove whatever extension existed previously). 
    
    You may assume that a sentence is a string that is terminated by a period and only a period, which is followed by a single space. If you use a splitting method, e.g., \ttt{.split}, you must remember to reinsert the period in the resulting string. There are many ways to solve this problem!}

    \emph{Example Run.} If we invoke \ttt{capitalize("file2a.in")} into the running program, and \ttt{file2a.in} contains the following \emph{(note that if you copy and paste this input data, you will need to remove the newline before the \ttt{"hopefully"} token):}

    \begin{verbnobox}[\small]
hi, it's a wonderful day. i am doing great, how are you doing. it's 
hopefully fairly obvious as to what you need to do to solve this problem.
this is a sentence on another line.
this sentence should also be capitalized.
    \end{verbnobox}

    then \ttt{file2a.out} is generated containing the following (\emph{again, remember to remove the newline before \ttt{"hopefully"}.}):

    \begin{verbnobox}[\small]
Hi, it's a wonderful day. I am doing great, how are you doing. It's 
hopefully fairly obvious as to what you need to do to solve this problem.
This is a sentence on another line.
This sentence should also be capitalized.
    \end{verbnobox}

    \myexercise{2}{chapter-exceptions-io}{Design the \ttt{SpellChecker} class, which contains one \ttt{static} method: \ttt{void spellCheck(String dict, String in)}. The \ttt{spellCheck} method reads two files: a ``dictionary'' and a content file. The content file contains a single sentence that may or may not have misspelled words. Your job is to check each word in the file and determine whether or not they are spelled correctly, according to the dictionary of (line-separated) words. If a word is not spelled correctly, wrap it inside brackets \ttt{[]}. 
    
    Output the modified sentences to a file of the same name, just with the \ttt{.out} extension (you must remove whatever extension existed previously). You may assume that words are space-separated and that no punctuation exist. Hint: use a \ttt{Set}! Another hint: words that are different cases are not misspelled; e.g., \ttt{"Hello"} is spelled the same as \ttt{"hello"}; how can your program check this?}

    \emph{Example Run.} Assuming \ttt{dictionary.txt} contains a list of words, if we invoke \ttt{spellChecker("dictionary.txt", "file3a.in")}, and \ttt{file3a.in} contains the following:

    \begin{verbnobox}[\small]
Hi hwo are you donig I am dioing jsut fine if I say so mysefl but I 
will aslo sya that I am throughlyy misssing puncutiation
    \end{verbnobox}

    then \ttt{file3a.out} is generated containing the following:

    \begin{verbnobox}[\small]
Hi [hwo] are you [donig] I am [dioing] [jsut] fine if I say so 
[mysefl] but I will [aslo] [sya] that I am [throughlyy] [misssing] 
[puncutiation]
    \end{verbnobox}

\myexercise{2}{chapter-exceptions-io}{Design the \ttt{OrderWebUrls} class, which contains one \ttt{static} method: \ttt{void orderWebUrls(String in)}. The \ttt{orderWebUrls} method reads in a file of line-separated web URLs. A web URL contains a protocol separated by a colon and two forward slashes, and a host name. For example, in the URL \ttt{https://www.joshuacrotts.us}, the protocol is \ttt{https} and the host name is \ttt{www.joshuacrotts.us}. The method should read in web URLs in this specific format and sort them, lexicographically, based on the hostname. If two hostnames are identical and only differ by the protocol, then the order becomes based on the protocol.}

\myexercise{2}{chapter-exceptions-io}{Recall the \ttt{Optional} class and its purpose. In this exercise you will reimplement its behavior with the \ttt{IMaybe} interface with two subtypes \ttt{Just} and \ttt{Nothing}, representing the existence and absence of a value, respectively. Design the generic \ttt{IMaybe} interface, which contains the following three metohds: \ttt{T get()}, \ttt{boolean isJust()}, and \ttt{boolean isNothing()}. The constructors of these subtypes receive either an object of type \ttt{T} or no parameter, depending on whether it is a \ttt{Just} or a \ttt{Nothing}. Throw an \ttt{UnsupportedOperationException} when trying to get the value from an instance of \ttt{Nothing}}.

\myexercise{2}{chapter-exceptions-io}{Redo the ``\ttt{Maybe}'' exercise, only this time implement it as an abstract class/subclass hierarchy. That is, \ttt{Maybe} should be an abstract class containing three abstract methods: \ttt{T get()}, \ttt{boolean isJust()}, and \ttt{boolean isNothing()}. The \ttt{Just} and \ttt{Nothing} classes should be subclasses of \ttt{Maybe} and override these methods accordingly. Do not create constructors for these classes. Instead, create static factory methods \ttt{Just.of(T t)} and \ttt{Nothing.of()} that return an instance of the appropriate class.}

\myexercise{2}{chapter-exceptions-io}{A common use for file input and output is data analysis. Design a class \ttt{StatisticsDescriptor} that has the following methods:}
\begin{enumerate}[label=(\alph*)]
    \item \ttt{void read(String fileName)}, which reads in a list of numbers from a file into a collection. These numbers can be integers or floating-point values.
    \item \ttt{double mean()}, which returns the mean of the dataset.
    \item \ttt{double stddev()}, which returns the standard deviation of the dataset.
    \item \ttt{double quantile(double q)}, which receives a quantile value $q \in [0, 1]$ and returns the value such that there are $q$, as a percentage, values below said value. As an example, if our dataset contains \ttt{3, 2, 1, 4, 5, 10, 20}, and we call \ttt{quantile(0.30)}, then we return $2.8$ to indicate that $30\%$ of the values in the dataset are below $2.8$. 
    \item \ttt{double median()}, which returns the median, or the middle value, of the dataset.
    \item \ttt{double mode()}, which returns the mode, or the most-frequent value, of the dataset.
    \item \ttt{double range()}, which returns the range, or the difference between the maximum and minimum values of the dataset.
    \item \ttt{List<Double> outliers()}, which returns the numbers that are outliers of the dataset. We consider a value an outlier if it is greater than three standard deviations away from the mean. Refer to the formula for z-score calculation in the exercises from Chapter~\ref{chapter-testingandjava}.
    \item \ttt{void output(String fileName)}, which outputs all of the above statistics to the file specified by the parameter (the order is irrelevant). You should output these as a series of ``key-value'' pairs separated by an equals sign, e.g., \ttt{mean=X}. Put each pair on a separate line.
\end{enumerate}

For all methods (except \ttt{read}), if the data has yet to be read, throw an \ttt{IllegalStateException}. 

\myexercise{2}{chapter-exceptions-io}{You are teaching an introductory programming course and you want to keep a seating chart for your students. A seating chart is an arrangement of numbers $1..n$, the location in the classroom of which is defined by the instructor. Numbers that are lower in the range are closer to the front of the room. Design the \ttt{SeatingChart} class, which has the following methods:}

\begin{enumerate}[label=(\alph*)]
    \item \ttt{SeatingChart()} is the constructor, which initializes the seating chart to be empty. The seating chart is represented as a \ttt{List<Student>}, where \ttt{Student} is a private and static class, inside \ttt{SeatingChart}, that you design. Students should have a name, a seat number, and an accommodation parameter. The seat number is an integer, and the accommodation parameter is a boolean.

    \item \ttt{void read(String fileName)} reads in a list of students from a file into the seating chart. The file contains a list of students, one per line, with their name. A student also has an optional accommodation parameter, which means they should sit in a seat closer to the front of the room. The file is comma-separated, and if the student has an accommodation, it is represented by \ttt{true} after the student's name.
    \begin{verbnobox}[\small]
Alice
Bob,true
Charlie
    \end{verbnobox}
    \item \ttt{void scramble()} scrambles the seating chart. That is, it randomly shuffles the students in the seating chart. This also accounts for the accommodations, so that students with accommodations are closer to the front of the room.
    \item \ttt{void alphabetize()} sorts the seating chart alphabetically by the students' names. This ``mode'' does not account for accommodations, and is thus strictly alphabetical.
    \item \ttt{List<Student> getStudents()} returns the seating chart as a list of students.
    \item \ttt{List<Student> getAccommodationStudents()} returns the students with accommodations as a list.
    \item \ttt{void output(String fileName)} outputs the seating chart to a file specified by the parameter. The file should contain the students' names and their seat numbers, one per line, separated by a comma. The output list should be in the order of the seating chart.
\end{enumerate}

\myexercise{3}{chapter-exceptions-io}{You are designing a system for looking up car information, similar to that of, say, Kelly Blue Book or Carvana.}

\begin{enumerate}[label=(\alph*)]
    \item First, design the \ttt{Car} class, which stores the make, model, color, trim, and VIN (vehicle identification number) of the car as strings, the year and number of prior owners as an integer, an enumeration that contains its title status (e.g., \ttt{Clean}, \ttt{Salvaged}, or \ttt{Rebuilt}), and its MSRP (in USD) as a floating-point value.\footnote{As a tip: if you are ever writing real-world software that works with currency values, you should \emph{never} store currency as floating-point numbers, e.g., \ttt{double} or \ttt{float}. This is because of the inaccuracies that come with such representations in a computer. The preferred solution is to use an object type that separately stores cents and dollars such as \ttt{BigDecimal}.}

    \item Make the \ttt{Car} class serializable, like we did in the chapter. That is, implement the \ttt{Serializable} interface and override the \ttt{writeObject} and \ttt{readObject} methods respectively. 

    \item Override the \ttt{public boolean equals(Object o)} and \ttt{public int hashCode()} methods. Two \ttt{Car} objects are the same if they share the same VIN. When overriding \ttt{hashCode}, return a hash code that hashes all instance variables.
    
    \item Finally, override the \ttt{public String toString()} method, which returns a string similar to the following (with a tab character before each line):
\begin{verbnobox}[\small]
    Make: Honda
    Model: Accord
    Color: Silver
    Trim: LX
    Year: 2007
    VIN: 1G4HDSLVRLX
    Number of Previous Owners: 2
    Title Status: Salvaged
    MSRP: $20,475.00
\end{verbnobox}

    \item Now, design the \ttt{CarDatabase} class, whose (no parameter) constructor instantiates a \ttt{List<Car>} instance variable to store the list of cars. Then, design the following methods:
    \begin{enumerate}[label=(\roman*)]
        \item \ttt{void addCar(Car car)}, which adds a car with the given values to the database.
        \item \ttt{boolean removeCar(String vin)}, which removes a car with the given VIN. If the car was in the database, the method returns \ttt{true}, and \ttt{false} otherwise.
        \item \ttt{boolean contains(String vin)}, which returns \ttt{true} if a \ttt{Car} with the given VIN exists in the database, and \ttt{false} otherwise. 
        \item \ttt{boolean contains(Car car)}, which returns \ttt{true} if the given car exists in the database, and \ttt{false} otherwise. Note that this method should be one line long and call the other variant of \ttt{contains}.
        \item \ttt{void readFile(String in)}, which populates the database with the \ttt{Car} objects from the given file. The file should contain only serialized \ttt{Car} objects and not plain-text. 
        \item \ttt{void writeFile(String out)}, which writes all cars in the database out to a file with the given file name. The file should contain only serialized \ttt{Car} objects and not plain-text.
        \item \ttt{void sort(Comparator<Car> cmp)}, which sorts the database of \ttt{Car} objects according to the provided \ttt{Comparator} implementation.
        \item \ttt{void sort()}, which sorts the database of \ttt{Car} objects according to their VIN.
    \end{enumerate}
\end{enumerate}

%\myexercise{2}{chapter-exceptions-io}{Grading anonymous submissions helps to reduce implicit bias in the classroom~\Citep{blindgrading}. So, you want to design a program that, when given a list of non-anonymized files, scrambles each file names into random strings. This allows you to grade the files without knowing \emph{who} you are grading. Then, when you're finished, you can deanonymize the files to revert them to their normal state.}

%\begin{enumerate}[label=(\alph*)]
%    \item Design the \ttt{Blindify} class. Its constructor should receive a string denoting the directory of files to use for grading.
%    \item Design the private and static \ttt{String generateRandomFileName(int len, String ext)} method that, when given a length and a file extension, 
%    \item Design the \ttt{void anonymize(String output)} method, which reads...
%    \item Design the \ttt{void deanonymize()} method, which ...
%    \item Design the \ttt{static void anonymize(String dir, String output)} method, ...
%   \item Design the \ttt{static void deanonymize(String dir, String anonymizedFile, String output)} method, ...
%\end{enumerate}

\myexercise{2}{chapter-exceptions-io}{You're interested in determining the letter statistics of a file containing text. In particular, you want to design a program that reports the frequency of each alphabetic character. Design the \ttt{LetterFrequency} class, which has the following methods:}

\begin{enumerate}[label=(\alph*)]
    \item \ttt{LetterFrequency(String fileName)} is the constructor, which reads a file containing text into a \ttt{long[]} instance variable with $26$ elements. Convert all upper-case letters into lower-case. Index 0 of the (frequency) array corresponds to \ttt{\q{}a\q{}}, and index 25 corresponds to \ttt{\q{}z\q{}}. Before reading the contents of the file, initialize the array to contain all zeroes.
    \item \ttt{void add(char c)} adds a character $c$ to the frequency map. If $c$ is not alphabetic, throw an \ttt{IllegalArgumentException}.
    \item \ttt{void add(String s)} calls the other \ttt{add} method on each character in the given string~$s$.
    \item \ttt{long get(char c)} returns the frequency of a given character, which should be converted to lowercase. If $c$ is not a letter, throw an \ttt{IllegalArgumentException}.
    \item \ttt{char get(int i)} returns the $i^\text{th}$ most frequent character. If $i \not\in [0, 25)$, throw an \ttt{IllegalArgumentException}.
    \item \ttt{List<Character> getMostFrequentChars(int n)} returns the~$n$ most frequent characters. If $n \not\in [0, 25)$, throw an \ttt{IllegalArgumentException}. Hint: invoke the \ttt{get} method~$n$ times for values~$1$ to~$n$ inclusive.
\end{enumerate}

\myexercise{2}{chapter-exceptions-io}{This exercise has two parts.}
A \emph{stack-based} programming language is one that uses a stack to keep track of variables, values, and the results of expressions. These types of languages have existed for several decades, and in this exercise you will implement such a language.

Design the \ttt{StackLanguage} class, whose constructor receives no parameters. The class contains two instance methods: \ttt{void readFile(String f)} and \ttt{double interpret()}. 

\begin{itemize}
    \item The \ttt{readFile} method reads a series of ``stack commands'' from the file. These can be stored however you feel necessary in the class, but you should not interpret anything in this method, nor should you throw any exceptions. You may want to create a private static class for storing commands.
    \item The \ttt{interpret} method interprets the stored list of instructions. If no instructions have been received by a \ttt{readFile} command, throw an \ttt{IllegalStateException}. Here are the following possible instructions:

    \begin{enumerate}[label=(\alph*)]
        \item \ttt{DECL $v$ $X$} declares that $v$ is a variable with value $X$.
        \item \ttt{PUSH $X$} pushes a number $X$ to the stack. 
        \item \ttt{POP $v$} pops the top-most number off the stack and stores it in a variable~$v$. If $v$ has not been declared, an \ttt{IllegalArgumentException} is thrown.
        \item \ttt{PEEK $v$} stores the value at the top of the stack in the variable~$v$. If $v$ has not been declared, an \ttt{IllegalArgumentException} is thrown.
        \item \ttt{ADD $X$} adds $X$ to the top-most number on the stack.
        \item \ttt{SUB $X$} subtracts $X$ from the top-most number on the stack.
        \item \ttt{XCHG $v$} swaps the value on the top of the stack with the value stored in variable~$v$. If~$v$ has not been declared as a variable, an \ttt{IllegalArgumentException} is thrown.
        \item \ttt{DUP} duplicates the value at the top of the stack.
    \end{enumerate}
    If the command is none of these, then throw an \ttt{UnsupportedOperationException}. You may assume that all commands, otherwise, are well-formed (i.e., they contain the correct number of arguments and the types thereof are correct).
    After interpreting all instructions, the value that is returned is the top-most value on the stack. If there is no such value, throw a \ttt{NoSuchElementException}.

    Hint: use a \ttt{Map} to store variable identifiers to values.
\end{itemize}

\myexercise{3}{chapter-exceptions-io}{Java provides many forms of input and output stream classes, e.g., \ttt{BufferedReader}/\ttt{BufferedWriter}. Unfortunately, it does not have classes, say \ttt{BitInputStream} and \ttt{BitOutputStream}, for outputting raw bits to a file. In this exercise you will implement these classes.}\footnote{This exercise is common in Java textbooks, and in our opinion, is worth repeating.}

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{BitOutputStream} class, which extends \ttt{OutputStream}. It should store two instance variables: an instance of \ttt{OutputStream} and an array of eight integers. Each integer index corresponds to a bit to send to the output.
    \begin{enumerate}[label=(\roman*)]
        \item Design three \ttt{BitOutputStream} constructors: one that sets the stored output stream instance to \ttt{null}, a second that receives an \ttt{OutputStream} object and assigns it to the instance variable, and a third that receives a file name, and instantiates the stored output stream as a \ttt{FileOutputStream}. All three constructors should instantiate the array of ``bits.''
        \item Override the \ttt{public void flush() throws IOException} method from \ttt{OutputStream} to output the bits, as a single byte, to the file. This does \emph{not} mean that you should output the raw \ttt{\q{}1\q{}} and \ttt{\q{}0\q{}} characters that are stored in the buffer. Instead, convert those bits into a single \ttt{int}, and write that value to the output stream. Hint: the bitwise operations \ttt{<<} and \ttt{|} may come in handy.
        \item Override the \ttt{public void write(int b) throws IOException} method from \ttt{OutputStream} to assign bit $b$ to the next-free index in the array. If you run out of bits to store in the array, call \ttt{this.flush()}. 
        \item Design the \ttt{void writeBit(int b)} method, which adds a bit to the $i^\text{th}$ index of the array. If the input~$b$ is not a 0 or 1, throw an \ttt{IllegalArgumentException}, otherwise call \ttt{this.write} with~$b$.
    \end{enumerate}

    \item Design the \ttt{BitInputStream} class, which extends \ttt{InputStream}. This class should also store an instance of an \ttt{InputStream} as a field, as well as an array of bit values.
    \begin{enumerate}[label=(\roman*)]
        \item Design three \ttt{BitInputStream} constructors that mimic the behavior of the \ttt{BitOutputStream} class constructors.
        \item Design the \ttt{private int readBit()} method, which reads a bit from the buffer. Your code should call \ttt{read} on the input stream once every eight bits, i.e., every byte. 
        \item Override the \ttt{public int read()} method, which returns the next bit from the buffer. If you run out of bits to return, read a byte from the input stream. If there are no more bytes to read, return $-1$. Hint: \ttt{read()} itself returns $-1$ when there are no bytes remaining.
    \end{enumerate}
\end{enumerate}

\myexercise{3}{chapter-exceptions-io}{A maze is a grid of cells, each of which is either open or blocked. We can move from one free cell to another if they are adjacent. Design the \ttt{MazeSolver} class, which has the following methods:}

\begin{enumerate}[label=(\alph*)]
    \item \ttt{MazeSolver(String fileName)} is the constructor, which reads a description of a maze from a file. The file contains a grid of characters, where \ttt{`.'} represents an open cell and \ttt{`\#'} represents a blocked cell. The file is formatted such that each line is the same length. Read the data into a \ttt{char[][]} instance variable. You may assume that the maze dimensions are on the first line of the file, separated by a space.

    \item \ttt{char[][] solve()} returns a \ttt{char[][]} that represents the solution to the maze. The solution should be the same as the input maze, but with the path from the start to the end marked with \ttt{`*'} characters. The start is the top-left cell, and the end is the bottom-right cell. If there is no solution, return \ttt{null}.

    We can use a backtracking algorithm to solve this problem: start at a cell and mark it as visited. Then, recursively try to move to each of its neighbors, marking the path with a \ttt{`*'} character. If you reach the maze exit, then return \ttt{true}. Otherwise, backtrack and try another path. By ``backtrack,'' we mean that you should remove the \ttt{`*'} character from the path. If you have tried all possible paths from a cell and none of them lead to the exit, then return \ttt{false}. We provide a skeleton of the class below.

    \item \ttt{void output(String fileName, char[][] soln)} outputs the given solution to the maze to a file specified by the parameter. Refer to the above description for the format of the output file and the input \ttt{char[][]} solution.

\begin{lstlisting}[language=MyJava]
class MazeSolver {

  private final char[][] MAZE;

  MazeSolver(String fileName) { /* TODO read maze from file. */ }

  /**
   * Recursively solves the maze, returning a solution if it exists, 
   * and null otherwise. We use a simple backtracking algorithm 
   * in the helper.
   * @return a solution to the maze, or null if it does not exist.
   */
  char[][] solve() {
    char[][] soln = new char[MAZE.length][MAZE[0].length];
    return this.solveHelper(0, 0, soln) ? soln : null;
  }

  /**
   * Recursively solves the maze, returning true if we ever reach
   * the exit. We try all possible paths from the current cell, if
   * they are reachable. If a path ends up being a dead end, we 
   * backtrack and try another path.
   * @param r - the row of the current cell.
   * @param c - the column of the current cell.
   * @param sol - the current solution to the maze.
   * @return true if we are at the exit, false otherwise.
   */
  private boolean solveHelper(int r, int c, char[][] sol) { 
    /* TODO. */ 
  }
}
\end{lstlisting}
\end{enumerate}

\myexercise{3}{chapter-exceptions-io}{The \ttt{cut} program is a command-line tool for extracting pieces of text from data. For this exercise, you will implement a very basic version of the program that reads data from the terminal.}

\begin{enumerate}[label=(\alph*)]
    \item First, add support for the \ttt{-c $X,Y,\ldots,Z$} flag, which outputs the characters at positions $X,Y,\ldots,Z$ in each line. If any number is less than $1$, throw an \ttt{IllegalArgumentException}.
    \item Second, add support for the \ttt{-c $X$-$Y$} flag, which outputs the characters between and including positions $X$ and $Y$. This option should also work with comma separators.
    \item Third, add support for the \ttt{-c $X$-} and \ttt{-c -$Y$} flags, which print the characters from $X$ to the end of the line, and all characters up to $Y$.
    \item Fourth, Add support for the \ttt{-d$D$} and \ttt{-f$X$} flags. The former serves as a single character delimiter, and the latter indicates that $X$ is either an interval or a range of fields to print. The fields are delimited by $D$. Note that these two flags cannot be used without the other. The format of $X$ mirrors that of the input to the $-c$ flag. If $D$ does not exist on a line, then the entire line is printed.
\end{enumerate}

\myexercise{3}{chapter-exceptions-io}{The \ttt{sort} program is a command-line tool for sorting input from a data source. For this exercise, you will implement a very basic version of the program that reads data from the terminal.}

\begin{enumerate}[label=(\alph*)]
    \item First, allow the sort command to receive either a file or a list of data. If the \ttt{-d$D$} flag is passed, use $D$ as the delimiter. The default for a file is a newline, and the default for a non-file is the space.
    \item Second, add support for the \ttt{-r} flag for reversed sorting.
    \item Third, add support for the \ttt{-i} flag for case-insensitive sorting.
    \item Fourth, add support for the \ttt{-c} flag for checking to see if a file is sorted. Reports the first occurrence of out-of-order sort.
    \item Fifth, add support the the \ttt{-n} flag for sorting the values as if they are numbers. Notice the difference between sorting \ttt{9, 10, 8} with and without this flag.
    \item Sixth, add support for the \ttt{-u} flag for removing duplicate values.
    \item Seventh, add support for the \ttt{-o} flag for outputting to the file specified immediately after.
\end{enumerate}
Any of these flags should be composable with another, with the exception of \ttt{-o} whose output file is the next argument, and \ttt{-c}, which outputs any disorders to standard out.

\myexercise{3}{chapter-exceptions-io}{The \ttt{awk} program is a command-line tool for text parsing and processing. For this exercise, you will implement a very basic version of the program that reads data from the terminal. Be aware that this exercise is more in line with a mini-project.}

\begin{enumerate}[label=(\alph*)]
    \item Add support for the \ttt{-F} flag that, when immediately followed by a delimiter, uses that delimiter as a ``field separator'' when parsing input lines. For example, \ttt{-F,} uses a comma as the delimiter.
    \item Add the \ttt{-h} flag that ignores the first row in all subsequent commands. This is particularly useful when working with files that have headers, e.g., comma-separated value files.
    \item Next, add the \ttt{\q{}{print ...}\q{}} command. That is, the user should be able to type an open brace, followed by \ttt{print}, then some data, then a closing brace, all enclosed by single quotes. The \ttt{print} command receives multiple possible values, including `column labels', i.e., \ttt{$N$}, where $N$ is a column number. For example, \ttt{awk -F, '{print \$1}' input.csv} should print the first column of each row in the input file. 
    \item After getting the previous command to work, add support for inlined prefix operations in the \ttt{print} command. That is, suppose we want to print the sum of the second and fourth column of each row. To do this, we might write \ttt{awk -h -F, '{print (+ \$2 \$4)}' input.csv}. For simplicity, you may assume that there are only four operations: \ttt{\q{}+\q{}}, \ttt{\q{}-\q{}}, \ttt{\q{}*\q{}}, and \ttt{\q{}/\q{}}. 
    \item After getting the previous command to work, add multiple-argument support for \ttt{print}. That is, if we want to compute the product of the first three columns, output a string saying \ttt{" multiplied is " }, followed by the product, we could write \ttt{awk -h -F, '{print \$1,\$2,\$3 " multiplied is " (* \$1 \$2 \$3) }'}. Note that the delimiter between the column labels must match that passed by \ttt{-F}, otherwise there is no separator.
    \item After getting the previous command to work, add support for conditional expressions. That is, suppose we want to print the second column of a row only if it has a value greater than $200$. We can achieve this via \ttt{"awk -h -F, '{print \$2(> \$2 200)}'}. If you \emph{really} want a challenge, you can add support for inlining other arithmatic expressions into a conditional. For example, if we want to print the third column only if the sum of the first two columns exceeds $1000$, we might write \ttt{awk -h -F, '{print \$3(> (+ \$1 \$2) 1000)}'}.
    \item Finally, add the \ttt{-v=N:V} flag that acts as a variable map that can be used in a print command. That is, suppose we want to create a variable called \ttt{val} and assign to it \ttt{30}. We can do this via \ttt{-v=val:30}, then reference it in a \ttt{print} via \ttt{\$}, e.g., \ttt{awk -F, '{print \$val}'}.
\end{enumerate}

\myexercise{3}{chapter-exceptions-io}{A thesaurus is, in effect, a dataset of words/phrases and information about those words/phrases. For example, a thesaurus may contain a word's definition, synonyms, antonyms, part-of-speech, and more. There are hundreds of collections online that researchers use for sentiment analysis, natural language processing, and more. In this exercise you will create a mini-thesaurus parser that allows the user to lookup information about a word/phrase.}

\begin{enumerate}[label=(\alph*)]
    \item First, design the skeleton for the \ttt{Thesaurus} class. It should store a \ttt{Set<Word>} $S$ as an instance variable.
    \item Design the private and static \ttt{Word} class inside the \ttt{Thesaurus} class body. A \ttt{Word} stores a \ttt{String} $s$ and a \ttt{Map<String, List<String>>} $M$ as instance variables. The string is the word itself, and the map is an association of information ``categories'' to a list of content. For example, we can create a \ttt{Word} that represents \ttt{"happy"}, with an association of \ttt{"synonym"} to \ttt{List.of("content", "cheery", "jolly")}. Design the respective getters and setters for these two instance variables.
    \item In the \ttt{Word} class, design the \ttt{boolean updateCategory(String c, String v)} method, which receives a category $c$ and a value $v$, and updates the list mapped by $c$ to now include $v$. If \ttt{c} did not previously exist for that \ttt{Word}, add it to the map and return \ttt{false}. On the other hand, if $c$ did previously exist for that \ttt{Word}, update its association and return \ttt{true}.
    \item In the \ttt{Word} class, override the \ttt{equals} and \ttt{hashCode} methods to compare two \ttt{Word} objects for equality and generate the hash code respectively. Two \ttt{Word} objects are equal if they represent the same word.
    \item In the \ttt{Thesaurus} class, design the \ttt{List<String> getInfo(String c)} and \ttt{List<String> getInfo(String w, String c, int n)} methods, where the former calls the latter with \ttt{Integer.MAX_VALUE} as \ttt{n}. The latter, on the other hand, looks up $w$ in $S$, and
    \begin{itemize}
        \item If $\ttt{w}\not\in{S}$, return \ttt{null}.
        \item Otherwise, return $n$ items from the category $c$ of $w$. If $n$ is \ttt{Integer.MAX_VALUE}, return the entire list.
    \end{itemize}
    The list returned by both methods must be immutable and not a pointer to the reference in the map. Notice that we overload \ttt{getInfo} to perform different actions based on the number (and type) of received parameters.
\end{enumerate}