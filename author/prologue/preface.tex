\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}

A course in Java programming is multifaceted. 
That is, it covers several core concepts, including basic datatypes, strings, simple-to-intermediate data structures, object-oriented programming, and beyond. 
What is commonly omitted from these courses is the notion of proper unit testing methodologies. 
Real-world companies often employ testing frameworks to bullet-proof their codebases, and students who leave university without expose to such frameworks are behind their colleagues. 
Our textbook aims to rectify this delinquency by emphasizing testing from day one; we write tests before designing the implementation of our methods, a fundamental feature of test-driven development.

In our book, we \emph{design} methods rather than write them, an idea stemming from Felleisen's \emph{How to Design Programs}, wherein we determine the definition of our data, the method signature (i.e., parameter and return types), appropriate examples and test cases, and only then follow with the method implementation. 
Diving straight into a method implementation often results in endless hours of debugging that may have been saved by only a few minutes of preparation. 
Extending this idea into subsequent computer science courses is no doubt excellent.

At Indiana University, students take either a course in Python or the Beginner/Intermediate Student Languages (based on Scheme/Racket), the latter of which involves constant testing and remediation. 
Previous offerings of the successor course taught in Java lead students astray into a ``plug and chug'' mindset of re-running a program until it works.
Our goal is to stop this once and for all (perhaps not truly ``once and for all,'' but rather we aim to make it a less frequent habit) by teaching Java correctly and efficiently. 

Object-oriented programming (and, more noteworthy, a second-semester computer science course) is tough for many students to grasp, but even more so if they lack the necessary prerequisite knowledge. 
Syntax is nothing short of a different way of spelling the same concept; we reinforce topics that students should already have exposure to: methods, variables, conditionals, recursion, loops, and simple data structures. 
We follow this with the Java Collections framework, generics, object-oriented programming, exceptions, I/O, searching and sorting algorithms, algorithm analysis, and modern Java features such as pattern matching and concurrency. 

The ordering of topics presented in a Java course is hotly-debated and has been ever since its creation and use in higher education. 
Such questions include the location of object-oriented programming principles: do we start off with objects or hold off until later? 
Depending on the style of a text, either option can work. 
Even though we, personally, are more of a fan of the ``early objects'' approach, and is how we learned Java many moons ago, we choose to place objects later in the curriculum. 
We do this to place greater emphasis on testing, method design, recursion, and data structures through the Collections framework. 
Accordingly, after our midterm (roughly halfway through the semester), students should have a strong foundation of basic Java syntax sans objects and class design. 
The second half of the class is dedicated to just that: object-oriented programming and clearing up confusions that coincide and introduce themselves. 
Learning Java also includes two supplemental parts: one on searching, sorting, and algorithms, and another on modern Java features, the latter of which is not typically covered in its entirety within the span of a second-semester course.

We believe that this textbook can be used as any standard second-semester computer science course. 
At the high-school level, this book can be used as a substitute for the College Board's former AP Computer Science~AB course. 
Certainly, this text may be well-suited for an AP Computer Science~A course at the high-school level, but its material goes well beyond the scope of the AP exam and curriculum.
Instructors are free to omit certain topics that may have been covered in a prerequisite (traditionally-styled) Java course. 
In those circumstances, it may be beneficial to dive further into the chapters on algorithm analysis and modern Java pragmatics (i.e., parts III and IV). 
For students without a Java background (or instructors of said students), which we assume, we take the time to quickly yet effectively build confidence in Java's quirky syntax. 
Additionally, we understand that our approach to teaching loops (through recursion and a translation pipeline) may appear odd to some long-time programmers. 
So, an instructor may reorder these sections however they choose, but we highly recommend retaining our chosen ordering for pedagogical purposes, particularly for those readers that are not taking an accompanying (college) class that uses this text. 

At the end of Chapters 1--5, we present a slew of exercises to the readers, and we encourage them to do most, if not all, of the exercises.
Some tasks in the exercises serve as simple reinforcement of topics, whereas others are long-haul marathons that take many hours to complete. 
Several exercises have also been used as (written) exam questions.
We do not provide answers to the exercises because there are many ``avenues to success.''
Readers should collaborate with others to solve the problems and discuss difficulties and points of confusion in aims of clarification.

The diction of our book is chosen very carefully, with hourly of scrutiny dedicated to the paragraphs, sentence structure, and their accompanying presentation.
When we demonstrate an example, stop, and closely follow along.
Do not rush through it.
The words on the text remain in place, no matter the pace of the reader.
A page, example, exercise, or chapter may require multiple passes to fully digest the content.
Make notes in the margins, type out any examples and exercises, ask questions, and answer the questions posed by others.
Perhaps they may answer one of yours.

In addition to the meticulously-selected diction, we have also made a conscious effort to place all code listings onto a single page, so as to prevent the reader from flipping back and forth between pages. The effort, while successful in most cases, is not perfect, and there are instances where a code listing spans multiple pages. Even so, we strongly encourage readers who cannot type out the code listings to read each line of code, ensuring that they understand its purpose in the context of the surrounding program.

Once again, by writing this book, we wish to ensure that students are better prepared for the more complex courses in a common computer science curriculum, e.g., data structures, operating systems, algorithms, programming languages, and whatever else lies ahead. 
A strong foundation keeps students motivated and pushes them to continue even when times are arduous, which we understand there to be plenty thereof.
After all, not many moons ago were we in the shoes of our target audience!

\begin{flushright}
Have a blast!\\\emph{Joshua Crotts}
\end{flushright}