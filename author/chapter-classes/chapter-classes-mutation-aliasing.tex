\section{Object Mutation and Aliasing}
\label{chapter-classes-mutation-aliasing}

A limitation that we have purposefully imposed on our object/class design is the inability to modify the values of instance variables. 
Value mutation is a foreign concept in some programming languages, but we have made extensive use of it throughout our time in the land of Java. 
In this section, we discuss the implications of instance variable mutation, and how it can lead to unintended problems, but also how it can be used to our advantage.

To access a \ttt{private} instance variable, we design a non-\ttt{private} accessor method, which returns the instance variable. 
To \emph{modify} a \ttt{private} instance variable, we design a non-\ttt{private} mutator method\index{mutator method}\index{setter method}, which receives a parameter and assigns its value to the corresponding instance variable. 
Let's return to the \ttt{Point} class to demonstrate. 
Suppose that we instantiate a \ttt{Point} object~$p$ to the position $(7, 4)$, but we then wish to change or modify either coordinate. 
We can do so by calling the \ttt{setX} or \ttt{setY} methods, respectively. 
Testing setter methods is important to verify that a change occurred when invoking the setter/mutator method, which is confirmed through the accessor method. 

Another way of phrasing such an approach is that, when testing a mutator, we care about the \emph{side-effect}\index{side-effect} of the method rather than what it returns, namely nothing. 
Setter methods, or methods that modify outside values or data are definitionally \emph{impure}\index{impure}. 
Because we want to alter an instance variable, these can no longer be marked as \ttt{final}, so we remove the keyword.\footnote{This is not to suggest that we should never use \ttt{final} instance variables. In fact, we \emph{should} use \ttt{final} instance variables whenever possible, since object mutation introduces the possibility of easy-to-overlook bugs.}

%\enlargethispage{1\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;

class PointTester {

  @Test
  void testSetX() {
    Point p = new Point(7, 4);
    p.setX(3);
    assertEquals(3, p.getX());
  }

  @Test
  void testSetY() {
    Point p = new Point(7, 4);
    p.setY(2);
    assertEquals(2, p.getY());
    p.setY(p.getY() - 4);
    assertEquals(-2, p.getY());
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Point {

  private int x;
  private int y;

  Point(int x, int y) { 
    this.x = x; 
    this.y = y; 
  }

  int getX() { return this.x; }

  int getY() { return this.y; }

  void setX(int x) { this.x = x; }

  void setY(int y) { this.y = y; }
}
\end{lstlisting}

\newpage %ugh
What are some consequences to mutating an object? 
One such consequence comes through the notion of \emph{object aliasing}. 
Recall that objects point to references in memory. 
Therefore, if we instantiate a \ttt{Point}~$p_1$, then initialize another \ttt{Point}~$p_2$ to~$p_1$, then both objects refer to the same \ttt{Point} instance in memory. 
If we modify~$p_1$ through a setter method, then~$p_2$ is also affected.

\enlargethispage{-3\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {

  @Test
  void testPointAliasing() {
    Point p1 = new Point(7, 4);
    Point p2 = p1;
    p1.setX(3);
    assertAll(
      () -> assertEquals(3, p1.getX()),
      () -> assertEquals(3, p2.getX()),
      () -> assertEquals(p1, p2));
  }

  @Test
  void testSetX() {
    Point p1 = new Point(11, 13);
    Point p2 = p1;
    p2.setX(100);
    assertAll(
      () -> assertEquals(100, p1.getX()),
      () -> assertEquals(100, p2.getX())
      () -> assertEquals(p1, p2));
  }

  @Test
  void testSetY() {
    Point p1 = new Point(7, 4);
    Point p2 = p1;
    p1.setY(2);
    assertAll(
      () -> assertEquals(2, p1.getY()),
      () -> assertEquals(2, p2.getY()),
      () -> assertEquals(p1, p2));
  }
}
\end{lstlisting}

Aliasing carries over to other, more complex classes as well.
For example, strings, arrays, lists, and others are all objects, and therefore, are subject to object aliasing. 
Modifying one \ttt{ArrayList} instance will modify all other \ttt{ArrayList} instances that reference the same object. 
Unintentional aliasing (or its associated actions) is a common source of bugs in Java programs, and it is important to be aware of this behavior. 

In the following example, we will demonstrate aliasing through the \ttt{ArrayList} data structure containing \ttt{Point} objects.
We add a series of \ttt{Point} instances to an \ttt{ArrayList}, which is then aliased by another \ttt{ArrayList}. 
We then add another \ttt{Point} instance to the first \ttt{ArrayList}, followed by a verification that the lists are the same size. 
We traverse over the lists and verify that the elements are the same through the \ttt{==} operator. 
Remember that \ttt{==} returns whether or not two objects reference the same instance in memory. 
Because these lists are merely aliases of each other, they will, in fact, contain references to the same \ttt{Point} instances.

%\enlargethispage{1\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;
import static Assertions.assertTrue;

import java.util.ArrayList;
import java.util.List;

class PointTester {

  @Test
  void testPointArrayListAliasing() {
    Point P1 = new Point(7, 4);
    Point P2 = new Point(3, 2);
    Point P3 = new Point(1, 8);

    List<Point> list1 = new ArrayList<>(List.of(P1, P2, P3));
    List<Point> list2 = list1;
    list1.add(new Point(5, 6));

    // First we can verify that the lists are actually the same.
    assertTrue(list1 == list2);

    // Size testing.
    assertTrue(list1.size() == list2.size());

    // Make sure both lists contain the same elements.
    for (int i = 0; i < list1.size(); i++) {
      assertTrue(list1.get(i) == list2.get(i));
    }

    // If we want, we can also verify that the content, i.e.,
    // the coordinates of the points in both are equal.
    for (int i = 0; i < list1.size(); i++) {
      assertTrue(list1.get(i).getX() == list2.get(i).getX()
              && list1.get(i).getY() == list2.get(i).getY());
    }
  }
}
\end{lstlisting}

\newpage %ugh
\myexample{Now that we have classes, accessibility, and mutation, we can implement generic data structures such as an \ttt{ArrayList}.} 
In this example, we will design a class that matches the behavior of the \ttt{ArrayList} class. 
Let's design the \ttt{MiniArrayList} class, which operates over any type using generics. 
Like generic static methods, we must quantify the generic type, but unlike static methods, however, we quantify the type over the class declaration, meaning that all instance methods observe/respect the quantify and do not need to be separately quantified. 
Static methods still necessitate the generic quantifier in their signatures.\footnote{Static methods are not tied to any instance of the class (nor its generic type), so they must be quantified separately.}

In addition to the class header, what else does an \ttt{ArrayList} store? 
Certainly, a backing array of elements and its corresponding length. 
The array, as we described in Chapter~\ref{chapter-arrays-collections}, ``dynamically resizes'' as we add or insert elements. 
The logical size of the array, i.e., the number of presently-existing elements is its \ttt{size}, whereas the current capacity, i.e., how many elements can currently be stored without a resize, is its \ttt{capacity}. 

Our class will provide two constructors: one that instantiates the backing array to store ten elements, and another that allows the user to specify the initial capacity. 
Interestingly, this shows off a great example of one constructor calling another of the same class, an idea called \emph{constructor chaining}. 
``Ten,'' however, is a magic number: a number whose context is the only thing that determines its meaning. 
So, let's refactor it into a constant class variable with a relevant identifier.

\begin{lstlisting}[language=MyJava]
class MiniArrayList<T> {

  private static final int DEFAULT_CAPACITY = 10;

  private T[] elements;
  private int size;
  private int capacity;

  MiniArrayList() { 
    this(DEFAULT_CAPACITY); 
  }

  MiniArrayList(int capacity) {
    this.size = 0;
    this.capacity = capacity;
  }
}
\end{lstlisting}

Notice that we declare an array of type \ttt{T} to store the elements of our mini array list. 
We now must instantiate the array inside the second constructor. 
The problem we immediately encounter is that we cannot instantiate an array of a generic type, because Java arrays utilize runtime information about the element type. 
Generics, on the other hand, are a compile-time feature, meaning it is impossible to directly instantiate an array of a generic type. 
Instead, we must instantiate an array containing (elements of) type \ttt{Object}, followed by a cast to contain (elements of) type \ttt{T}.\footnote{To be pedantic, the array is of type \ttt{Object[]}, and we cast it to type \ttt{T[]}.} 
This is called an \emph{unchecked cast}, and it is a necessary evil in Java to support powerful classes that operate over generic arrays.

\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
class MiniArrayList<T> {

  private static final int DEFAULT_CAPACITY = 10;

  private T[] vals;
  private int size;
  private int capacity;

  MiniArrayList() { 
    this(DEFAULT_CAPACITY); 
  }

  MiniArrayList(int capacity) {
    this.size = 0;
    this.capacity = capacity;
    this.vals = (T[]) new Object[this.capacity];
  }
}
\end{lstlisting}

We now need to implement the \ttt{add} method, which adds an element to the end of the array list. 
We first check if the array is full, and if so, resize the array. 
We then add the element to the end of the array and increment the size. 
Resizing the array is, fortunately, not complicated; all we need to do is instantiate a new, larger array, copy the existing elements over, then reassign the instance variable. 
The question now is, by what factor should the array capacity increase? 
This decision is implementation-dependent, but we will use a doubling factor out of common practice.\footnote{Another logical choice is to increase the capacity linearly based on the default capacity. This choice removes the need for an extra static variable.} 
We make \ttt{resize} private because it is an implementation detail that the programmer who uses \ttt{MiniArrayList} should not concern themselves over. 

To write coherent tests, we should also write the \ttt{get} method, which returns the element at a given index, as well as \ttt{size}, which returns the number of logical elements in the list. 
For now, we will not consider invalid inputs, e.g., negative array indices, and all inputs to methods are assumed to be semantically correct.

%\enlargethispage{5\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class MiniArrayListTester {

  @Test
  void testAdd() {
    MiniArrayList<Integer> list = new MiniArrayList<>();
    list.add(100);
    list.add(200);
    list.add(300);
    assertAll(
      () -> assertEquals(3, list.size()),
      () -> assertEquals(100, list.get(0)),
      () -> assertEquals(200, list.get(1)),
      () -> assertEquals(300, list.get(2)));
  }
}
\end{lstlisting}

\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
class MiniArrayList<T> {

  private static final int RESIZE_FACTOR = 2;

  /**
   * Adds an element to the end of the list.
   * @param element the element to add.
   */
  void add(T element) {
    if (this.size == this.capacity) { 
      this.resize(); 
    }
    this.vals[this.size++] = element;
  }

  /**
   * Retrieves an element at a given index. The index should
   * be in-bounds. If not, an ArrayIndexOutOfBoundsException is thrown.
   * @param index list index between 0 <= i < L.size()
   * @return item at the given index.
   */
  T get(int index) { 
    return this.vals[index]; 
  }

  /**
   * Returns the logical size of the list, i.e., the number of 
   * actual elements in the list.
   * @return number of elements.
   */
  int size() { 
    return this.size; 
  }

 /**
  * Resizes the backing array by a factor specified by the class.
  */
  private void resize() {
    this.capacity *= RESIZE_FACTOR;
    T[] newArray = (T[]) new Object[this.capacity];
    for (int i = 0; i < this.size; i++) { 
      newArray[i] = this.vals[i]; 
    }
    this.vals = newArray;
 }
}
\end{lstlisting}

We will write two more methods: \ttt{insert} and \ttt{remove}, which inserts an element~$e$ at a given index~$i$, and removes an element~$e$ respectively. 
These two methods are similar in that they alter the backing array by shifting its values right and left. 
Accordingly, our implementation will contain the private helper methods \ttt{shiftRight} and \ttt{shiftLeft}. 
If we attempt to insert an element into a list that must be resized, we call \ttt{resize}. 
Both \ttt{insert} and \ttt{remove} warrant new test cases.
Like the \ttt{get} counterpart, neither of these new methods will perform bounds checking, so testing out-of-bounds behavior is not pertinent.

\enlargethispage{-3\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class MiniArrayListTester {

  @Test
  void testInsert() {
    MiniArrayList<Integer> list = new MiniArrayList<>();
    list.add(100);
    list.add(300);
    list.insert(1, 150);
    assertAll(
      () -> assertEquals(3, list.size()),
      () -> assertEquals(100, list.get(0)),
      () -> assertEquals(150, list.get(1)),
      () -> assertEquals(300, list.get(2)));
  }

  @Test
  void testRemove() {
    MiniArrayList<Integer> list = new MiniArrayList<>();
    list.add(100);
    list.add(300);
    list.remove(0);
    assertAll(
      () -> assertEquals(1, list.size()),
      () -> assertEquals(300, list.get(0)));
  }
}
\end{lstlisting}

%\enlargethispage{5\baselineskip}
\begin{lstlisting}[language=MyJava]
class MiniArrayList<T> {
  // ... previous code not shown.

  /**
   * Inserts an element at the given index.
   * @param e the element to insert.
   * @param idx the index to insert at.
   */
  void insert(T e, int idx) {
    if (this.size == capacity) { 
      this.resize(); 
    }
    this.shiftRight(idx);
    this.vals[idx] = e;
  }

  /**
   * Removes the element at the given index.
   * @param idx the index to remove.
   * @return the element removed.
   */
  T remove(int idx) {
    T e = this.get(idx);
    this.shiftLeft(idx);
    this.size--;
    return e;
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class MiniArrayList<T> {

  /**
   * Shifts all elements to the left of the given index 
   * one position leftwards. Note that this method overwrites 
   * the element at the given index.
   * @param idx the index to shift left of.
   */
  private void shiftLeft(int idx) {
    for (int i = idx; i < this.size - 1; i++) { 
      this.vals[i] = this.vals[i + 1]; 
    }
  }

  /**
   * Shifts all elements to the right of the given index 
   * one position rightwards.
   * @param idx the index to shift right of.
   */
  private void shiftRight(int idx) {
    for (int i = size - 1; i > idx; i--) { 
      this.vals[i] = this.vals[i - 1]; 
    }
  }
}
\end{lstlisting}

\myexample{Let's see a few more examples of object aliasing and mutation.} 
These examples will not be meaningful in what they represent, but are great exercises in testing your understanding. 

Let's consider five classes: \ttt{A}, \ttt{B}, \ttt{C}, \ttt{D}, and \ttt{E}. 
Class \ttt{A} contains one mutable string instance variable; its constructor assigns the instance variable to the parameter thereof. 
Classes \ttt{B} and \ttt{C} are identical aside from the name: they contain an immutable object of type \ttt{A} as an instance variable. 
Class \ttt{D} stores an integer array of ten elements. 
Finally, class \ttt{E} stores a mutable integer as an instance variable.

We present several test cases that assert different pieces of these classes. 
We will analyze each one and determine why it uses either \ttt{assertEquals} or \ttt{assertNotEquals} in its comparison. 
Our first series of tests only focuses on classes \ttt{A}, \ttt{B}, and \ttt{C} to keep things simple. 
We insert blanks in the assertion statements for you to fill in as exercise before checking your answers.

\newpage %ugh
\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;
import static Assertions.assertNotEquals;

class ClassTester {

  @Test
  void testOne() {
    final A a = new A("Hello!");
    B b = new B(a);
    C c = new C(a);
    assert______(b.getA(), c.getA());
    assert______(b.getA().getS(), c.getA().getS());
    a.setS("Hi!");
    assert______(b.getA().getS(), c.getA().getS());
    b.getA().setS("howdy!");
    assert______(b.getA().getS(), c.getA().getS());
    B b2 = new B(a);
    assert______(a, b2.getA());
    assert______(b, b2);
    b = b2;
    assert______(a, b.getA());
    assert______(b, b2);
  }
}
\end{lstlisting}

To set the scene, we first declare \ttt{a} as an immutable instance of \ttt{A} with the string literal \ttt{"Hello!"}. 
Then, we instantiate objects \ttt{b} and \ttt{c} of types \ttt{B} and \ttt{C} respectively, each receiving \ttt{a} as an argument to their constructors. 

Comparing \ttt{b.getA()} against \ttt{c.getA()} is a comparison of two references to the same object. 
Because \ttt{a} is immutable, we cannot change its value, so both \ttt{b} and \ttt{c} will always refer to the same object. 
Therefore, we use \ttt{assertEquals} to compare the two references. 
In particular, passing \ttt{a} to both constructors passes a reference to the same object.

\begin{figure}[htp!]
\centering
\begin{tikzpicture}
  % Object a
  \node[rectangle, draw] (a) {\texttt{a = 0xffff2345}};

  % References b and c
  \node[above left=of a,on grid,align=left] (b) {\texttt{B b = new B(a);}\\\texttt{b.getA();}};
  \node[above right=of a,on grid, align=left] (c) {\texttt{C c = new C(a);}\\\texttt{c.getA();}};

  % Arrows
  \draw[-{Latex[length=2mm]}] (b) -> (a);
  \draw[-{Latex[length=2mm]}] (c) -> (a);

  % Annotations
%   \node[below=0.5cm of a] (note) {Both `\texttt{b.getA()}' and `\texttt{c.getA()}' refer to the same `\texttt{a}' instance in memory};
% \node[below of=note] (note2) {Assume `\texttt{a}' is instantiated as `\texttt{new A()}' and points to address \texttt{0xffff2345}};

  % Equality Check Illustration (optional)
  % ... (Can be an inset showing assertEquals usage)
\end{tikzpicture}
\caption{Memory Aliasing Example}
\label{fig:memoryref}
\end{figure}

In Figure~\ref{fig:memoryref}, we use memory addresses to refer to the location of \ttt{a}. To be a bit pedantic, objects are not stored directly in system memory per se, but rather a location accessible by the Java Virtual Machine.

Comparing \ttt{b.getA().getS()} against \ttt{c.getA().getS()} is a comparison of two references to the same object, similar to the previous problem, right? Wrong! Recall that the \ttt{String} class overrides the \ttt{equals} method implementation to compare strings for their content rather than their reference. Should we choose to compare the two strings for referential equality, we must use the \ttt{==} operator. In this case, we use \ttt{assertEquals} since the two strings are equal in content, but using \ttt{==} would also work because the strings are also equal in reference.

In the third line we change the value of the string inside \ttt{a} to be \ttt{"Hi!"}, which updates across all instances that point to \ttt{a}. Therefore, rerunning the same comparison as before still results in a true equality.

In the fifth line, we retrieve the \ttt{A} object instance pointed to by \ttt{B} and change its underlying string to be \ttt{"Howdy!"}. Rerunning the same test as before yet again results in a true equality. Because \ttt{b} points to the same \ttt{a} that \ttt{c} references, this change propagates across all references to \ttt{a}, even if we do not directly modify \ttt{a}.

We then declare a new instance of \ttt{B} named \ttt{b2}, which references the same \ttt{a} as before. If we check the value of \ttt{a} against the value of \ttt{a} inside \ttt{b2}, we of course get a true equality.

We immediately follow this comparison with one in which we compare \ttt{b} to \ttt{b2}. Because these are completely distinct object instantiations, the equality does not hold true.

Up next we reassign \ttt{b} to point to \ttt{b2}. This is a reassignment of a reference, not a reassignment of an object. Therefore if we check \ttt{b} against \ttt{b2} for equality, it is now trivially true.

\myexample{Let's do another aliasing test, this time to involve arrays of objects. We will operate over a class \ttt{E} that stores a single number, similar to how the \ttt{Integer} class works.}

\begin{lstlisting}[language=MyJava]
class E {

  private int val;

  E(int v) { this.val = v; }

  int getNumber() { return this.val; }

  void setNumber(int v) { this.val = v; }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;
import static Assertions.assertNotEquals;

class ClassTester {

  @Test
  void testTwo() {
    E e = new E(42);
    E[] arrOfE = new E[10];
    for (int i = 0; i < arrOfE.length; i++) { arrOfE[i] = new E(i); }
    assert______(arrOfE[2], arrOfE[5]);
    assert______(arrOfE[2].getNumber(), arrOfE[5].getNumber());

    for (int i = 0; i < arrOfE.length; i++) { arrOfE[i] = e; }
    assert______(arrOfE[0], arrOfE[2]);
    assert______(arrOfE[0].getNumber(), arrOfE[2].getNumber());
    arrOfE[7].setNumber(102);
    assert______(arrOfE[0].getNumber(), arrOfE[2].getNumber());
  }
}
\end{lstlisting}

The object \ttt{e} is instantiated to a new instance of \ttt{E}, whose constructor receives \ttt{42} as an argument. Thereafter we instantiate \ttt{arrOfE} to be an array of ten \ttt{E} objects. The following loop then instantiates each index of the array to a new, distinct \ttt{E} object with the integer \ttt{i} as an argument to the constructors.

So, what happens if we compare any arbitrary element $e$ against any other arbitrary element $e'$ such that $e \neq e'$? Because they are all instantiated to distinct instances of \ttt{E}, any equality comparison is false. We can extend this to retrieving the number inside each \ttt{E} object and comparing them. Each \ttt{E} instance receives a different value of~$i$, entailing that the equality does not hold.

The second loop assigns the \ttt{e} object to each index of the array. 
We can then compare any arbitrary element against any other arbitrary element, and they will always be equal according to both \ttt{==} and \ttt{equals}, since every element is a reference to the same memory reference. 
Thus, changing the stored integer value at one index propagates to every other element in the array, because again, all references point to the same object.
Preceding the final assertion is an assignment of a new \ttt{E} instance to index four that boxes the integer~$2$. 
Changing any index aside from four modifies \ttt{e}, but does not modify the instance of \ttt{E} at index four, the converse of which also holds.

\myexample{Let's get even more practice with aliasing over arrays. Suppose we have the following code segment:}

\begin{lstlisting}[language=MyJava]
class ArrayAliasingTester {

  static int baz(int[] A) {
    A[3] = 42;
    return A[3];
  }

  static int modify(int[] A) {
    A = new int[100];
  }

  @Test
  void testBaz() {
    int[] A = new int[]{0, 0, 0, 0, 0};
    A[2] = baz(A);
    assertEquals(84, A[2] + A[3]);

    int[] B = new int[]{0, 0, 0, 0, 0, 0};
    int[] C = B;
    assert______(84, C[3] + baz(B));

    int[] D = new int[]{0, 0, 0, 0, 0, 0, 0};
    int[] E = D;
    int res = baz(E);
    assert______(84, D[3] + res);  
    D = new int[]{1, 2, 3, 4, 5, 6, 7};
    assert______(E, D);  

    int[] F = new int[]{0, 1, 2, 3, 4};
    int h1 = F.hashCode();
    modify(F);
    assertEquals(h1, F.hashCode());
  }
}
\end{lstlisting}

Again, we encourage the readers to stop and think about what kinds of assertions to fill in the blanks. Consider what happens when arrays are passed to methods, then continue onward to check your understanding.

We start by examining the \ttt{baz} method, which receives an array of integers~$A$ as a parameter, overwrites the value at index~$3$ to be~$42$, then returns that element. 

Inside the JUnit tester method, we first instantiate an array~$A$ to contain five zeroes. Afterwards, we assign, to index 2 of~$A$, the value of invoking \ttt{baz(A)}, meaning \ttt{A[2]} is $42$, but so is \ttt{A[3]}, because passing an array to a method passes a copy of the reference to the array. 
Therefore, the index of the passed array is mutated. 
We assert whether the sum of these two elements is~$84$, which is true because $42+42=84$.

Second, we instantiate an array~$B$ to contain six zeroes. This is followed by an initialization of an array~$C$ to point to~$B$, meaning~$C$ is an alias for~$B$. We then assert whether the sum of \ttt{C[3]} and \ttt{baz(B)} is~$84$. The answer relies on an understanding of evaluation order. The plus operator evaluates its arguments from left-to-right. Before invoking \ttt{baz(B)}, the value of \ttt{C[3]} is zero, so the left-hand side of the addition is zero. Immediately after, we evaluate \ttt{baz(B)}, which mutates not only index~$3$ of~$B$, but also index~$3$ of~$C$, because again, $C$ aliases~$B$. The expression is now an addition of~$0$ and~$42$, which is certainly not equal to~$84$.

Third, we instantiate yet another array~$E$ to contain seven zeroes. We then alias the array~$D$ to~$E$, followed by a call to \ttt{baz(E)}, whose result is stored in the \ttt{res} variable. We know for certain that \ttt{res} contains \ttt{42}, and we want to know whether \ttt{D[3]} also contains~$42$ to sum to the expected value of $84$. Because~$D$ aliases~$E$, it must be the case that \ttt{D[3]} is also~$42$, meaning we assert equals.

The fourth assertion is the result of altering~$D$'s reference. Recall that~$D$ initially references the new integer array of seven zeroes. The~$D$ array becomes an alias to~$E$, which might suggest that changing~$E$ also changes what~$D$ points to, but this is not the case. When we instantiate~$E$ to point to the new array of the integers from 1 to 7, $D$ remains aliased to the array of seven zeroes that~$E$ was instantiated to. Therefore, the assertion should be not equals.

Finally, we instantiate an array~$F$ to contain the integers from~$0$ to~$4$ inclusive. We compute the hash code of~$F$ and store it inside~$h_1$. Then, we pass~$F$ to the \ttt{modify} method, which appears to modify the passed reference to point to a new array. In the previous chapter we mentioned ``pass by pseudo-reference,'' which alluded to this problem. When we pass an object to a method, we pass a copy \emph{of} the reference rather than the reference itself. Changing what the copy points to does not change the reference outside the context of the \ttt{modify} method. So, we should assert equals on~$h_1$ and the hash code of~$F$ after invoking \ttt{modify}, since~$F$'s reference is never altered.

\myexample{Some readers may question why we emphasize mutation and aliasing. When working with the Collections framework and designing data structures, proper care must be taken to avoid undesired behavior and outcomes. Consider what happens if we design a class \ttt{F} whose constructor receives a \ttt{List<Integer>}, which is assigned directly to an instance variable. Then, suppose we instantiate two distinct instances of \ttt{F}, namely $f_1$ and $f_2$, each of which receive the same (reference to a) list of numbers. If we then mutate the list somewhere inside of $f_1$, then the list stored as a reference inside $f_2$ also contains the change.}

\enlargethispage{1\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class ClassTester {

  @Test
  void testListAliasing() {
    List<Integer> ls = new ArrayList<>(List.of(1, 2, 3, 4, 5));
    F f1 = new F(ls);
    F f2 = new F(ls);
    f1.getList().set(2, 100);
    assertEquals(100, f1.getList().get(2));
    assertEquals(100, f2.getList().get(2));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.List;

class F {
  
  private final List<Integer> LS;
  
  F(List<Integer> ls) { this.LS = ls; }
  
  List<Integer> getList() { return this.LS; }
}
\end{lstlisting}

\myexample{Recall the \ttt{LinkedList} class from Chapter~\ref{chapter-arrays-collections}. If you have ever wondered how it works under the hood, now is the time to find out! We will design a \emph{doubly-linked list} data structure that stores arbitrarily-typed elements.}

First, remember the structure of a linked list: it is composed of nodes, which hold the data and a pointer to the next element in the chain/sequence. These types of linked lists are \emph{singly-linked}, because nodes only refer to the successive element. In contrast, our class models a doubly-linked list, since its nodes point to their successor \emph{and} their predecessor. 

We need a generic class that stores references to the first and last elements of the list. Let's design the \ttt{DoublyLinkedList} class to receive a type parameter \ttt{T}, and store the first and last nodes as instance variables. It's important to realize that, whoever uses this class will not (and should not) be exposed to the innards of the class, i.e., how the links are established/constructed/altered/removed. After all, we wish to preserve the encapsulation motif.

We run into an imminent problem when declaring the types of the instance variables: what \emph{should} they be? 
We need to design a class that encapsulates the value of the node, and holds references to its previous and successor nodes. 
Some programmers may consider designing a separate \ttt{.java} file for this class, but remember the encapsulation methodology: nobody outside of this class should even be aware that nodes exist in the first place. 
So, we can create a private and static \ttt{Node<T>} class, which is local to the definition of \ttt{DoublyLinkedList}. 
A privatized class can only ever be static, because it is nonsense to say that a private class definition belongs to an arbitrary instance of the class in which it resides.\footnote{Such a claim would imply that every instance of the \ttt{DoublyLinkedList} class would carry the data for instantiating nodes, which is wasteful.} 
We also override the \ttt{toString} method to output a stringified representation of underlying node data.

\enlargethispage{2\baselineskip}
\begin{lstlisting}[language=MyJava]
class DoublyLinkedList<T> {

  private static class Node<T> {

    private T value;
    private Node<T> prev;
    private Node<T> next;

    private Node(T value) { this.value = value; }

    @Override
    public String toString() { return this.value.toString(); }
  }

  private Node<T> first;
  private Node<T> last;

  DoublyLinkedList() { this.last = this.first = null; }
}
\end{lstlisting}

Notice that, in the constructor of \ttt{DoublyLinkedList}, we assign the first and last references to each other, both of which point to \ttt{null}. 
An empty list contains neither a first nor a last element.

To test the methods that we are about to design, we will override the \ttt{toString} method (of \ttt{DoublyLinkedList}) to print the elements inside brackets, separated by commas and a space. To traverse over the list, however, we should use a custom-defined \ttt{Iterator}, which will be its own localized class definition. We have seen iterators before, but until now we have not implemented one on our own. The idea is, fortunately, very simple: we keep track of the current node, and upon calling \ttt{hasNext}, we return whether or not the node is \ttt{null}. Similarly, invoking \ttt{next} returns the value of the stored node and moves the pointer forward via the ``next'' instance. Finally, we create the \ttt{.iterator} method, which returns an instance of the iterator superclass. There is no desire to expose the implementation of the iterator to the caller; they are only concerned with iterating over the doubly-linked list.

\begin{lstlisting}[language=MyJava]
import java.util.Iterator;

class DoublyLinkedList<T> {
  // ... previous code not shown.

  Iterator<T> iterator() {
    return new DoublyLinkedListIterator<>(this.first);
  }

  private static class DoublyLLIterator<T> implements Iterator<T> {
    
    private Node<T> current;

    private DoublyLLIterator(Node<T> first) {
      this.current = first;
    }

    @Override
    boolean hasNext() { 
      return this.current != null; 
    }

    @Override
    T next() {
      T value = this.current.value;
      this.current = this.current.next;
      return value;
    }
  }
}
\end{lstlisting}

Using the iterator in \ttt{toString} is straightforward: we have a while loop that continues until no more elements are present. We complete two tasks at the same time by having an iterator, which then makes subsequent traversals over the list easier.

Now we can write methods to add, retrieve, and remove elements from the list. To add an element, we need to take the links of \ttt{first} and \ttt{last}, and reassign them accordingly to remain consistent with our doubly-linked list property. If the list is empty, then we just have to assign the new node~$n$ to both the \ttt{first} and \ttt{last} references. Otherwise, we set the ``next'' pointer of \ttt{last} to~$n$, and set the ``previous'' pointer of~$n$ to \ttt{last}. 

\enlargethispage{-3\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class DoublyLinkedListTester {

  @Test
  void testAdd() {
    DoublyLinkedList<Integer> list = new DoublyLinkedList<>();
    assertAll(
      () -> assertEquals("[]", list.toString()),
      () -> list.add(1),
      () -> list.add(2),
      () -> list.add(3),
      () -> assertEquals("[1, 2, 3]", list.toString()),
      () -> list.add(4),
      () -> list.add(1),
      () -> list.add(5),
      () -> assertEquals("[1, 2, 3, 4, 1, 5]", list.toString()));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class DoublyLinkedList<T> {
  // ... previous code not shown.

  /**
   * Adds a new node to the end of the list.
   * @param data The data to be stored in the new node.
   */
  void add(T data) {
    Node<T> newNode = new Node<>(data);

    // If the list is empty, make the new node the first and last node.
    if (this.first == null) {
      this.first = newNode;
    } else {
      // Otherwise, add the new node to the end of the list.
      newNode.prev = this.last;
      this.last.next = newNode;
    }
    this.last = newNode;
  }
}
\end{lstlisting}

Retrieving an element is trivial, as it's just a matter of traversing over the list and returning the data at the index of a node. If the index is out of bounds, we return an empty \ttt{Optional}.\footnote{It is, in general, a better idea to use \emph{exceptions} when encountering bad inputs, but we have not covered them at this point in the text.}

\newpage %ugh
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class DoublyLinkedListTester {

  @Test
  void testGet() {
    DoublyLinkedList<Integer> list = new DoublyLinkedList<>();
    assertAll(
      () -> assertEquals(Optional.empty(), list.get(0)),
      () -> list.add(50),
      () -> list.add(25),
      () -> list.add(100),
      () -> assertEquals(Optional.of(50), list.get(0)),
      () -> assertEquals(Optional.of(25), list.get(1)),
      () -> assertEquals(Optional.of(100), list.get(2)),
      () -> assertEquals(Optional.empty(), list.get(3)),
      () -> list.add(1000),
      () -> list.add(10000),
      () -> list.add(50),
      () -> assertEquals(Optional.of(1000), list.get(3)),
      () -> assertEquals(Optional.of(10000), list.get(4)),
      () -> assertEquals(Optional.of(50), list.get(5)),
      () -> assertEquals(Optional.empty(), list.get(6)));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.Optional;

class DoublyLinkedList<T> {
  // ... previous code not shown.

  /**
   * Returns the element at a given index as an Optional.
   * @param idx index to retrieve.
   * @return Optional.empty() if the index is out of bounds,
   *         the data at that node's index otherwise.
   */
  Optional<T> get(int idx) {
    Node<T> curr = this.first;
    int i = 0;
    while (curr != null && i < idx) {
      curr = curr.next;
      i++;
    }
    return idx >= 0 && curr != null
            ? Optional.of(curr.data)
            : Optional.empty();
  }
}
\end{lstlisting}

%\enlargethispage{3\baselineskip}
Finally we arrive at element removal, which is not as cut-and-dry. We want to pass the element-to-remove (compared via \ttt{equals}), but we need to adjust the pointers accordingly. In particular, there are four cases to consider:

\begin{enumerate}[label=(\alph*)]
  \item If the element-to-remove~$e$ is the first of the list, then its successor is now the first. Its previous pointer is adjusted to now point to \ttt{null}.
  \item If the element-to-remove~$e$ is the last of the list, then its predecessor is now the last. Its next pointer is adjusted to now point to \ttt{null}.
  \item If the element to remove~$e$ is neither the first nor the last, we retrieve its previous node~$p$, its next node~$n$, and assign $p_\emph{next} = n$, and $n_\emph{prev} = p$. This, in effect, ``delinks''~$e$ from the list, and is eventually consumed/reclaimed by the garbage collector.
  \item If the element-to-remove~$e$ is not in the list, do nothing.
\end{enumerate}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class DoublyLinkedListTester {

  @Test
  void testRemove() {
    DoublyLinkedList<Integer> list = new DoublyLinkedList<>();
    assertAll(
      () -> list.add(50),
      () -> list.add(25),
      () -> list.add(100),
      () -> list.remove(50),
      () -> assertEquals("[25, 100]", list.toString()),
      () -> list.remove(100),
      () -> assertEquals("[25]", list.toString()),
      () -> list.remove(25),
      () -> assertEquals("[]", list.toString()),
      () -> list.remove(25),
      () -> assertEquals("[]", list.toString()));
  }
}
\end{lstlisting}

%\enlargethispage{6\baselineskip}
\begin{lstlisting}[language=MyJava]
class DoublyLinkedList<T> {
  // ... previous code not shown.

  /**
   * Removes an element from the linked list, if it exists.
   * @param data value to be removed, compared via .equals.
   */
  void remove(T data) {
    Node<T> curr = this.first;
    while (curr != null) {
      if (curr.data.equals(data)) { // Case 1: if it's the first.
        if (curr == this.first) {
          curr.next = this.first.next;
          this.first = curr.next;
        } else if (curr == this.last) { // Case 2: if it's the last.
          curr.prev.next = null;
          this.last = curr.prev;
        } else { // Case 3: if it's anything else.
          curr.prev.next = curr.next;
          curr.next.prev = curr.prev;
        }
        break;
      } else { curr = curr.next; }
    }
  }
}
\end{lstlisting}

\myexample{Some programming languages, e.g., C, do not come standard with data structures such as a map. A substitute for the common mapping data structure is called an \emph{association list}, originating with the Lisp programming language~\cite{lisp15}. Its desired purpose is nearly identical to that of a map, but with worse performance implications. In this example we will design such a structure, as if \ttt{Map} did not exist in Java.}

Associations lists, as their name implies, associate values to other values, like a map. In dynamically-typed languages, e.g., Scheme, association lists accept any type as their key and any type as their value. Therefore, we could have an association list that maps a string to an integer, or an integer to a list of strings, and so on. Should we want to use truly arbitrary types in the list, we can assign \ttt{Object} to both key and value types.

Our association list will support several methods that are related to their functional programming equivalents. 
In particular, we want a \ttt{lookup} method to retrieve the associated value of some element and an \ttt{extend} method to add a new association. 
Note that the \ttt{extend} method will, rather than modifying the current association list, return a new association list with the new association added. 
We want to preserve the idea of immutability, which is a common theme in functional programming.
Association lists, therefore, need to have a ``parent'' reference to keep track of those associations in the list that we extend from.\footnote{In the next section on abstract classes and interpreters, we will revisit this idea in greater detail.} 
We will also override the \ttt{toString} method to print the associations in a readable format. 

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class AssociationListTester {

  @Test
  void testAssociationList() {
    AssociationList<String, Integer> list = new AssociationList<>();
    assertAll(
      () -> assertEquals("[]", list.toString()),
      () -> list = list.extend("a", 1),
      () -> assertEquals("[(a, 1)]", list.toString()),
      () -> list = list.extend("b", 2),
      () -> assertEquals("[(b, 2), (a, 1)]", list.toString()),
      () -> list = list.extend("c", 3),
      () -> assertEquals("[(c, 3), (b, 2), (a, 1)]", list.toString()),
      () -> assertEquals(Optional.of(3), list.lookup("c")),
      () -> assertEquals(Optional.of(2), list.lookup("b")),
      () -> assertEquals(Optional.of(1), list.lookup("a")),
      () -> assertEquals(Optional.empty(), list.lookup("d")));
  }
}
\end{lstlisting}

\newpage %ugh
\begin{lstlisting}[language=MyJava]
import java.lang.StringBuilder;
import java.util.Optional;

class AssociationList<K, V> {
  
  private final K key;
  private final V value;
  private final AssociationList<K, V> parent;
  
  AssociationList() {
    this.key = null;
    this.value = null;
    this.parent = null;
  }

  private AssociationList(K key, V value, AssociationList<K, V> parent) {
    this.key = key;
    this.value = value;
    this.parent = parent;
  }
  
  /**
   * Returns the value associated with a given key.
   * @param key the key to lookup.
   * @return the value associated with the key, if it exists.
   */
  Optional<V> lookup(K key) {
    AssociationList<K, V> curr = this;
    while (curr != null) {
      if (curr.key.equals(key)) { return Optional.of(curr.value); } 
      else { curr = curr.parent; }
    }
    return Optional.empty();
  }
  
  /**
   * Adds a new association to the list.
   * @param key the key to associate.
   * @param value the value to associate.
   * @return a new association list with the new association.
   */
  AssociationList<K, V> extend(K key, V value) {
    return new AssociationList<>(key, value, this);
  }
\end{lstlisting}
%\enlargethispage{4\baselineskip}
\begin{lstlisting}[language=MyJava]
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("[");
    AssociationList<K, V> curr = this;
    while (curr != null) {
      sb.append(String.format("(%s, %s)", curr.key, curr.value));
      curr = curr.parent;
      if (curr != null) { sb.append(", "); }
    }
    sb.append("]");
    return sb.toString();
  }
}
\end{lstlisting}
Each association list in our representation stores exactly one association. 
Each time we extend the association, we create a new list that points to the previous list. 
This is a very inefficient way to store and lookup associations, at least when compared to data structures such as a \ttt{HashMap} or \ttt{TreeMap}. But, association lists are commonly used for adding (variable) bindings in a programming language, usually when writing simple interpreted languages.\footnote{This serves as foreshadowing for~\cref{chapter-classes}!}

\myexample{In Chapter~\ref{chapter-arrays-collections}, we began to explore and use the \ttt{Set} data structure from the Collections framework. One existing implementation of sets is the \ttt{HashSet}, which stores non-duplicate elements according to their hash codes. In this example we will design a related data structure called a \textit{hash table}\index{hash table}.}

Elements in a hash table are stored according to their hash code. 
The properties of a hash table (and the hashing function) guarantee very fast element lookup times, insertions, and removals. 
A straightforward hashing function is to modulo the hash code of the object by the capacity of the table. 
This way, every element is guaranteed a valid index into the table. 
The problem with this approach is that multiple objects may hash to the same ``bucket.'' 
For example, if the hash code of some object~$o_1$ is~$100$, and the capacity of the table is $40$, then we would store $o_1$ at index $100 \text{ mod } 40 = 2$. 
But, consider another object~$o_2$ with the hash code~$1000$, which we store at index $1000 \text{ mod } 40 = 2$. 
We cannot store multiple objects at the same index, so we need to perform \emph{collision resolution}\index{collision resolution}. 
A collision, as we just demonstrated, occurs when two objects hash to the same index. 

As noted in our initial discussion of hashable data structures, there are several algorithms for resolving hash collisions. The simplest, albeit the least performant, is \emph{chaining}, where each index of the hash table stores a list of elements. If two elements hash to the same index, then we walk the list at that index to query the hash table. 

Let's begin by designing the constructor, fields, and method skeletons for the generic \ttt{HashTable} class. It stores an array of list instances, and the constructor instantiates this array to a capacity specified as a static class variable. We will include a second constructor to allow the user of the class to specify a capacity. Our hash table will not be resizable at runtime.

\enlargethispage{-3\baselineskip}
\begin{lstlisting}[language=MyJava]
import java.util.LinkedList;
import java.util.List;

class HashTable<T> {

  private static final int DEFAULT_CAPACITY = 50;

  private final List<T>[] ELEMENTS;

  private int size;

  HashTable(int capacity) {
    this.ELEMENTS = new List<>[capacity];
    for (int i = 0; i < this.ELEMENTS.length; i++) {
      this.ELEMENTS[i] = new LinkedList<>();
    }
  }

  HashTable() { this(DEFAULT_CAPACITY); }

  /**
   * Adds a value to the hash table. We compute its hash code, then 
   * insert it onto the end of the bucket at that index in the table. 
   * If the value is already in the hash table, we return false and do 
   * not add it into the table.
   * @param v value to add.
   * @return true if the element (*;$\not\in$;*) hash table; false otherwise.
   */
  boolean add(T v) { /* TODO. */ }

  /**
   * Determines whether an element exists in the hash table. We compute 
   * the hash code of the input parameter, then traverse the bucket at 
   * that index.
   * @param v value to search for.
   * @return true if the element (*;$\in$;*) hash table; false otherwise.
   */
  boolean contains(T v) { /* TODO. */ }

  int size() { return this.size; }
}
\end{lstlisting}

The \ttt{add} method relies on \ttt{contains}, so we will design the latter first. We begin by computing the hash code of the given argument, then clamp that value to the bounds of the underlying array.\footnote{Java's modulo operator may return a negative number, so we wrap the operation in a call to \ttt{Math.abs}.} Every index in the table corresponds to a \ttt{LinkedList}, so we traverse the list in search of the element and return whether or not it exists.

Designing \ttt{add} is almost identical to \ttt{contains}: we compute the index-to-insert, traverse the list, and if the element is not in that list, we add it to the end and return \ttt{true}. Otherwise, the element is already in the table and we return \ttt{false}. Upon successfully adding an element to the table, we increment the \ttt{size} instance variable.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;
import static Assertions.assertFalse;
import static Assertions.assertTrue;

class HashTableTester {

  @Test
  void testHashTable() {
    HashTable<String> t = new HashTable<>();
    assertAll(
      () -> assertTrue(t.add("Tarski")),
      () -> assertTrue(t.add("Quine")),
      () -> assertTrue(t.add("Russell")),
      () -> assertTrue(t.add("Boole")),
      () -> assertFalse(t.add("Tarski")),
      () -> assertTrue(t.contains("Quine")),
      () -> assertFalse(t.contains("Carnap")),
      () -> assertEquals(4, t.size()));
  }
}
\end{lstlisting}

\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
class HashTable<T> {
  // ... other methods not shown.

  /**
   * Adds a value to the hash table. We compute its hash code, then 
   * insert it onto the end of the bucket at that index in the table. 
   * If the value is already in the hash table, we return false and 
   * do not add it.
   * @param v value to add.
   * @return true if the element (*;$\not\in$;*) hash table; false otherwise.
   */
  boolean add(T v) {
    if (this.contains(v)) { return false; } 
    else {
      int idx = Math.abs(v.hashCode() % this.BUCKETS.length);
      List<T> bucket = this.BUCKETS[idx];
      bucket.add(v);
      this.size++;
      return true;
    }
  }

 /**
  * Determines whether an element exists in the hash table. We compute 
  * the hash code of the input parameter, then traverse the bucket at 
  * that index.
  * @param v value to search for.
  * @return true if the element (*;$\in$;*) hash table; false otherwise.
  */
  boolean contains(T v) {
    int idx = Math.abs(v.hashCode() % this.BUCKETS.length);
    List<T> bucket = this.BUCKETS[idx];
    return bucket.stream()
                 .anyMatch(t -> t.equals(v));
  }
}
\end{lstlisting}
