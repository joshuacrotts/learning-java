\section{Exercises}

\myexercise{1}{chapter-classes}{Design the \ttt{Car} class, which stores a \ttt{String} representing the car's make, a \ttt{String} representing the car's model, and an \ttt{int} representing the car's year. Its constructor should receive these three values and store them in the instance variables. Be sure to write instance accessor and mutator methods for modifying all three fields. That is, you should write \ttt{getMake()}, \ttt{setMake(String s)}, and so forth, to access and modify the fields directly.}

\myexercise{1}{chapter-classes}{Design the \ttt{Dog} class, which stores a \ttt{String} representing the breed, a \ttt{String} representing its name, and an \ttt{int} representing its age in years. You should also store a boolean to keep track of whether or not the dog is a puppy. A dog is a puppy if it is less than two years old. Its constructor should receive these three values and store them in the instance variables. Be sure to write instance accessor and mutator methods for modifying all three fields. That is, you should write \ttt{getBreed()}, \ttt{setBreed(String s)}, and so forth, to access and modify the fields directly.}

\myexercise{1}{chapter-classes}{Design the \ttt{Person} class, which stores a \ttt{String} representing the person's first name, a \ttt{String} representing the person's last name, and an \ttt{int} representing the person's age in years. Its constructor should receive these three values and store them in the instance variables. Be sure to write instance accessor and mutator methods for modifying all three fields. That is, you should write \ttt{getFirstName()}, \ttt{setFirstName(String s)}, and so forth, to access and modify the fields directly.}

% \myexercise{1}{chapter-classes}{Design the \ttt{Employee} class, which stores the employee's first and last names as strings, their birth year as an integer, their yearly salary as a double (we will assume that all employees are paid some value greater than zero), and their employee ID as a string.}
    
% To make things interesting, assume that an employee's ID is not alterable and must be set in the constructor. The employee ID is constructed using the first five characters of their last name, the first letter of their first name, and the last two digits of their birth year. For instance, if the employee's name is \ttt{Joshua Crotts} and their birth year is \ttt{1999}, their employee ID is \ttt{CrottJ99}. Its constructor should receive the name, birth year, and salary as parameters, but build the employee ID from the name and birth year.

% The instance variables, accessors, and mutators (where applicable) should be named as follows:
% \begin{itemize}
%     \item \ttt{id}, \ttt{getId}.
%     \item \ttt{firstName}, \ttt{getFirstName}.
%     \item \ttt{lastName}, \ttt{getLastName}.
%     \item \ttt{birthYear}, \ttt{getBirthYear}.
%     \item \ttt{salary}, \ttt{getSalary}, \ttt{setSalary}
% \end{itemize}

% Then, design the following methods:

% \begin{enumerate}[label=(\alph*)]
%   \item \ttt{void bonus()} method, which updates the salary of an employee. Calling \ttt{bonus} on an employee increases their salary by ten percent.
%   \item Override the \ttt{public boolean equals(Object o)} and \ttt{public String toString()} methods from the \ttt{Object} class to compare two employees by their employee ID and to print the employee's name, birth year, salary, and employee ID respectively separated by commas and a space. Do not add a comma and space after the last field.
% \end{enumerate}

\myexercise{2}{chapter-classes}{In this exercise you will design a class for storing employees. This relies on having the \ttt{Employee} class and its subclasses from the chapter available.}
\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{Job} class, which stores a list of employees \ttt{List<Employee>} as an instance variable. Whether you choose to instantiate it as an \ttt{ArrayList} or a \ttt{LinkedList} is up to you and makes little difference for this particular question. Its constructor should receive no arguments. The instance variable, along with its accessor and mutator, should be named \ttt{employees}, \ttt{getEmployees}, and \ttt{setEmployees} respectively.
    \item Design the \ttt{void addEmployee(Employee e)} method, which adds an employee to the \ttt{Job}.
    \item Design the \ttt{void removeEmployee(Employee e)} method, which removes an employee from the \ttt{Job}.
    \item Design the \ttt{Optional<Double> computeAverageSalary()} method, which returns the average salary of all employees in the \ttt{Job}. If there are no employees, return an empty \ttt{Optional}.
    \item Design the \ttt{Optional<Employee> highestPaid()} method, which returns the employee whose salary is the highest of all employees in the \ttt{Job}. If there are no employees, return an empty \ttt{Optional}.
    \item Override the \ttt{public String toString()} method to print out the list of employees in the \ttt{Job}. To make this easy, you can simply invoke the \ttt{toString} method from the \ttt{List} implementation.
\end{enumerate}

\newpage %ugh
\myexercise{2}{chapter-classes}{In this exercise you will design a simple music system, similar to Spotify.}
\begin{enumerate}[label=(\alph*)]
  \item Design the \ttt{Song} class, which stores its \ttt{title}, \ttt{artist}, \ttt{genre}, and \ttt{length}. The first three fields are strings and the last is an integer. Create the accessor methods, then override \ttt{equals}, \ttt{hashCode}, and \ttt{toString}. You may choose how to override \ttt{toString}.
  \item Design the \ttt{Playlist} class, which stores the title of the playlist and a set of the songs in the list. In this class, create the accessor methods, then override \ttt{equals}, \ttt{hashCode}, and \ttt{toString}. Finally, design the \ttt{boolean addSong(Song s)} that attempts to add~$s$ to the set of songs. If it already exists, return false. Otherwise, add the song to the set and return true.
  \item Design the \ttt{User} class, which stores their name and a list of playlists. Its constructor should receive the name and assign it to the respective instance variable. Instantiate the list to a new \ttt{ArrayList}. Create the accessor methods, then override \ttt{equals}, \ttt{hashCode}, and \ttt{toString}.
  \begin{enumerate}[label=(\roman*)]
    \item Design the \ttt{boolean createPlaylist(String t, Song... S)} method, which receives a playlist title~$t$ and a variadic number of songs~$S$, attempts to create a playlist with the title$~t$. If it already exists, return false and do nothing else. Otherwise, declare a new \ttt{Playlist} to their list and add to it the given songs.
  \end{enumerate}
  \item Design the \ttt{MusicSystem} class, which stores a list of users and a set of all the songs in the system. In the constructor, instantiate these to an \ttt{ArrayList} and \ttt{HashSet} respectively.
  \begin{enumerate}[label=(\roman*)]
    \item Design the \ttt{void addUser(User u)} method that receives a user~$u$ and adds them to the list of users.
    \item Design the \ttt{boolean addSong(User u, String t, Song s)} method that, when given a user~$u$, a playlist title~$t$, and a song~$s$, adds $s$ to $u$'s playlist with the title~$t$. If~$u$ does not exist or~$t$ is not a title in a playlist authored by~$u$, return false.
    \item Design the \ttt{Map<User, Song> getLongestSong()} method that returns the longest (length) song out of all the songs that a user has in their playlists. If the user has no playlists nor any songs in the playlists, do not add that user to the map.
  \end{enumerate}
\end{enumerate}

\myexercise{2}{chapter-classes}{In this exercise you will create two classes: \ttt{Chocolate} and \ttt{ChocolateBox} to store a two-dimensional array of chocolate pieces.}
\begin{enumerate}[label=(\arabic*)]
  \item Design the \ttt{Chocolate} class, which stores a string denoting its kind, and an integer representing its weight in ounces.

  \item Design the \ttt{ChocolateBox} class, which stores a \ttt{Chocolate[][]} array as an instance variable. Its constructor should receive the number of rows and columns of the box. 
  \begin{enumerate}[label=(\roman*)]
    \item Design the \ttt{int numberOfChocolates()} method that returns the number of non-\ttt{null} instances of \ttt{Chocolate} that are in the \ttt{ChocolateBox}.
    \item Design the \ttt{void shuffleChocolate()} method, which randomizes the elements in the box. 
    How you shuffle them is up to you, as long as it is a sufficient shuffle (and not just, for example, a linear shift of all chocolates).
    \item Design the \ttt{int removeFirst(String kind)} method, which removes the first occurrence, from the top, of the~\ttt{kind} of chocolate. Return what position was removed, assuming positions are numbered from~$1$ to~$n$, ordered from left to right, then top to bottom (similar to a standard calendar). If there are no~\ttt{kind} of chocolates in the box, return~\ttt{-1}.
    \item Design the \ttt{ChocolateBox allergyBox(String kind)} method, which returns a new \ttt{ChocolateBox} where all \ttt{kind} of chocolates are removed. If there are \ttt{null} spots in between the chocolates of the old box, shift the chocolates over accordingly. Consider the following \ttt{ChocolateBox}:
    % \newcolumntype{C}[1]{>{\centering\arraybackslash}m{#1}}
    \newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}} % Centered columns with fixed width

    % Table with 2x2 square cells, each 1cm x 1cm
    \renewcommand{\arraystretch}{2.5} % Adjust the row height to make cells square
    \begin{figure}[H]
      \centering
      \begin{tabular}{|C{1cm}|C{1cm}|C{1cm}|C{1cm}|C{1cm}|}
      \hline
      \emph{Dark} & \emph{White} & \emph{Milk} & \emph{Nut} & \emph{Sweet}\\ \hline
      \ttt{null} & \emph{Nut} & \emph{Dark} & \ttt{null} & \ttt{null}\\ \hline
      \emph{White} & \emph{Sweet} & \emph{Nut} & \ttt{null} & \emph{Nut}\\ \hline
      \end{tabular}
    \end{figure}
  \end{enumerate}

  Invoking \ttt{allergyBox("Nut")} on this box would return the following \ttt{ChocolateBox}:

  \newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}} % Centered columns with fixed width

    % Table with 2x2 square cells, each 1cm x 1cm
  \renewcommand{\arraystretch}{2.5} % Adjust the row height to make cells square
  \begin{figure}[H]
    \centering
    \begin{tabular}{|C{1cm}|C{1cm}|C{1cm}|C{1cm}|C{1cm}|}
    \hline
    \emph{Dark} & \emph{White} & \emph{Milk} & \emph{Sweet} & \emph{Dark}\\ \hline
    \emph{White} & \emph{Sweet} & \ttt{null} & \ttt{null} & \ttt{null}\\ \hline
    \ttt{null} & \ttt{null} & \ttt{null} & \ttt{null} & \ttt{null}\\ \hline
    \end{tabular}
  \end{figure}
\end{enumerate}

\myexercise{2}{chapter-classes}{In this exercise you will design a \emph{linear congruential generator}: a pseudorandom number generation algorithm. In particular, the C programming language standard library defines two functions: \ttt{rand} and \ttt{srand}. The latter sets the \emph{seed} for the generator, and \ttt{rand} returns a random integer between $[0, 2^{15})$. The formula for this generator is a recurrence relation:}
\begin{align*}
    \emph{next} &= |r_n \cdot 1103515245 + 12345|\\
    r_{n+1} &= \left(\dfrac{\emph{next}}{2^{16}}\right)\;\%\;2^{15};
\end{align*}

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{LcgRandom} class, which implements this behavior. In particular, it should have two constructors: one that receives a seed value $s$, and another that sets the seed to one. The seed initializes the value of $r_0$.
    \item Design the \ttt{int genInt()} method, which returns a random integer between $0$ and $2^{15}$ using this algorithm.
    \item Design the \ttt{IntStream stream()} method, which returns a stream of random numbers that uses \ttt{genInt} to generate numbers. Hint: use \ttt{generate}!
    \item Design the \ttt{genInt(int b)} method that returns an integer between $[0, b]$. Note that $0 \leq b < 2^{15}$; you do not need to account for values outside of this range. Do \textbf{not} simply loop until you find a value between that range; instead, use modulus to your advantage.
\end{enumerate}

\newpage %ugh
\myexercise{3}{chapter-classes}{This question has six parts.}

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{Matrix} class, which stores a two-dimensional array of integers. Its constructor should receive two integers~$m$~and~$n$ representing the number of rows and columns respectively, as well as a two-dimensional array of integers (you may assume that the number of rows and columns of the passed array are equal to~$m$ and~$n$). Copy the integers from the passed array into an instance variable array. Do \emph{not} simply assign the provided array to the instance variable!
    \item Design the \ttt{void set(int i, int j, int val)} method, which sets the value at row~$i$ and column~$j$ to \ttt{val}. If the row or column is out of bounds, do nothing.
    \item Design the \ttt{boolean add(Matrix m)} method, which adds the values of the passed matrix to the current matrix. If the dimensions of the passed matrix do not match the dimensions of the current matrix, return false and do not add the matrix.
    \item Design the \ttt{boolean multiply(Matrix m)} method, which multiplies the values of the passed matrix to the current matrix. If we cannot multiply~$m$ with this matrix, return false and do not multiply the matrix.
    \item Design the \ttt{void transpose()} method, which transposes the matrix. That is, the rows become the columns and the columns become the rows. You may need to alter the dimensions of the matrix.
    \item Design the \ttt{void rotate()} method, rotates the matrix~$90$ degrees clockwise. To rotate a matrix, compute the transposition and then reverse the rows. You may need to alter the dimensions of the matrix.
    \item Override the \ttt{public String toString()} method to return a stringified version of the matrix. As an example, \ttt{"[[1, 2, 3], [4, 5, 6]]"} represents the following matrix:

    \[
    \begin{bmatrix}
      1&2&3\\
      4&5&6
    \end{bmatrix}
    \]
\end{enumerate}

\myexercise{2}{chapter-classes}{This exercise has five parts.}
\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{GameObject} class, which stores a \ttt{Pair<Double, Double>} denoting its center~$(x, y)$ position and a \ttt{Pair<Double, Double>} denoting its width and height respectively. Its constructor should receive four \ttt{double} values representing~$x$,~$y$, $\emph{width}$, and $\emph{height}$. Be sure to write instance accessor and mutator methods for modifying both fields. That is, you should write \ttt{double getLocationX()}, \ttt{void setLocationX(double d)}, and so forth, to access and modify the \ttt{Pair} values directly. 

    \item Design the \ttt{boolean collidesWith(GameObject obj)} method that returns whether \ttt{this} \ttt{GameObject} collides with the parameter \ttt{obj}. You should design this solution as if the game objects are shaped like rectangles (which they are!).

    \item Design the \ttt{double distance(GameObject obj)} method that returns the Euclidean distance from the center of \ttt{this} \ttt{GameObject} to the center of the parameter \ttt{obj}. 

    \item Design the \ttt{double move(double dx, double dy)} method that moves the object about the Cartesian (two-dimensional) plane. The distance should be a delta represented as two \ttt{double} numbers \ttt{dx} and \ttt{dy} that directly manipulate the object position. For instance, if \ttt{dx} is~$3.0$ and \ttt{dy} is~$-2.0$ and the object is currently at \ttt{<2.0, -9.0>}, invoking \ttt{move(3.0, -2.0)} updates the object to be at \ttt{<5.0, -11.0>}.

    \item Override the \ttt{public String toString()} method to call the \ttt{toString} methods of the two instance variables, conjoined by a semicolon.
\end{enumerate}

\newpage %ugh
\myexercise{2}{chapter-classes}{This exercise has three parts.}
\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{GameRunner} class, which stores a list of objects \ttt{List<GameObject>} as an instance variable. Its constructor should receive an integer representing a random number generator seed. It should first instantiate \ttt{rand} to a new \ttt{Random} object with this seed, and then populate the list with twenty random \ttt{GameObject} instances at random \textbf{integer} positions with random \textbf{integer} sizes. These random positions should be between $[-10, 10]$ for both coordinates and the random sizes should be between $[1, 10]$ for both dimensions.

    \item Design the \ttt{void moveObjects()} method, which moves each object by three positive $x$ units and four negative $y$ units.

    \item Design the \ttt{String stringifyObjects()} method, which converts each object in the list into its string representation, with brackets around the elements, and separated by commas. Hint: you can use one method from the \ttt{Stream} class to do this quickly!
\end{enumerate}

\myexercise{2}{chapter-classes}{This exercise involves the ``Twenty-One'' game implementation from the chapter.}
\begin{enumerate}[label=(\alph*)]
    \item Change each card to use the Unicode symbol counterpart rather than the \ttt{"X of Y"} \ttt{toString} model, where \ttt{X} is the value and \ttt{Y} is the suit. The Unicode symbols are available on the second page of this PDF: \url{https://www.unicode.org/charts/PDF/U1F0A0.pdf}. This will be a little tedious, but it makes the game look cooler!
    \item Add the Ace, Jack, Queen, and King cards, instead of the previous implementation of using four cards whose values were all ten. A simple solution is to use a \ttt{String} that keeps track of the ``name'' of a card alongside the other instance variables. 
    \item Add an AI to the game (you do not need to test this class). This involves writing the \ttt{AI} class and designing the \ttt{boolean play(Deck deck)} method. An \ttt{AI} has a \ttt{ArrayList<Card>}, similar to \ttt{Player}, but makes decisions autonomously using the following algorithm (written in a pseudocode-like language):
    \begin{verbnobox}[\small]
boolean play(Deck d) {
  score = getScore()
  if score < 16 then:
    cards.add(d.drawCard())
    return true;
  else if (score > 16 && score < 21) {
    k = Generate a random integer between [0, 3).
    if k is zero then:
      cards.add(d.drawCard())
      return true;
  } 
  return false;
}
\end{verbnobox}
The method returns whether or not the AI drew a card. If they did not draw a card, then their turn is over. When playing the game, the player can see the first two cards dealt to an AI, but nothing more. You might want to add a static variable to the \ttt{Card} class representing the ``covered card.'' Note that the AI knows only the context of its deck of cards; it is not aware of any other \ttt{Player} or \ttt{AI}.
\item After designing the \ttt{AI} class and adding one to your game, create an \ttt{ArrayList<AI>} simulating multiple computer players in the game.
\end{enumerate}

\myexercise{1}{chapter-classes}{Design the \ttt{void set(T e, int idx)} method within the \ttt{MiniArrayList} class, which sets the element at $\emph{idx}$ to the given~$e$ element.}

\myexercise{1}{chapter-classes}{Design the \ttt{void isEmpty()} method within the \ttt{MiniArrayList} class, which returns whether or not the list is empty.}

\myexercise{2}{chapter-classes}{Design the \ttt{void clear()} method within the \ttt{MiniArrayList} class, which ``removes'' all elements from the list. This should not change the capacity of the list. Note that there's a reason why ``removes'' is in quotes. We rank this exercise as a two-star not because of its length, but because it is a little tricky.}

\myexercise{2}{chapter-classes}{Override the \ttt{public boolean equals(Object o)} method in the \ttt{MiniArrayList} class to compare two lists by their elements. Return \ttt{true} if all elements in the two lists are \ttt{equals} to one another, and \ttt{false} otherwise.}

\myexercise{2}{chapter-classes}{Using the \ttt{StackFrame} class, design an implementation of the tail recursive factorial method. Recall how to do this from Chapter~\ref{chapter-crl}: instead of pushing an activation record to the call stack, we can simply update the bindings in the existing frame.}

\myexercise{2}{chapter-classes}{This exercise has seven parts.}

In this question you will design the \ttt{Time} class for working with units of time. 
Programming languages often support operations for handling dates and times to varying degrees of success.
Java provides a few classes and methods of its own, and you cannot use these in your implementation, as that would defeat the point of the exercise.
\begin{enumerate}[label=(\alph*)]
  \item Design the \ttt{Time} class. It should contain three constructors that receive the following parameters:
  \begin{itemize}
    \item \ttt{Time(int h, int m, int s)} receives three integers \ttt{h}, \ttt{m}, and \ttt{s} represents times in hours, minutes, and seconds respectively.
    \item \ttt{Time(int s)} receives a single integer \ttt{s} representing the number of seconds.
    \item \ttt{Time(String t)} receives a string of the form \ttt{"hh:mm:ss"} with three components: hours, minutes, and seconds. The bounds on the time string are \ttt{00:00:00} and \ttt{23:59:59}.
  \end{itemize}
  However you choose to store the units of time is fine, as long as your class supports the remaining operations.
  \item Design the \ttt{int getNumberOfSeconds()} method, which returns the number of seconds that this \ttt{Time} object represents.
  \item Design the \ttt{int getNumberOfMinutes()} method, which returns the number of minutes that this \ttt{Time} object represents. If there are an inexact number of minutes, simply return the minutes. As an example, \ttt{new Time("02:30:45").getNumberOfMinutes()} returns \ttt{150} and not \ttt{151}.
  \item Override the \ttt{public String toString()} method to return a stringified version of the time where the hours, minutes, and seconds are separated by colons. Single-digit units of time must contain a leading zero.
  \item Override the \ttt{public boolean equals(Object o)} method that returns whether a given \ttt{Time} object represents the same time as \ttt{this} instance.
  \item Design the \ttt{void addTime(Time t)} method that adds a given \ttt{Time} object to \ttt{this} instance. Take the following invocations as an example.
  \begin{verbnobox}[\small]
Time t1 = new Time("02:30:45");
Time t2 = new Time("11:45:18");
Time t3 = new Time("00:53:57");
t1.add(t2);
t1.toString(); => 14:16:03
t1.add(t3);
t1.toString(); => 15:00:00
  \end{verbnobox}
  \item Design the \ttt{void increment(String u)} method, which receives a string~$u$ denoting the unit of time to increment. If~$u$ is not one of \ttt{"HOUR"}, \ttt{"MINUTE"}, or \ttt{"SECOND"}, return \ttt{false}, and otherwise return \ttt{true}. Take the following invocations as examples. Remember to account for fringe cases, e.g., incrementing a unit that is about to roll-over to the next.
\begin{verbnobox}[\small]
Time t1 = new Time("02:30:45");
t1.increment("HOUR");
t1.toString(); => "03:30:45"
t1.increment("MINUTE");
t1.toString(); => "03:31:45"
t1.increment("SECOND");
t1.toString(); => "03:31:46"
\end{verbnobox}
\end{enumerate}


\myexercise{2}{chapter-classes}{This exercise has six parts.}

In this question you will implement the \ttt{MiniStack} data structure. This is similar to the \ttt{MiniArrayList} class from the chapter, but, of course, is a stack and not an array list.

Unlike many stack implementations, however, we will use an array-backed stack. This means that, instead of using a collection of \ttt{private} and \ttt{static} \ttt{Node} classes, the stack will use an array to store its elements. When the array runs out of space, a new one is allocated and the elements are copied over. 

\begin{enumerate}[label=(\alph*)]
    \item First, design the generic \ttt{MiniStack} class. Its constructor should receive no arguments, and instantiate two instance variables: \ttt{T[] elements} and \ttt{size} to a new array and zero respectively. Remember that you cannot instantiate a generic array, so how do we do that? The initial capacity of the array should be set to \ttt{INITIAL\_CAPACITY}, which is a \ttt{private static final} variable declared in the class as ten.

    \item Second, design the \ttt{void add(T t)} method, which adds an element onto the top of the stack. The ``top of the stack,'' when using an array, is the right-most element, i.e., the element with the highest index. It might be a good idea to design a \ttt{private} helper method that resizes the underlying array when necessary. Your resize factor, i.e., how you resize the stack, is up to you.

    \item Third, design the \ttt{T peek()} method, which returns (but does not remove) the top-most element of the stack.

    \item Fourth, design the \ttt{T pop()} method, which returns \textit{and} removes the top-most element. Be sure that your \ttt{add} method still works after designing \ttt{pop}.

    \item Fifth, design the \ttt{int size()} method, which returns the number of logical elements in the stack.

    \item Finally, override the \ttt{public String toString()} method to return a string containing the elements of the stack from top-to-bottom, separated by commas and a space. For example, if the stack contains, from bottom-to-top, \ttt{10}, \ttt{20}, \ttt{30}, \ttt{40}, and \ttt{50}, the \ttt{toString} method returns \ttt{"50, 40, 30, 20, 10"}.
\end{enumerate}

\newpage %ugh
\myexercise{3}{chapter-classes}{This exercise has seven parts.}

A \emph{chunked array list} data structure avoids the overhead of copying the underlying array upon running out of free spots. The idea is to break the collection into chunks, namely, as an \ttt{ArrayList} of arrays. Assuming that the underlying collection of chunks is adequately populated, this collection will seldom require a resizing operation. This data structure will not support arbitrary insertions or removals.

\begin{enumerate}[label=(\alph*)]
    \item Design the generic \ttt{ChunkedArrayList} class. It should store, as an instance variable, an \ttt{ArrayList<T[]>} of chunks, where $T$ is the parameterized type. Design two constructors: one that receives a chunk size $s$ and a number of preallocated chunks $n$, and another constructor that receives no parameters, defaulting $n$ to $10$ and $s$ to $50$.
    \item Design the \ttt{void add(T t)} method that, when given an item $t$, adds it to the end of the current chunk. If we run out of space in the current chunk, add it to the next chunk in succession. If there are no available chunks, add a new \ttt{T[]} of size $s$ to the list. Hint: use modulus.
    \item Design the \ttt{T get(int i)} method that, when given an index $i$, returns the item at that index. The user of this data structure should not need to know about the chunks or their implementation. Therefore, if $s=10$, and we access index $27$, it should receive the element in chunk $3$, index $7$. Assume that $i$ is in bounds.
    \item Design the \ttt{void resizeChunks(int n)} method that resizes each chunk to the input argument $n$. Depending on this value, you will need to either reallocate each underlying array or shift values around. For example, if we have a chunk array list with $150$ elements whose chunks hold up to $50$ elements each, and we resize the chunks to be $25$ in maximum capacity, we will double the number of necessary chunks. On the other hand, if we resize the chunks to hold $100$ elements, then the values in chunk two are shifted into chunk one, and those in chunk three are shifted into chunk two.
    \item Design the \ttt{int getChunkCapacity()} method that returns the maximum capacity of each chunk.
    \item Design the \ttt{int size()} method that returns the total number of elements in the chunk array list.
    \item Design the \ttt{int getChunkSize()} method that returns the number of chunks currently in-use.
\end{enumerate}

\myexercise{3}{chapter-classes}{This exercise has seven parts.}

A \emph{persistent data structure}\index{persistent data structure} is one that saves intermittent data structures after applying operations that would otherwise alter the contents of the data structure. Take, for instance, a standard FIFO queue. When we invoke its `enqueue' method, we modify the underlying data structure to now contain the new element. If this were a persistent queue, then enqueueing a new element would, instead, return a new queue that contains all elements and the newly-enqueued value, thereby leaving the original queue unchanged.

\begin{enumerate}[label=(\alph*)]
    \item First, design the generic, private, and static class \ttt{Node} inside a generic \ttt{PQueue} class skeleton. It should store, as instance variables, a pointer to its next element as well as its associated value.
    \item Then, design the \ttt{PQueue} class, which represents a persistent queue data structure. As instance variables, store ``first'' and ``last'' pointers as \ttt{Node} objects, as well as an integer to represent the number of existing elements. In the constructor, instantiate the pointers to \ttt{null} and the number of elements to zero.
    \item Design the \ttt{private PQueue<T> copy()} method that returns a new queue with the same elements as the current queue. You should divide this method into a case analysis: one where \ttt{this} queue is empty and another where it is not. In the former case, return a new queue with no elements. In the latter case, iterate over the elements of the queue, enqueuing each element into a new queue. You will need instantiate a new \ttt{Node} (reference) for each element.
    \item Design the \ttt{PQueue<T> enqueue(T t)} method that enqueues a value onto the end of a new queue containing all the old elements, in addition to the new value. You should use the \ttt{copy} method to your advantage.
    \item Design the \ttt{PQueue<T> dequeue()} method that removes the first element of the queue, returning a new queue without this first value. You should use the \ttt{copy} method to your advantage.
    \item Design the \ttt{T peek()} method that returns the first element of the queue.
    \item Design the \ttt{static <T> PQueue<T> of(T... vals)} method that creates a queue with the values passed as \ttt{vals}. Note that this must be a variadic method. Do not create a series of \ttt{PQueue} objects by enqueueing each element into a distinct queue; this is incredibly inefficient. Instead, allocate each \ttt{Node} one-by-one, thereby never calling \ttt{enqueue}.
    \item Design the \ttt{int size()} method that returns the number of elements in the queue. You should not traverse the queue to compute this value. 
\end{enumerate}

\myexercise{3}{chapter-classes}{This exercise has three parts.}

A \emph{deterministic finite state automaton} is an extremely primitive machine that represents transitions between the different states of a system. Think, as an example, of a light switch; there is an ``OFF'' state and an ``ON'' state, where flipping the switch flops between the two. The switch flip represents the input that causes a transition from one state to another. Programming languages most often use finite automata for character recognition, i.e., what characters are valid in the language grammar. The following is an example of a DFA diagram that accepts input strings that contain an odd number of \ttt{\q{}a\q{}} characters from an input alphabet $\Sigma = \{a, b\}$.

\begin{enumerate}[label=(\alph*)]
    \item First, begin by designing the skeleton for the \ttt{DFA} class, which contains the following private and static class definitions:
    \begin{itemize}
        \item \ttt{State}, which stores a string identifier, an \ttt{"isStart"} boolean flag and an \ttt{"isFinal"} flag. The class should contain appropriate accessors but no mutators.
        \item \ttt{Transition}, which stores two \ttt{State} objects $a$ and $b$ representing the ``from'' and ``to'', as well as the required input to transition from $a$ to $b$. 
    \end{itemize}
    \item The \ttt{DFA} constructor should be empty, and the class definition should store a \ttt{Set<Transition>} as well as a \ttt{Set<State>}. 
    \item Design the \ttt{void addState(State s)} method, which adds a new \ttt{State} to the finite automaton.
    \item Design the \ttt{State transition(State s, String i)} method, which returns the state arrived after making the transition from $s$ via input $i$.
    \item Finally, design the \ttt{boolean accepts(String v)} method, which receives an input string $v$ and traverses over the automaton to determine if it accepts or rejects the input. We accept $v$ if the last state we end on is marked as a final state.
\end{enumerate}

\newpage %ugh
\myexercise{3}{chapter-exceptions-io}{A binary relation $\mathcal{R}$ is a subset of the cartesian product of two sets $A$ and $B$. That is, $\mathcal{R} \subseteq A \times B$ such that $A \times B = \{\langle{x, y}\rangle \mid x \in A \text{ and } y \in B\}$. There are several ways that we can describe binary relations, including reflexive, symmetric, transitive, antisymmetric, asymmetric, irreflexive, and serial.}

Design the generic \ttt{BinaryRelation<T, U>} class to represent a mathematical binary relation. It should store a \ttt{Set<Pair<String, String>{>}}, where the inner pair is the associated tuples of the set. Its constructor should instantiate the set instance variable. 

Then, design the following methods:

\begin{enumerate}[label=(\alph*)]
    \item \ttt{void addTuple(T x, U y)} receives two values $x$ and $y$ of types $T$ and $U$ respectively, and adds them as a tuple to the underlying set.
    
    \item \ttt{boolean isReflexive()} returns true if the relation is reflexive. A relation $\mathcal{R}$ is reflexive if, for all $x \in S$, $\langle{x, x}\rangle \in \mathcal{R}$.
    
    \item \ttt{boolean isSymmetric()} returns true if the relation is symmetric. A relation $\mathcal{R}$ is symmetric if, for all $x, y \in S$, $\langle{x, y}\rangle \in \mathcal{R}$ and $\langle{y, x}\rangle \in \mathcal{R}$.
    
    \item \ttt{boolean isTransitive()} returns true if the relation is reflexive. A relation $\mathcal{R}$ is transitive if, for all $x, y, z \in S$, if $\langle{x, y}\rangle \in \mathcal{R}$ and $\langle{y, z}\rangle \in \mathcal{R}$, then $\langle{x, z}\rangle \in \mathcal{R}$.
    
    \item \ttt{boolean isEquivalence()} returns true if the relation is an equivalence relation. A relation $\mathcal{R}$ is an equivalence relation if it is reflexive, symmetric, and transitive.

    \item \ttt{boolean isIrreflexive()} returns true if the relation is irreflexive. A relation $\mathcal{R}$ is irreflexive if, for all $x \in S$, $\langle{x, x}\rangle \not\in \mathcal{R}$.
    
    \item \ttt{boolean isAntisymmetric()} returns true if the relation is antisymmetric. A relation $\mathcal{R}$ is antisymmetric if, for all $x, y \in S$, if $\langle{x, y}\rangle \in \mathcal{R}$ and $\langle{y, x}\rangle \in \mathcal{R}$, then $x \neq y$.
    
    \item \ttt{boolean isAsymmetric()} returns true if the relation is asymmetric. A relation is asymmetric if it is both antisymmetric and irreflexive.

    \item \ttt{boolean isSerial()} returns true if the relation is serial. A relation $\mathcal{R}$ is serial if, for all $x \in S$, there exists a $y \in S$ such that $\langle{x, y}\rangle \in \mathcal{R}$.

    \item \ttt{Set<Pair<String, String>{>} reflexiveClosure()} returns a set representing the reflexive closure of a binary relation, which is $\mathcal{R} \cup r(\mathcal{R})$, where~$r$ returns a reflexive set over~$S$.
    
    \item \ttt{Set<Pair<String, String>{>} isSymmetricClosure()} returns a set representing the symmetric closure of a binary relation, which is $\mathcal{R} \cup s(\mathcal{R})$, where~$r$ returns a symmetric set over~$S$.

    \item \ttt{Set<Pair<String, String>{>} transitiveClosure()} returns a set representing the transitive closure of a binary relation, which is $\mathcal{R} \cup t(\mathcal{R})$, where~$t$ returns a transitive set over~$S$.
\end{enumerate}

As an added optimization, we should cache whether the current relation is one of these properties when prompted. If we do not add a pair to the relation, then it makes little sense to recompute whether or not is, say, reflexive. Implement this as an optimization, however you wish, into the class.

\newpage %ugh
\myexercise{2}{chapter-classes}{This exercise has five parts.}
Repeated string concatenation is a common performance issue in Java. 
As we know, Java \ttt{String} objects are immutable, which means that concatenation creates a new \ttt{String} objects. 
This is fine for small strings, but for larger strings (or concatenation operations performed in a loop), this can be a performance bottleneck. 
Each concatenation requires copying the entire string. 
Java provides the \ttt{StringBuilder} class to alleviate the issue. 
In this exercise, you will design a \ttt{MiniStringBuilder} class that mimics the behavior of \ttt{StringBuilder}. 
You cannot use \ttt{StringBuilder} or the older \ttt{StringBuilder} classes in your implementation.

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{MiniStringBuilder} class, which stores a \ttt{char[]} as an instance variable. The class should also store a variable to keep track of the number of ``logical characters'' that are in-use by the buffer.
    \item Design two constructors for the \ttt{MiniStringBuilder} class: one that receives no arguments and initializes the default capacity of the underlying \ttt{char[]} array to~$20$, and another that receives a \ttt{String}~$s$ and initializes the \ttt{char[]} array to the characters of~$s$. 
    \item Design the \ttt{void append(String s)} method, which appends the given string~$s$ onto the end of the current string stored in the buffer. The given string should not simply be appended onto the end of the buffer, but rather added to the end of the previous string in the buffer. If the buffer runs out of space, reallocate the array to be twice its current size, similar to how we reallocate the array in the \ttt{MiniArrayList} example class.
    \item Design the \ttt{void clear()} method, which resets the \ttt{char[]} array to the default size of~$20$ and clears the character buffer.
    \item Override the \ttt{public String toString()} method, which returns the \ttt{char[]} array as a \ttt{String} object. The resulting string should contain only the logical characters in the buffer, and not the entire array. Output the characters without any additional characters, such as brackets or commas.
\end{enumerate}

\myexercise{2}{chapter-classes}{This exercise has twelve parts.} 
A complex number~$c \in \mathbb{C}$ has two components: a real number~$a$ and an imaginary number~$b$. 
Together, these components compose into~$a + bi$. 
In this exercise you will design a class that operates over complex numbers.

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{ComplexNumber} class, whose constructor receives two \ttt{double} values: $a$ and $b$. Store these as instance variables.
    \item Design the empty constructor that initializes $a$ and $b$ to $0$ and $0$ respectively. 
    \item Implement the respective accessor and mutator methods for the real and imaginary components.
    \item Override the \ttt{public String toString()} method to return a string representation of the complex number of the form \ttt{"a + bi"} or \ttt{"a - bi"} when $b$ is either positive or negative. 
    \item Override the \ttt{public boolean equals(Object o)} method to compare two complex numbers. Of course, this entails comparing the real component and the imaginary component.
    \item Override the \ttt{public int hashCode()} method to return a hash code that hashes the \ttt{a} and \ttt{b} components respectively.
    \item Design the \ttt{double magnitude()} method, which returns the magnitude of \ttt{this} complex number. The magnitude of a complex number is the square root of the sum of its components.
    \item Design the \ttt{double argument()} method, which returns the argument, or angle, of \ttt{this} complex number in radians. The argument of a complex number is computed as $\tan^{-1}{\frac{b}{a}}$.
    \item Design the \ttt{ComplexNumber conjugate()} method, which returns the conjugate of \ttt{this} complex number. The conjugate of a complex number flips the parity of the imaginary component. That is, if we have a complex number $a + bi$, its conjugate is $a - bi$.
    \item Design the \ttt{ComplexNumber add(ComplexNumber c2)} method, which receives a \ttt{ComplexNumber} as an argument and returns a new \ttt{ComplexNumber} representing the sum of \ttt{this} complex number and the given number. The sum of two complex numbers is the sum of the real components and the imaginary components.
    \item Design the \ttt{ComplexNumber sub(ComplexNumber c2)} method, which receives a \ttt{ComplexNumber} as an argument and returns a new \ttt{ComplexNumber} representing the difference of \ttt{this} complex number and the given number. The difference of two complex numbers is the difference of the real components and the imaginary components.
    \item Design the \ttt{ComplexNumber mul(ComplexNumber c2)} method, which receives a \ttt{ComplexNumber} as an argument and returns a new \ttt{ComplexNumber} representing the product of \ttt{this} complex number and the given number. The product of two complex numbers is as follows:
    \[
        (a + bi)(c + di) = (ac - bd) + (ad + bc)i    
    \]
    Hint: use \ttt{add} and \ttt{mul} to your advantage.
\end{enumerate}

\myexercise{1}{chapter-classes}{This exercise has 2 parts.}
\begin{enumerate}[label=(\alph*)]
  \item Design the \ttt{Accumulator} class, which stores an instance variable of type \ttt{Number}. The \ttt{Accumulator} constructor receives a value of type \ttt{T} and stores it as an instance variable.
  \item Design the \ttt{apply} method, which receives a \ttt{Number} and adds it to the instance variable, then returns the instance variable. If \ttt{apply} has only received integers as arguments, then the result should be interpreted as an integer and not a floating-point value. We're recreating a challenge invented by Paul Graham called the ``Accumulator Factory.''

  As an example, consider the following sequence.
  \begin{verbnobox}[\small]
Accumulator acc1 = new Accumulator(1);
acc1.apply(5);
acc1.apply(7);
assertEquals(13, acc1.apply(0));
assertEquals(15.3, acc1.apply(2.3));
  \end{verbnobox}[\small]
\end{enumerate}

\myexercise{1}{chapter-classes}{This exercise has 3 parts.}

The \emph{Kotlin} programming language supports customized \emph{ranges}. That is, we can define an interval using dot notation, e.g., \ttt{1..10}, then query a value over that interval. For instance, \ttt{x in 1..10} returns whether or not \ttt{x} is between \ttt{1} and \ttt{10}, inclusive. This comparison, however, extends beyond primitive datatypes; ranges may operate over classes. For example, we can create a range \ttt{"hi".."howdy"}, which defines the range of strings in between \ttt{"hi"} and \ttt{"howdy"}.

\begin{enumerate}[label=(\alph*)]
    \item Design the generic \ttt{Range} class. It should store, as instance variables, a minimum and a maximum value, both of which are of type \ttt{<T extends Comparable<T>>}, meaning \ttt{T} must be a comparable type.
    \item The \ttt{Range} constructor should receive these two values as parameters and assign them to the instance variables accordingly. 
    \item Design the \ttt{boolean contains(T v)} method that returns whether or not $v$ is between the interval that this range operates over. 
\end{enumerate}

\myexercise{2}{chapter-classes}{Design the generic static method \ttt{T validateInput(String prompt, String errResp, U extends Predicate<T> p)} that receives a prompt, an error response, and an object that implements the \ttt{Predicate} interface to test whether or not the received value, received through standard input, is valid. If the value is invalid according to the predicate, print the error response and re-prompt the user. Otherwise, return the entered value.}

\myexercise{2}{chapter-classes}{This exercise has three parts.} In this exercise, you'll be developing a \ttt{Document} interface along with its implementing classes:
\begin{itemize}
\item \ttt{TextDocument}
\item \ttt{SpreadsheetDocument}
\item \ttt{PresentationDocument}
\end{itemize}

\noindent The \ttt{Document} interface is defined as follows:
\begin{verbnobox}[\small\mbox{}]
interface Document {

  /**
   * Returns the number of pages in this document.
   */
  int numberOfPages();

  /**
   * Returns a string representing that the Document
   * is being printed.
   */
  default String print() {
    return "Printing the document!";
  }
}
\end{verbnobox}

Notice that we have a \ttt{default} method, which is one that an implementing class does \textbf{not} have to implement. It provides ``default'' functionality, should the ``implementee'' not want to implement the method (hence the name!).

\begin{enumerate}[label=(\alph*)]
\item Implement the other three classes with the following specifications:
\begin{itemize}
\item A \ttt{TextDocument} consists of 100 pages. When it is printed, it should return a message \ttt{"Printing text document!"}.
\item A \ttt{SpreadsheetDocument} has 50 pages. When it is printed, it should return a message \ttt{"Printing spreadsheet document!"}.
\item A \ttt{PresentationDocument} contains 20 pages. It utilizes the default implementation of the \ttt{print} method.
\end{itemize}
\item Design the \ttt{PrintingOffice} class, which includes the following static method: \ttt{static OptionalDouble avgPages(List<Document> lodocs)}. This method calculates and returns the average number of pages across the provided list of \ttt{Document} objects. Remember why we use \ttt{Optional}: if there are no \ttt{Document} objects in the list, we would be dividing by zero if we took the average! 
\item Inside the \ttt{PrintingOffice} class, modify it to include the \ttt{static void printDocuments(List<Document> documents)} method, responsible for invoking the \ttt{print} method on each object in the list of \ttt{Document} instances.
\end{enumerate}

\newpage %ugh
\myexercise{2}{chapter-classes}{This exercise has three parts.}
\begin{enumerate}[label=(\alph*)]
  \item Design the \ttt{INumberFormat} interface, which contains the \ttt{String format(int n)} method. 
  \item Design the \ttt{DollarFormat} method, which implements \ttt{INumberFormat}, and returns a string where the number is prepended with a dollar sign \ttt{"\$"}.
  \item Design the \ttt{CommaFormat} method, which implements \ttt{INumberFormat}, and returns a string where the number contains commas where appropriate. For example, \ttt{format(4412)} should return \ttt{"4,412"}.
\end{enumerate}

\myexercise{3}{chapter-classes}{In the chapter, we described the \ttt{PizzaOrder} class. This exercise introduces readers to the visitor design pattern, which we explore in greater detail in~\Cref{chapter-modern}.}
\begin{enumerate}[label=(\alph*)]
  \item First, design the \ttt{GroupOrder} class, which keeps track of multiple pizzas in an order. Store a \ttt{Queue<PizzaOrder>} as an instance variable and instantiate it to a \ttt{PriorityQueue}. The \ttt{GroupObject} constructor should receive a \ttt{Comparator<PizzaOrder}. Pass this to the \ttt{PriorityQueue} instantiation.
  \item Design the \ttt{ITopping} interface, which represents a topping. For now, it contains no methods. Then, design four classes: \ttt{Pepperoni}, \ttt{Onion}, \ttt{Pineapple}, and \ttt{Anchovie}, all of which implement \ttt{ITopping}.
  \item Now, let's design a class that allows us to do multiple actions with toppings. Design the generic \ttt{IToppingVisitor} class, which has four methods: \ttt{T visit(Pepperoni p)}, \ttt{T visit(Onion o)}, \ttt{T visit(Pineapple p)}, and \ttt{T visit(Anchovie a)}.
  \item Design the \ttt{ToppingPriceVisitor} class, which implements the interface \ttt{IToppingVisitor}, whose type parameter is a \ttt{Double}. The idea is that the \ttt{ToppingPriceVisitor} class serves as a way of associating a property with toppings without having to modify/amend the class definitions. Override the four methods to return \ttt{3.50}, \ttt{2.50}, \ttt{5.75}, and \ttt{4.00} respectively.
  \item Modify the \ttt{PizzaOrder} class to have its map instance variable associate \ttt{ITopping} objects to \ttt{Integer}, rather than \ttt{String} to \ttt{Integer}.
  \item Amend the \ttt{ITopping} interface to now supply the \ttt{<T> T visit(IToppingVis\-itor<T> v)} method. Its subtypes should override \ttt{visit} by defining it as a call to \ttt{v.visit(this)}, where \ttt{v} is the visitor object parameter.
  \item Finally, design the \ttt{PizzaOrderPriceComparator} class, which implements \ttt{Comparator<PizzaOrder>}, and compares pizzas based on the price of its toppings. Pizzas with a higher cost are prioritized over pizzas with a lower cost.
\end{enumerate}

\myexercise{3}{chapter-classes}{A \emph{lazy list} is one that, in theory, produces infinite results! Consider the \ttt{ILazyList} interface below:}
\begin{lstlisting}[language=MyJava]
interface ILazyList<T> {
  T next();
}
\end{lstlisting}

When calling \ttt{next} on a lazy list, we update the contents of the lazy list and return the next result. We mark this as a generic interface to allow for any desired return type. For instance, below is a lazy list that produces factorial values:\footnote{We will ignore the intricacies that come with Java's implementation of the \ttt{int} datatype. To make this truly infinite (up to the system's memory limit), we could use \ttt{BigInteger}.}

\newpage %ugh
\begin{lstlisting}[language=MyJava]
class FactorialLazyList implements ILazyList<Integer> {

  private int n;
  private int fact;
 
  FactorialLazyList() {
    this.n = 1;
    this.fact = 1;
  }

  @Override
  public Integer next() {
    this.fact *= this.n;
    this.n++;
    return this.fact;
  }
}
\end{lstlisting}

Testing it with ten calls to \ttt{next} yields predictable results.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class FactorialLazyListTester {

  @Test
  void testFactorialLazyList() {
    ILazyList<Integer> FS = new FactorialLazyList();
    assertAll(
      () -> assertEquals(1, FS.next()),
      () -> assertEquals(2, FS.next()),
      () -> assertEquals(6, FS.next()),
      () -> assertEquals(24, FS.next()),
      () -> assertEquals(120, FS.next()));
  }
}
\end{lstlisting}

Design the \ttt{FibonacciLazyList} class, which implements \ttt{ILazyList<Integer>} and correctly overrides \ttt{next} to produce Fibonacci sequence values. You code should \emph{not} use any loops or recursion. Recall that the Fibonacci sequence is defined as $f(n) = f(n - 1) + f(n - 2)$ for all $n\geq{2}$. The base cases are $f(0) = 0$ and $f(1) = 1$.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class FibonacciLazyListTester {

  @Test
  void testFibonacciLazyList() {
    ILazyList<Integer> FS = new FibonacciLazyList();
    assertAll(
      () -> assertEquals(0, FS.next()),
      () -> assertEquals(1, FS.next()),
      () -> assertEquals(1, FS.next()),
      () -> assertEquals(2, FS.next()),
      () -> assertEquals(3, FS.next()),
      () -> assertEquals(5, FS.next()));
  }
}
\end{lstlisting}

\myexercise{2}{chapter-classes}{Design the \ttt{LazyListTake} class. Its constructor should receive an \ttt{ILazyList} and an integer~$n$ denoting how many elements to take, as parameters. Then, write a \ttt{List<T> getList()} method, which returns a \ttt{List<T>} of~$n$ elements from the given lazy list.}


\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class LazyListTakeTester {

 @Test
 void testLazyListTake() {
  LazyListTake llt1 = new LazyListTake(new FactorialLazyList(), 8);
  LazyListTake llt2 = new LazyListTake(new FibonacciLazyList(), 10);

  assertAll(
    () -> assertEquals("[1, 2, 6, 24, 120, 720, 5040, 40320]",
                       llt1.getList().toString()),
    () -> assertEquals("[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]",
                       llt2.getList().toString()));
 }
}
\end{lstlisting}

\myexercise{2}{chapter-classes}{Java's functional API allows us to pass lambda expressions as arguments to other methods, as well as method references (as we saw in Chapter~\ref{chapter-arrays-collections}). Design the generic \ttt{FunctionalLazyList} class to implement \ttt{ILazyList}, whose constructor receives a unary function \ttt{Function<T, T> f} and an initial value \ttt{T t}. Then, override the \ttt{next} method to invoke $f$ on the current element of the lazy list and return the previous. For example, the following test case shows the expected results when creating a lazy list of infinite positive multiples of three.}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;
import static Assertions.assertAll;

class FunctionalLazyListTester {

  @Test
  void testMultiplesOfThreeLazyList() {
    ILazyList<Integer> mtll = new FunctionalLazyList<>(x -> x + 3, 0);
    assertAll(
      () -> assertEquals(0, mtll.next()),
      () -> assertEquals(3, mtll.next()),
      () -> assertEquals(6, mtll.next()),
      () -> assertEquals(9, mtll.next()),
      () -> assertEquals(12, mtll.next()));
  }
}
\end{lstlisting}

What's awesome about this exercise is that it allows us to define the elements of the lazy list as any arbitrary lambda expression, meaning that we could redefine \ttt{FactorialLazyList} and \ttt{FibonacciLazyList} in terms of \ttt{FunctionLazyList}. We can generate infinitely many ones, squares, triples, or whatever else we desire.

\myexercise{2}{chapter-classes}{Design the generic \ttt{CyclicLazyList} class, which implements \ttt{ILazyList}, whose constructor is variadic and receives any number of values. Upon calling \ttt{next}, the cyclic lazy list should return the first item received from the constructor, then the second, and so forth until reaching the end. After returning all the values, cycle back to the front and continue. For instance, if we invoke \ttt{new CyclicLazyList<Integer>(1, 2, 3)}, invoking \ttt{.next} five times will produce \ttt{1}, \ttt{2}, \ttt{3}, \ttt{1}, \ttt{2}.}

\myexercise{3}{chapter-classes}{In this exercise you will design a simple particle system manager. A \emph{particle system} is a data structure that manages particles, or small effects, in a graphical engine. Think of a video game that has smoke, fire, water, explosion, or other kinds of effects. In general, these all use particle engines for managing hundreds of thousands of particle objects. Therefore, such an engine should be efficient.}

\begin{enumerate}[label=(\alph*)]
  \item In the first part of this exercise, you will design the \ttt{Particle} class.
  \begin{enumerate}[label=(\roman*)]
    \item A \texttt{Particle} contains a \ttt{double x} and \ttt{double y} representing its position, a \ttt{double width} and \ttt{double height} representing its dimensions, and a \ttt{double dx} and \ttt{double dy} representing its velocity. Finally, it contains a \ttt{double life} representing its life. The constructor should receive these as parameters and assign them to the instance variables.
    \item Inside the \ttt{Particle} class, design the \ttt{update} method, which adds the particle's velocity to its position. It should also decrement the \ttt{life} instance variable by one. If \ttt{life} ever becomes zero or negative, the particle is no longer alive. If the particle \emph{isn't} alive, do not update its position (nor decrement its life).
    \item Design the \ttt{isAlive} method that returns whether or not the particle is alive.
  \end{enumerate}
  \item Now, you will design the \ttt{ParticleSystem} class for efficiently managing multiple particle instances. The idea behind this particle system is that we create a \emph{memory pool}, and poll already-allocated particles from it when available. That is, when a particle dies, it moves to the ``dead'' sector, but that memory still exists. Then, when we want to create a new \ttt{Particle}, we first check to see if there are any dead particles that we can reuse. If so, we reuse that particle's allocated memory and simply reassign variables. 
  \begin{enumerate}[label=(\roman*)]
    \item In the \ttt{ParticleSystem} class, store the following instance variables and instantiate them as \ttt{LinkedList} instances in the constructor. The constructor should also receive a value \ttt{maxAlive}, which is assigned to a \ttt{final int MAX\_ALIVE} instance variable.
    \begin{itemize}
      \item \ttt{List<Particle> alive}, which stores the alive particles in the system. All particles in this list should be non-\ttt{null}.
      \item \ttt{List<Particle> dead}, which stores the dead particles in the system. All particles in this list should be non-\ttt{null}.
    \end{itemize}
    \item Design the \ttt{boolean addParticle(double x, double y, double w, double h, double dx, double dy, double life)} method that adds a particle to the system with the given parameters. If there are no dead particles available, then simply allocate a \ttt{new Particle} onto the rear of the \ttt{alive} list. If there is a dead particle, use that allocated space instead and assign the parameters to the object using the respective setters. Then, move the particle out of the \ttt{dead} list and onto the rear of the \ttt{alive} list. If it is impossible to add a new particle (because there is no space for more alive particles), return \ttt{false}. Otherwise, return \ttt{true}.
    \item Design the \ttt{void updateSystem()} method that traverses over the alive particles, and invokes their \ttt{update} methods. After invoking a particle's \ttt{update} method, check to see if it is alive or not. If it is not alive, move it out of the \ttt{alive} list and into the \ttt{dead} list. 
  \end{enumerate}
  \newpage %ugh
  \item In the final part of this exercise, you will design two subclass particles.
  \begin{enumerate}[label=(\roman*)]
    \item Design the \ttt{SparkParticle} class, which inherits from \ttt{Particle}. ``Spark particles'' move in a straight line, but their velocity decreases over time due to air resistance until they stop moving.
    \begin{itemize}
        \item The \ttt{SparkParticle} constructor receives the same values as its superclass counterpart.
        \item Override the \ttt{update} method to decrease the vertical and horizontal velocities by 10\% with each call to \ttt{update}. Do \emph{not} call \ttt{super.update()}. Instead, update the position of the particle directly inside this class. Remember that those variables are private in the \ttt{Particle} class.
        \item Override the \ttt{isAlive} method to return \ttt{false} when its horizontal and vertical velocity values are both less than~$0.01$ away from zero. Otherwise, it should return \ttt{true}.
    \end{itemize}
    \item Design the \ttt{SmokeParticle} class, which inherits from \ttt{Particle}. ``Smoke particles'' move in a straight line, but their velocity decreases over time due to air resistance until they stop moving.
    \begin{itemize}
        \item The \ttt{SmokeParticle} constructor receives the same values as its superclass counterpart.
        \item Override the \ttt{update} method to increase the width and height dimensions by 2\% with each call to \ttt{update}. Do \emph{not} call \ttt{super.update()}. Instead, update the position of the particle directly inside this class (the behavior is the same as the \ttt{Particle} superclass). Remember that those variables are private in the \ttt{Particle} class. Finally, decrement the life by \ttt{0.2} rather than \ttt{1}.
    \end{itemize}
  \end{enumerate}
\end{enumerate}



\myexercise{1}{chapter-classes}{Design the \ttt{static <T> Predicate<T> orEq(Predicate<T> p, T x)} method that, when given a predicate $p$ and an object $x$, returns a \emph{new} predicate that returns true if its argument $x'$ is equal (using \ttt{equals}) to $x$ or satisfies $p(x)$.}

\myexercise{2}{chapter-classes}{Design the \ttt{static <T> List<T> predOrEq(List<T> ls, Predicate<T> p, BiFunction<T, T, Boolean>, T x)} method that, when given a list of values $\mathit{ls}$, a predicate $p$, a function $f$, and a value $x$ that returns the list of values in $\mathit{ls}$ that either satisfy $p$ or are equal according to $f$. For the purposes of this question, $f$ is a method of two arguments of type $T$ that determines whether or not they are ``equal'' according to some criteria.}

\myexercise{1}{chapter-classes}{Design the \ttt{static <T> boolean andMap(List<T> l, Predicate<T> p)} method that returns whether or not all elements of the input list satisfy the given predicate. Use the stream API to solve this problem, but do \emph{not} use the \ttt{allMatch} method, as that method solves the problem we want \emph{you} to solve!}

\myexercise{2}{chapter-classes}{Design the \ttt{static <T, U> U foldr(List<T> ls, BiFunction<T, U, U> f, U u)} me\-thod that receives a list of values $ls$, a function $f$, and an initial value $u$. The method should return the result of folding the list from the right with the given function and initial value. By ``folding,'' we mean that we apply $f$ to the last element of the list and the initial value, then apply $f$ to the second-to-last element and the result of the previous application, and so forth. To think of this in terms of infix notation over some list, consider the list $[a, b, c, d]$. Folding it over the function $\circ$ and initial value $u$ is $a \circ (b \circ (c \circ (d \circ u)))$. Do \emph{not} use the \ttt{reduce} method, as that method solves the problem we want \emph{you} to solve!}

\myexercise{1}{chapter-classes}{Design the \ttt{static <T, U> List<U> buildList(int n, Function<T, U> func)} method that receives an integer $n$ and a function $f$ and returns a list of $n$ elements, where the $i^\text{th}$ element is $f(i)$. For example, if we invoke \ttt{buildList(5, x -> x * x)}, we should receive the list $[1, 4, 9, 16, 25]$.}

\myexercise{1}{chapter-classes}{This exercise involves the doubly-linked list we wrote in the chapter.}
Design the \ttt{int size()} method, which returns the number of elements in the list. You can do this either recursively or with a loop. For better practice, try (and thoroughly test) both implementations.

\myexercise{2}{chapter-classes}{This exercise involves the doubly-linked list we wrote in the chapter.}
Design the \ttt{void set(int i, T v)} method, which overwrites/assigns, at index $i$, the value $v$. If the provided index is out-of-bounds, do nothing.

\myexercise{2}{chapter-classes}{This exercise involves the doubly-linked list we wrote in the chapter.}
Design the \ttt{void insert(int i, T v)} method, which inserts the value $v$ at index $i$. As an example, if we insert $4$ into the list $[20, 5, 100, 25]$ at index $2$, the list then becomes $[20, 5, 4, 100, 25]$. If the provided index is out-of-bounds, do nothing.

\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Our interpreter, so far, is very memory inefficient. The reason is not apparent at first glance, but consider every time that we create a \ttt{NumberNode} or, especially, a \ttt{BooleanNode}. There are only two possibilities for a \ttt{BooleanNode}: true and false, which are immutable by design. So, the interpreter should never waste time allocating an instance thereof when it can simply reference an existing one. Such an optimization follows the ``factory'' design pattern, which we will explore in Chapter~\ref{chapter-modern}.

Privatize the \ttt{BooleanNode} constructor, then design the \ttt{static BooleanNode of(boolean b)} method. It receives a boolean value $v$ and returns a reference to a pre-allocated static true or false node. Similarly, also privatize the \ttt{NumberNode} constructor and design the \ttt{static NumberNode of(double v)} method. This method returns a new \ttt{NumberNode} if the given value $v$ is not an integer between $[0, 1000)$. Otherwise, pre-cache those integer values and store them in a private lookup table.

\myexercise{1}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Add the \ttt{"read-number"} and \ttt{"print"} primitive operations to the language. The latter is polymorphic, meaning it can print both numbers and booleans.

\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Functional programming languages, in general, are a composition of expressions, wherein statements are more of an afterthought. To this end, design the \ttt{BeginNode} abstract syntax tree node, which receives a list of abstract syntax trees. At the interpreter level, the \ttt{BeginNode} should evaluate each of the abstract syntax trees in the list, and return the result of the last one.

\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Variables, in our language, are defined and bound exactly once, namely when they are defined within a let node. Though, in imperative programming, it is often crucial to allow variable reassignments. Design the \ttt{SetNode} class, which receives a variable and an abstract syntax tree, and reassigns the variable to the result of the abstract syntax tree. At the interpreter level, the \ttt{SetNode} should evaluate the abstract syntax tree, and reassign the variable to the result in the current environment (and only the current environment). This means that you'll need to modify the \ttt{Environment} class to allow for variable reassignments. Hint: create a \ttt{set} method in the \ttt{Environment} class.

\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.} Recursion is nice and intuitive, for the most part. Unfortunately, it is not always the most efficient way to solve a problem. For example, the Fibonacci sequence, as we saw in Chapter~\ref{chapter-crl}, is often defined recursively, but it is much more efficient to define it iteratively (or even with tail recursion). Design the \ttt{WhileNode} class, which receives a condition and an abstract syntax tree, and evaluates the abstract syntax tree until the condition is false. At the interpreter level, the \ttt{WhileNode} should evaluate the condition, and if it is true, evaluate the abstract syntax tree, and repeat until the condition is false. To test your implementation, you will need to combine the \ttt{WhileNode} with both the \ttt{SetNode} and \ttt{BeginNode} classes.

\myexercise{3}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.} Having to manually update our case analysis on the primitive operator type is cumbersome and prone to mistakes. A better solution would be to store the operator and its corresponding ``handler'' method, i.e., the method that receives the operands and does the logic of the operator. We can do this via a map where the keys are the string operators and the values are functional references to the handlers. Unfortunately, Java does not directly support passing methods as parameters, meaning they are not first-class. Conversely, we can make use of Java's functional interfaces to achieve our goal. Namely, the interface will contain one method: \ttt{AstNode apply(List<AstNode> args, Environment env)}, where \ttt{args} is the list of evaluated arguments. We will call the interface \ttt{IFunction} and make it generic, with the first type quantified to a list of \ttt{AstNode} instances, and the second type quantified to \ttt{AstNode}. Hopefully, the connection between these quantified types and the signature of \ttt{apply} is apparent. Using the below definition of \ttt{IFunction}, update \ttt{PrimNode} to no longer perform a case analysis in favor of the map. We provide an example of populating the map with the initial operators in a \ttt{static} block.

\begin{lstlisting}[language=MyJava]
@FunctionalInterface
interface IFunction<T, R> {
  
  R apply(T t);
}
\end{lstlisting}

\enlargethispage{1\baselineskip}
\begin{lstlisting}[language=MyJava]
import java.util.List;
import java.util.Map;
import java.util.HashMap;

class PrimNode extends AstNode {
  
  private static final Map<String, IFunction<List<AstNode>, AstNode>> OPS;
  
  static {
    OPS = new HashMap<>();
    OPS.put("+", this.primPlus);
  }

  @Override
  AstNode eval(Environment env) { /* TODO. */  }

  private AstNode primPlus(List<AstNode> args, Environment env) { /* ... */ }
}
\end{lstlisting}

\newpage %ugh
\myexercise{3}{chapter-classes}{This exercise is multi-part and involves the interpreter we wrote in the chapter.}
\begin{enumerate}[label=(\alph*)]
  \item First, design the \ttt{ProgramNode} class, which allows the user to define a program as a sequence of statements rather than a single expression.
  \item Design the \ttt{DefNode} class, which allows the user to create a global definition. Because we're now working with definitions that do not extend the environment, we should use the set method in environment. When creating a global definition via \ttt{DefNode}, we're expressing the idea that, from that point forward, the (root) environment should contain a binding from the identifier to whatever value it binds.
  \item Design the \ttt{FuncNode} node. We will consider a function definition as an abstract tree node that begins with \ttt{FuncNode}. This node has two parameters to its constructor: a list of parameter (string) identifiers, and a single abstract syntax tree node representing the body of the function. We will only consider functions that return values; void functions do not exist in this language.
  \item Design the \ttt{ApplyNode} class, which applies a function to its arguments. You do not need to consider applications in which the first argument is a non-function. 

  Calling/Invoking a function is perhaps the hardest part of this exercise. Here's the idea, which is synonymous and shared with almost all programming languages: 

  \begin{enumerate}[label=(\roman*)] 
  \item First, evaluate each argument of the function call. This will result in several evaluated abstract syntax trees, which should be stored in a list. 
  \item We then want to create an environment in which the formal parameters are bound to their arguments. Overload the extend method in \ttt{Environment} to now receive a list of string identifiers and a list of (evaluated) AST arguments. Bind each formal to its corresponding AST, and return the extended environment. 
  \item Evaluate the function abstract syntax tree to get its function definition as an abstract syntax tree.
  \item Call \ttt{eval} on the function body and pass the new (extended) environment.
  \end{enumerate}
  This seems like a lot of work (because it is), but it means you can write really cool programs, including those that use recursion!
  %\enlargethispage{2\baselineskip}
\begin{small}
\begin{verbatim}
new ProgramNode(
  new DefNode("!", 
    new FuncNode(
      List.of("n"),
      new IfNode(
        new PrimNode("eq?", 
          new VarNode("n"), 
          new NumNode(0)),
        new NumNode(1),
        new PrimNode("*", 
          new VarNode("n"), 
          new ApplyNode("!", 
            new PrimNode("-", 
            new VarNode("n"), 
            new NumNode(1))))))),
  new ApplyNode("!", new NumNode(5)))
\end{verbatim}
\end{small}
\end{enumerate}

\newpage %ugh
\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter, and relies on the addition of \ttt{FuncNode} and \ttt{ApplyNode}.}
Our current version of the interpreter uses \textit{dynamic scoping}. A dynamically-scoped interpreter is one that uses the value of the closest declaration of a variable. This seems like nonsense without an example, so consider the following code listing.
\begin{lstlisting}[language=MyScheme, frame=single]
(define f
  (let ([x 10])
    ((*;$\lambda$;*) ()
      x)))

(let ([x 3])
  (f))
\end{lstlisting}

Under dynamic scoping, this program outputs \ttt{3}, because the binding of \ttt{x} takes on the value \ttt{3}. On the other hand, if we were using a \textit{lexically-scoped} interpreter, the program would output \ttt{10}, which seems to make more sense due to the binding that exists immediately above the function declaration. The question is: how do we implement lexical scoping into our interpreter? The answer is via \textit{closures}, which are data structures that couple a function definition with an environment. Then, when we apply a closure to an argument (if it exists), we restore the environment that was captured by the closure. 

To this end, design the \ttt{ClosureNode} class, whose constructor receives a \ttt{FuncNode} and an \ttt{Environment}. The respective \ttt{eval} method returns \ttt{this}, but \ttt{FuncNode} changes slightly. Rather than returning \ttt{this}, we return a \ttt{ClosureNode}, which wraps the current \ttt{FuncNode} and the environment passed to \ttt{eval}. Finally, inside \ttt{ApplyNode}, evaluating the function definition should resolve to a closure. Evaluate the arguments to the closure inside the passed environment, but \textit{extend} the captured environment, and bind the formals to the arguments in this extended environment. The body of the closure's function definition is then evaluated inside this new environment. 

Making this alteration not only causes our programs to output the ``common sense'' result, but also means we can implement recursive functions using \textit{only} a \ttt{LetNode}. See if you can figure out how to do this!

\myexercise{3}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Data structures are a core and fundamental feature of programming languages. A language without them, or at least one to build others on top of, suffers severely in terms of usability. We will implement a \emph{cons}-like data structure for our interpreter. In functional programming, we often use three operations to act on data structures akin to linked lists: \emph{cons}, \emph{first}, and \emph{rest}, to construct a new list, retrieve the first element, and retrieve the rest of the list respectively. We can inductively define a cons list as follows:

\begin{verbnobox}[\small]
A ConsList is one of:
 - new ConsList()
 - new ConsList(x, ConsList)
\end{verbnobox}

\enlargethispage{2\baselineskip}
Implement the cons data structure into your interpreter. This should involve designing the \ttt{ConsNode} class that conforms to the aforementioned data definition. Moreover, you will need to update \ttt{PrimNode} to account for the \ttt{first} and \ttt{rest} primitive operations, as well as an \ttt{empty?} predicate, which returns whether or not the cons list is empty. Finally, override \ttt{toString} inside \ttt{ConsNode}, which amounts to printing each element, separated by spaces, inside of brackets, e.g., \ttt{[$l_0, l_1, \ldots, l_{n-1}]$}.

\newpage %ugh
\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Having to manually type out the abstract syntax tree constructors when writing tests is extremely tedious. Design a \emph{lexer} for the language described by the interpreter. That is, the text is broken up into tokens that are then categorized. For example, \ttt{\q{}(\q{}} might become \ttt{OPEN\_PAREN}, \ttt{"lambda"} might become \ttt{SYMBOL}, \ttt{"variable-name"} might become \ttt{SYMBOL}, and \ttt{123.45} might become \ttt{NUMBER}. The output of the lexer is a list of tokens. Part of the trick is to ensure that after reading an open parenthesis, the next token is not grabbed as part of the open parenthesis.

\myexercise{3}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Design a parser for the language described by the interpreter. The idea is to tokenize a raw string, then parse the tokens to create an abstract syntax tree that represents the program. A good starting point would be to parse \emph{all} parenthesized expressions into what we will call \ttt{SExprNode}, then traverse over the tree to ``correct'' them into their true nodes, e.g., whether they are \ttt{IfNode}, \ttt{LetNode}, and so forth. Realistically, all programs in our language are, at their core, either primitive values or s-expressions.

\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
The Scheme programming language and its derivatives support \emph{code quotation}, i.e., the ability to convert an evaluable expression into data. As an example, if we evaluate \ttt{new QuoteNode(new VarNode("x"))}, we receive a symbol as the output, rather than the evaluated symbol via environment lookup. Add the \ttt{QuoteNode} class to your interpreter.

\myexercise{3}{chapter-classes}{In Chapter~\ref{chapter-crl}, we discussed tail recursion and an action performed by some programming languages known as tail-call optimization. We know that we can convert any (tail) recursive algorithm into one that uses a loop, and we described said process in the chapter. There is yet another approach that we can mimic in Java with a bit of trickery and interfaces.}

The problem with tail recursion (and recursion in general) in Java is the fact that it does not convert tail calls into iteration, which means the stack quickly overflows with activation records. We can make use of a \emph{trampoline} to force the recursion into iteration through \emph{thunks}. In essence, we have a tail recursive method that returns either a value or makes a tail recursive call, such as the factorial example below. Inside our base case, we invoke the \ttt{done} method with the accumulator value. Otherwise, we invoke the \ttt{call} method containing a lambda expression of no arguments, whose right-hand side is a recursive call to \ttt{factTR}. Functions, or lambda expressions, that receive no arguments are called thunks.

\enlargethispage{4\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;
import static Assertions.assertDoesNotThrow;

import java.lang.BigInteger;
import java.lang.StackOverflowError;

class FactorialTailRecursiveTester {
  
  @Test 
  void testFactTailRecursiveTrampoline() {
    assertAll(
      () -> assertEquals(BigInteger.valueOf(120), 
                         factTailCall(BigInteger.valueOf(5), BigInteger.ONE)),
      () -> assertDoesNotThrow(StackOverflowError.class,
                               () -> factTailCall(BigInteger.valueOf(50000), 
                                                  BigInteger.ONE)));
  }
}
\end{lstlisting}

\newpage %ugh
\begin{lstlisting}[language=MyJava]
import java.lang.BigInteger;

class FactorialTailRecursive {
 
  /**
   * Tail-recursive factorial function. Uses BigInteger to 
   * avoid number overflow and thunks to avoid stack overflow.
   * @param n the number to compute the factorial of.
   * @param ac the accumulator.
   * @return a tail call that is either done or not done.
   */
  static ITailCall<BigInteger> factTailCall(BigInteger n, BigInteger ac) {
    if (n.equals(BigInteger.ZERO)) { 
      return TailCallUtils.done(ac); 
    } else {
      return TailCallUtils.call(() -> 
                factTailCall(n.subtract(BigInteger.ONE), ac.multiply(n)));
    }
  }
}
\end{lstlisting}

The idea is that we have a helper class and method, namely \ttt{invoke}, that continuously applies the thunks, \textbf{inside a while loop}, until the computation is done. The trampoline analogy is used because we bounce on the trampoline while invoking thunks and jump off when we are ``done.''

First, design the generic \ttt{ITailCall<T>} interface. It should contain only one (non-default) method: \ttt{ITailCall<T> apply()}, which is necessary for the \ttt{invoke} method. The remaining methods are all default, meaning they must have a body. Design the \ttt{boolean isDone()} method to always return false. Design the \ttt{T getValue()} method to simply return \ttt{null}. Finally, design the \ttt{T invoke()} method that stores a local variable and constantly calls \ttt{apply} on itself until it is ``done.'' 

Second, design the \ttt{TailCallUtils} final class to contain a private constructor (this class will only utilize and define two static methods). The two methods are as follows:

\begin{itemize}
  \item \ttt{static <T> ITailCall<T> call(ITailCall next)}, which receives and returns the next tail call to apply. This definition should be exactly one line long and as simple as it seems.
  \item \ttt{static <T> ITailCall<T> done(T val)}, which receives the value to return from the trampoline. We need to create an instance of an interface, which sounds bizarre, but is possible only when we provide an implementation of its methods. So, return a \ttt{new ITailCall<>()}, and inside its body, override the \ttt{isDone} and \ttt{getValue} methods with the correct bodies.
\end{itemize}

Finally, run the factorial test that we provided earlier in its JUnit suite. It should pass and not stack overflow, hence the inclusion of an \ttt{assertDoesNotThrow} call.

% \myexercise{3}{chapter-classes}{In this series of problems, you will design several methods that act on very large \emph{natural numbers} resembling the \ttt{BigInteger} class. You \emph{\textbf{cannot}} use any methods from \ttt{BigInteger}, or the \ttt{BigInteger} class itself.} 

% \begin{enumerate}[label=(\alph*)]
%     \item Design the \ttt{BigNat} class, which has a constructor that receives a string. The \ttt{BigNat} class stores a \ttt{List<Integer>} as an instance variable. You will need to convert the given string into said list. Store the digits in reverse order, i.e., the least-significant digit (the ones digit) of the number is the first element of the list.
%     \item Design the \ttt{private void trimLeadingZeroes()} method that removes all leading zeroes from the number. That is, \ttt{new BigNat("0032")} should be trimmed to \ttt{"32"}. You may need to call this method in other methods, so do so when you feel it is necessary. Be careful to not trim all the zeroes from a number, e.g., \ttt{new BigNat("00000")} should be \ttt{"0"} and not the empty string.
%     \item Override the \ttt{public String toString()} method to return a string representation of the \ttt{BigNat} object. 
%     In particular, place commas between the digits where necessary, e.g., \ttt{"1,000"} and \ttt{"12,345,678"}.
%     \item Design the \ttt{BigNat copy()} method that returns a new \ttt{BigNat} instance representing the same natural number as \ttt{this} instance instance of \ttt{BigNat}. Do \emph{not} simply copy the reference to the list of digits over to the new \ttt{BigNat} (this violates the aliasing principle that we have repeatedly discussed and can be the cause of relentless debugging).
%     \item Implement the \ttt{Comparable<BigNat>} interface, and override the method that it provides, namely \ttt{public int compareTo(BigNat b)}, to return the sign of the result of comparing the given \ttt{BigNat} (which we will call $b$) to \ttt{this} \ttt{BigNat} (which we will call $a$). Namely, if $a < b$, return $-1$, if $a > b$, return $1$, otherwise return $0$.
%     \item Override the \ttt{public boolean equals(Object obj)} method to compare two \ttt{BigNat} values for equality. Remember that you have to cast the given parameter to an instance of the \ttt{BigNat} class. Because you implemented the \ttt{compareTo} method, defining \ttt{BigNat} equality is trivial.
%     \item Design the \ttt{BigNat add(BigNat bn)} method, which adds a \ttt{BigNat} to \ttt{this} \ttt{BigNat}. Do not modify the digits/value of \ttt{this} or the parameter. Note: this problem is harder than it may look at first glance!
%     \item Design the \ttt{BigNat sub(BigNat bn)} method, which subtracts a \ttt{BigNat} from \ttt{this} \ttt{BigNat}. If the subtrahend (the right-hand side of the subtraction) is greater than the minuend, the result is zero. Over the natural numbers, this is called the \emph{monus} operator. Do not modify the digits/value of \ttt{this} or the parameter.
%     \item Design the \ttt{BigNat mul(BigNat bn)} method, which multiplies a \ttt{BigNat} with \ttt{this} \ttt{BigNat}. You cannot use the recursive algorithm. That is, your method must not define multiplication in terms of repeated addition, as that would be astronomically slow. Do not modify the digits/value of \ttt{this} or the parameter.
% \end{enumerate}

\newpage %ugh
\myexercise{3}{chapter-classes}{In this series of problems, you will design several methods that act on very large/small \emph{integers} resembling the \ttt{BigInteger} class. You \emph{\textbf{cannot}} use any methods from \ttt{BigInteger}, or the \ttt{BigInteger} class itself.} 

\begin{enumerate}[label=(\alph*)]
  \item Design the \ttt{BigInt} class, which has a constructor that receives a string. The \ttt{BigInt} class stores a \ttt{List<Integer>} as an instance variable, as well as a boolean for keeping track of whether it is negative. You will need to convert the given string into said list of digits. Store the digits in reverse order, i.e., the least-significant digit (the ones digit) of the number is the first element of the list. Leading zeroes should be omitted from the representation.

  The possible values for the parameter are an optional sign (either positive \textbf{or} negative), followed by one or more digits.

  Below are some example inputs.
\begin{small}
\begin{verbatim}
new BigNat("42")       => [2, 4], isNegative = false
new BigNat("0420")     => [0, 2, 4], isNegative = false
new BigNat("-42")      => [2, 4], isNegative = true
new BigNat(0000420000) => [0, 0, 0, 0, 2, 4], isNegative = false
new BigNat("+42")      => [2, 4], isNegative = false;
\end{verbatim}
\end{small}

  \item Override the \ttt{public boolean equals(Object o)} method to return whether \ttt{this} instance represents the same integer as the parameter. If \ttt{o} is not an instance of \ttt{BigInt}, return \ttt{false}.

\begin{small}
\begin{verbatim}
new BigInt("42").equals(new BigInt("42"))      => true
new BigInt("00042").equals(new BigInt("0042")) => true
new BigInt("+42").equals(new BigInt("42"))     => true
new BigInt("42").equals(new BigInt("-42"))     => false
new BigInt("-42").equals(new BigInt("-42"))    => false
new BigInt("422").equals(new BigInt("420"))    => false
\end{verbatim}
\end{small}

  \item Override the \ttt{public String toString()} method to return a stringified version of the number. Remember to include the negative sign where appropriate. If the number is positive, you do not need to include it.

  \item Implement the \ttt{Comparable<BigInt>} interface and override the method it provides, namely \ttt{public int compareTo(BigInt b2)}. Return the result of comparing \ttt{this} instance with the parameter. That is, if~$a < b$, return~$-1$, if~$a > b$, return~$1$, and otherwise return~$0$, where~$a$ is \ttt{this} and~$b$ is \ttt{b2}.

  \item Design the \ttt{BigInt copy()} method, which returns a (deep)-copy of instance representing the same integer as \ttt{this} instance of \ttt{BigInt}. Do \emph{not} simply copy the reference to the list of digits over to the new \ttt{BigInt} (this violates the aliasing principle that we have repeatedly discussed and can be the cause of relentless debugging).

  \item Design the \ttt{BigInt negate()} method, which returns a copy of \ttt{this} instance of \ttt{BigInt}, but negated. Do \emph{not} modify \ttt{this} instance.
  
  \item Design the \ttt{private boolean areDifferentSigns(BigInt b)} method, which returns whether \ttt{this} instance and \ttt{b} have different signs. That is, if one is positive and one is negative, \ttt{areDifferentSigns} returns \ttt{true}, and false otherwise.

  \item Design the \ttt{private BigInt addPositive(BigInt b)} method, which returns a \ttt{BigInt} instance that is the sum of \ttt{this} and \ttt{b} under the assumption that \ttt{this} and \ttt{b} are non-negative. \emph{Be sure you thoroughly test this method!}

  \item Design the \ttt{private BigInt subPositive(BigInt b)} method, which returns a \ttt{BigInt} instance that is the difference of \ttt{this} and \ttt{b} under the assumption that \ttt{this} and \ttt{b} are non-negative, and the minuend (the left-hand operand) is greater than or equal to the subtrahend (the right-hand operand). \emph{Be sure you thoroughly test this method!}

  \item Design the \ttt{private BigInt mulPositive()} method, which returns a \ttt{BigInt} instance that is the product of \ttt{this} and \ttt{b} under the assumption that \ttt{this} and \ttt{b} are non-negative. \emph{Be sure you thoroughly test this method!}

  \item Design the \ttt{BigInt add(BigInt b)} and \ttt{BigInt sub(BigInt b)} method that returns the sum/difference of \ttt{this} and \ttt{b} respectively. Note that these methods should be a case analysis of the signs of the operands. Use the following equivalences to guide your design. Do \emph{not} over-complicate these methods.

  \begin{align*}
    A + (-B) &= A - B \text{ if } A \geq B. \text{ Otherwise, } -(B - A).\\
    (-A) + (-B) &= -(A + B).\\
    A - (-B) &= A + B.\\
    (-A) - B &= -(A + B).\\
    (-A) - (-B) &= (-A + B) \text{ if } A \geq B. \text{ Otherwise, } (B - A).\\
  \end{align*}

  \item Design the \ttt{BigInt mul(BigInt b)} method that returns the product of \ttt{this} and \ttt{b}. The product of two negative integers is a positive integer, and the product of exactly one positive and exactly one negative is a negative integer.

\end{enumerate}

\myexercise{3}{chapter-classes}{Recall the unification exercise from Chapter~\ref{chapter-arrays-collections}. We can take the idea of unification a step further, which is the basis for almost all logic programming languages such as Prolog. For instance, take the expression \ttt{p(X, f(Y))}; attempting to unify this with \ttt{p(q(r(x)), f(b(x)))} returns a unification assignment of \ttt{X : q(r(x)), Y : b(x)}. It is possible for a unification to not return any possible assignment. As an example, unifying \ttt{p(a, b)} with \ttt{p(Y, Y)} returns an empty assignment because it is not possible to unify~\ttt{a} with~\ttt{Y}, then unify~\ttt{b} with~\ttt{Y}.}

Design three classes: \ttt{Variable}, \ttt{Constant}, and \ttt{Predicate}. Each of these should implement the \ttt{IUnifiable} interface, which supplies one method: \ttt{Assignment unify(IUnifiable u, Assignment as)}. An \ttt{Assignment} is simply a mapping of \ttt{IUnifiable} objects to \ttt{IUnifiable} objects, resembling a map data structure. Variables in this small language will be represented as upper0cased letters, whereas constants are lowercase. If two \ttt{IUnifiable} objects cannot be unified, then \ttt{unify} should return \ttt{null}.

Constants are straightforward: constants can only be unified with other constants if they are equivalent. Constants can only be unified with variables if that variable does not have an existing assignment and, if it does, it must be equal to \ttt{this} constant. Constants cannot be unified with predicates.

Variables can only be unified with constants if the variable does not have an existing assignment and, if it does, it must be equal to the constant passed as an argument. Variables can only be unified with other variables if at least one is bound to a constant; if they are both bound, then they must be equivalent constants. 

\enlargethispage{2\baselineskip}
Predicates can only be unified with variables if the variable does not have an existing assignment and, if it does, it must be equal to \ttt{this} predicate. Predicates can only be unified with predicates if it is possible to successfully unify all of its arguments. E.g., \ttt{p(a, z(b), c)} unifies with \ttt{p(X, z(Y), Z)} because we return the assignment \ttt{X : a, Y : b, Z : c}. 

\newpage %ugh
\myexercise{3}{chapter-classes}{Quine's method of truth resolution~\cite{methodsoflogic} is a method of automatically reasoning about the truth of a propositional logic statement (recall the exercise from Chapter~\ref{chapter-crl}). The method is as follows:}

\begin{enumerate}
    \item Choose an atom $P$ from the statement. Consider two cases: when $P$ is true and when $P$ is false. Derive the consequences of each case. The rules follow those of the propositional logic connectives.
    \item Repeat this process for each sub-statement until there are no more sub-statements, and you have only true or false results. If you have \emph{both} true and false results, the statement is a contingency. If all branches lead to true, the statement is a tautology. If all branches lead to false, the statement is a contradiction. 
\end{enumerate}

Design several classes to represent a series of well-formed schemata in propositional logic, namely \ttt{CondNode}, \ttt{BicondNode}, \ttt{NegNode}, \ttt{AndNode}, \ttt{OrNode}, and \ttt{AtomNode}, all of which extend a root \ttt{Node} class, similar to our representation of the abstract syntax trees within the ASPL interpreter. Then, design the \ttt{boolean isTautology(Node t)}, \ttt{boolean isContingency(Node t)}, and the \ttt{boolean isContradiction(Node t)} methods, which return whether or not the given statement is a tautology, contingency, or contradiction, respectively. You may assume that the input is a well-formed schema. Note that only one of these methods needs a full-fledged recursive traversal over the data; the other two can be implemented in terms of the first.