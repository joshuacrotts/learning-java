\section{Exercises}

\myexercise{1}{chapter-classes}{Design the \ttt{Car} class, which stores a \ttt{String} representing the car's make, a \ttt{String} representing the car's model, and an \ttt{int} representing the car's year. Its constructor should receive these three values and store them in the instance variables. Be sure to write instance accessor and mutator methods for modifying all three fields. That is, you should write \ttt{getMake()}, \ttt{setMake(String s)}, and so forth, to access and modify the fields directly.}

\myexercise{1}{chapter-classes}{Design the \ttt{Dog} class, which stores a \ttt{String} representing the breed, a \ttt{String} representing its name, and an \ttt{int} representing its age in years. You should also store a boolean to keep track of whether or not the dog is a puppy. A dog is a puppy if it is less than two years old. Its constructor should receive these three values and store them in the instance variables. Be sure to write instance accessor and mutator methods for modifying all three fields. That is, you should write \ttt{getBreed()}, \ttt{setBreed(String s)}, and so forth, to access and modify the fields directly.}

\myexercise{1}{chapter-classes}{Design the \ttt{Person} class, which stores a \ttt{String} representing the person's first name, a \ttt{String} representing the person's last name, and an \ttt{int} representing the person's age in years. Its constructor should receive these three values and store them in the instance variables. Be sure to write instance accessor and mutator methods for modifying all three fields. That is, you should write \ttt{getFirstName()}, \ttt{setFirstName(String s)}, and so forth, to access and modify the fields directly.}

\myexercise{1}{chapter-classes}{Design the \ttt{Employee} class, which stores the employee's first and last names as strings, their birthyear as an integer, their yearly salary as a double (we will assume that all employees are paid some value greater than zero), and their employee ID as a string.}
    
To make things interesting, assume that an employee's ID is not alterable and must be set in the constructor. The employee ID is constructed using the first five characters of their last name, the first letter of their first name, and the last two digits of their birthyear. For instance, if the employee's name is \ttt{Joshua Crotts} and their birthyear is \ttt{1999}, their employee ID is \ttt{CrottJ99}. Its constructor should receive the name, birthyear, and salary as parameters, but build the employee ID from the name and birthyear.

The instance variables, accessors, and mutators (where applicable) should be named as follows:
\begin{itemize}
    \item \ttt{id}, \ttt{getId}.
    \item \ttt{firstName}, \ttt{getFirstName}.
    \item \ttt{lastName}, \ttt{getLastName}.
    \item \ttt{birthYear}, \ttt{getBirthYear}.
    \item \ttt{salary}, \ttt{getSalary}, \ttt{setSalary}
\end{itemize}

\myexercise{1}{chapter-classes}{As part of the \ttt{Employee} class, design the \ttt{void bonus()} method, which updates the salary of an employee. Calling \ttt{bonus} on an employee increases their salary by ten percent.}

\myexercise{2}{chapter-classes}{As part of the \ttt{Employee} class, override the \ttt{equals} and \ttt{toString} methods from the \ttt{Object} class to compare two employees by their employee ID and to print the employee's name, birthyear, salary, and employee ID respectively separated by commas and a space. Do not add a comma and space after the last field.}

\myexercise{2}{chapter-classes}{In this exercise you will design a class for storing employees. This relies on completing the \ttt{Employee} class exercise.}
\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{Job} class, which stores a list of employees \ttt{List<Employee>} as an instance variable. Whether you choose to instantiate it as an \ttt{ArrayList} or a \ttt{LinkedList} is up to you and makes little difference for this particular question. Its constructor should receive no arguments. The instance variable, along with its accessor and mutator, should be named \ttt{employees}, \ttt{getEmployees}, and \ttt{setEmployees} respectively.
    \item Design the \ttt{void addEmployee(Employee e)} method, which adds an employee to the \ttt{Job}.
    \item Design the \ttt{void removeEmployee(Employee e)} method, which removes an employee from the \ttt{Job}.
    \item Design the \ttt{Optional<Double> computeAverageSalary()} method, which returns the average salary of all employees in the \ttt{Job}. If there are no employees, return an empty \ttt{Optional}.
    \item Design the \ttt{Optional<Employee> highestPaid()} method, which returns the employee whose salary is the highest of all employees in the \ttt{Job}. If there are no employees, return an empty \ttt{Optional}.
    \item Override the \ttt{toString} method to print out the list of employees in the \ttt{Job}. To make this easy, you can simply invoke the \ttt{toString} method from the \ttt{List} implementation.
\end{enumerate}

\myexercise{2}{chapter-classes}{In this exercise you will design a \emph{linear congruential generator}: a pseudorandom number generation algorithm. In particular, the C programming language standard library defines two functions: \ttt{rand} and \ttt{srand}. The latter sets the \emph{seed} for the generator, and \ttt{rand} returns a random integer between $[0, 2^{15})$. The formula for this generator is a recurrence relation:}
\begin{align*}
    \emph{next} &= |r_n \cdot 1103515245 + 12345|\\
    r_{n+1} &= \left(\dfrac{\emph{next}}{2^{16}}\right)\;\%\;2^{15};
\end{align*}

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{LcgRandom} class, which implements this behavior. In particular, it should have two constructors: one that receives a seed value $s$, and another that sets the seed to one. The seed initializes the value of $r_0$.
    \item Design the \ttt{int genInt()} method, which returns a random integer between $0$ and $2^{15}$ using this algorithm.
    \item Design the \ttt{IntStream stream()} method, which returns a stream of random numbers that uses \ttt{genInt} to generate numbers. Hint: use \ttt{generate}!
    \item Design the \ttt{genInt(int b)} method that returns an integer between $[0, b]$. Note that $0 \leq b < 2^{15}$; you do not need to account for values outside of this range. Do \textbf{not} simply loop until you find a value between that range; instead, use modulus to your advantage.
\end{enumerate}

\myexercise{3}{chapter-classes}{This question has six parts.}

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{Matrix} class, which stores a two-dimensional array of integers. Its constructor should receive two integers~$m$~and~$n$ representing the number of rows and columns respectively, as well as a two-dimensional array of integers. Copy the integers from the passed array into an instance variable array.
    \item Design the \ttt{void set(int i, int j, int val)} method, which sets the value at row $i$ and column $j$ to \ttt{val}.
    \item Design the \ttt{void add(Matrix m)} method, which adds the values of the passed matrix to the current matrix. If the dimensions of the passed matrix do not match the dimensions of the current matrix, do nothing.
    \item Design the \ttt{void multiply(Matrix m)} method, which multiplies the values of the passed matrix to the current matrix. If we cannot multiply~$m$ with this matrix, do nothing.
    \item Design the \ttt{void transpose()} method, which transposes the matrix. That is, the rows become the columns and the columns become the rows. You may need to alter the dimensions of the matrix.
    \item Design the \ttt{void rotate()} method, rotates the matrix~$90$ degrees clockwise. To rotate a matrix, compute the transposition and then reverse the rows. You may need to alter the dimensions of the matrix.
    \item Override the \ttt{String toString()} method to print out the matrix in a boxed format.
\end{enumerate}

\myexercise{2}{chapter-classes}{This exercise has five parts.}
\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{GameObject} class, which stores a \ttt{Pair<Double, Double>} denoting its center~$(x, y)$ position and a \ttt{Pair<Double, Double>} denoting its width and height respectively. Its constructor should receive four \ttt{double} values representing~$x$,~$y$, $\emph{width}$, and $\emph{height}$. Be sure to write instance accessor and mutator methods for modifying both fields. That is, you should write \ttt{double getLocationX()}, \ttt{void setLocationX(double d)}, and so forth, to access and modify the \ttt{Pair} values directly. 

    \item Design the \ttt{boolean collidesWith(GameObject obj)} method that returns if \ttt{this} \ttt{GameObject} collides with the parameter \ttt{obj}. You should design this solution as if the game objects are shaped like rectangles (which they are!).

    \item Design the \ttt{double distance(GameObject obj)} method that returns the Euclidean distance from the center of \ttt{this} \ttt{GameObject} to the center of the parameter \ttt{obj}. 

    \item Design the \ttt{double move(double dx, double dy)} method that moves the object about the Cartesian (two-dimensional) plane. The distance should be a delta represented as two \ttt{double} numbers \ttt{dx} and \ttt{dy} that directly manipulate the object position. For instance, if \ttt{dx} is~$3.0$ and \ttt{dy} is~$-2.0$ and the object is currently at \ttt{<2.0, -9.0>}, invoking \ttt{move(3.0, -2.0)} updates the object to be at \ttt{<5.0, -11.0>}.

    \item Override the \ttt{String toString()} method to call the \ttt{toString} methods of the two instance variables, conjoined by a semicolon.
\end{enumerate}

\myexercise{2}{chapter-classes}{This exercise has three parts.}
\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{GameRunner} class, which stores a list of objects \ttt{ArrayList<GameObject>} as an instance variable. Its constructor should receive an integer representing a random number generator seed. It should first instantiate \ttt{rand} to a new \ttt{Random} object with this seed, and then populate the list with twenty random \ttt{GameObject} instances at random \textbf{integer} positions with random \textbf{integer} sizes. These random positions should be between $[-10, 10]$ for both coordinates and the random sizes should be between $[1, 10]$ for both dimensions.

    \item Design the \ttt{void moveObjects()} method, which moves each object by three positive $x$ units and four negative $y$ units.

    \item Design the \ttt{String stringifyObjects()} method, which converts each object in the list into its string representation, with brackets around the elements, and separated by commas. Hint: you can use one method from the \ttt{Stream} class to do this quickly!
\end{enumerate}

\myexercise{2}{chapter-classes}{This exercise involves the ``Twenty-One'' game implementation from the chapter.}
\begin{enumerate}[label=(\alph*)]
    \item Change each card to use the Unicode symbol counterpart rather than the \ttt{"X of Y"} \ttt{toString} model, where \ttt{X} is the value and \ttt{Y} is the suit. The Unicode symbols are available on the second page of this PDF: \url{https://www.unicode.org/charts/PDF/U1F0A0.pdf}. This will be a little tedious, but it makes the game look cooler!
    \item Add the Ace, Jack, Queen, and King cards, instead of the previous implementation of using four cards whose values were all ten. A simple solution is to use a \ttt{String} that keeps track of the ``name'' of a card alongside the other instance variables. 
    \item Add an AI to the game (you do not need to test this class). This involves writing the \ttt{AI} class and designing the \ttt{boolean play(Deck deck)} method. An \ttt{AI} has a \ttt{ArrayList<Card>}, similar to \ttt{Player}, but makes decisions autonomously using the following algorithm (written in a pseudocode-like language):
    \begin{verbnobox}[\small]
boolean play(Deck d) {
  score = getScore()
  if score < 16 then:
    cards.add(d.drawCard())
    return true;
  else if (score > 16 && score < 21) {
    k = Generate a random integer between [0, 3).
    if k is zero then:
      cards.add(d.drawCard())
      return true;
  } 
  return false;
}
\end{verbnobox}
The method returns whether or not the AI drew a card. If they did not draw a card, then their turn is over. When playing the game, the player can see the first two cards dealt to an AI, but nothing more. You might want to add a static variable to the \ttt{Card} class representing the ``covered card.'' Note that the AI knows only the context of its deck of cards; it is not aware of any other \ttt{Player} or \ttt{AI}.
\item After designing the \ttt{AI} class and adding one to your game, create an \ttt{ArrayList<AI>} simulating multiple computer players in the game.
\end{enumerate}

\myexercise{1}{chapter-classes}{Add the \ttt{void set(T e, int idx)} method to the \ttt{MiniArrayList} class, which sets the element at $\emph{idx}$ to the given $e$ element.}

\myexercise{1}{chapter-classes}{Add the \ttt{void isEmpty()} method to the \ttt{MiniArrayList} class, which returns whether or not the list is empty.}

\myexercise{2}{chapter-classes}{Add the \ttt{void clear()} method to the \ttt{MiniArrayList} class, which ``removes'' all elements from the list. This should not change the capacity of the list. Note that there's a reason why ``removes'' is in quotes. We rank this exercise as a two-star not because of its length, but because it is a little tricky.}

\myexercise{2}{chapter-classes}{Override the \ttt{equals} method (from \ttt{Object}) in the \ttt{MiniArrayList} class to compare two lists by their elements. Return \ttt{true} if all elements in the two lists are \ttt{equals} to one another, and \ttt{false} otherwise.}

\myexercise{2}{chapter-classes}{Using the \ttt{StackFrame} class, design an implementation of the tail recursive factorial method. Recall how to do this from Chapter~\ref{chapter-crl}: instead of pushing an activation record to the call stack, we can simply update the bindings in the existing frame.}

\myexercise{2}{chapter-classes}{This exercise has six parts.}

In this question you will implement the \ttt{MiniStack} data structure. This is similar to the \ttt{MiniArrayList} class from the chapter, but, of course, is a stack and not an array list.

Unlike many stack implementations, however, we will use an array-backed stack. This means that, instead of using a collection of \ttt{private} and \ttt{static} \ttt{Node} classes, the stack will use an array to store its elements. When the array runs out of space, a new one is allocated and the elements are copied over. 

\begin{enumerate}[label=(\alph*)]
    \item First, design the generic \ttt{MiniStack} class. Its constructor should receive no arguments, and instantiate two instance variables: \ttt{T[] elements} and \ttt{size} to a new array and zero respectively. Remember that you cannot instantiate a generic array, so how do we do that? The initial capacity of the array should be set to \ttt{INITIAL\_CAPACITY}, which is a \ttt{private static final} variable declared in the class as ten.

    \item Second, design the \ttt{void add(T t)} method, which adds an element onto the top of the stack. The ``top of the stack,'' when using an array, is the right-most element, i.e., the element with the highest index. It might be a good idea to design a \ttt{private} helper method that resizes the underlying array when necessary. Your resize factor, i.e., how you resize the stack, is up to you.

    \item Third, design the \ttt{T peek()} method, which returns (but does not remove) the top-most element of the stack.

    \item Fourth, design the \ttt{T pop()} method, which returns \textit{and} removes the top-most element. Be sure that your \ttt{add} method still works after designing \ttt{pop}.

    \item Fifth, design the \ttt{int size} method, which returns the number of logical elements in the stack.

    \item Finally, override the \ttt{toString} method to return a string containing the elements of the stack from top-to-bottom, separated by commas and a space. For example, if the stack contains, from bottom-to-top, \ttt{10}, \ttt{20}, \ttt{30}, \ttt{40}, and \ttt{50}, the \ttt{toString} method returns \ttt{"50, 40, 30, 20, 10"}.
\end{enumerate}

\myexercise{3}{chapter-classes}{This exercise has seven parts.}

A \emph{chunked array list} data structure avoids the overhead of copying the underlying array upon running out of free spots. The idea is to break the collection into chunks, namely, as an \ttt{ArrayList} of arrays. Assuming that the underlying collection of chunks is adequately populated, this collection will seldom require a resizing operation. This data structure will not support arbitrary insertions or removals.

\begin{enumerate}[label=(\alph*)]
    \item Design the generic \ttt{ChunkedArrayList} class. It should store, as an instance variable, an \ttt{ArrayList<T[]>} of chunks, where $T$ is the parameterized type. Design two constructors: one that receives a chunk size $s$ and a number of preallocated chunks $n$, and another constructor that receives no parameters, defaulting $n$ to $10$ and $s$ to $50$.
    \item Design the \ttt{void add(T t)} method that, when given an item $t$, adds it to the end of the current chunk. If we run out of space in the current chunk, add it to the next chunk in succession. If there are no available chunks, add a new \ttt{T[]} of size $s$ to the list. Hint: use modulus.
    \item Design the \ttt{T get(int i)} method that, when given an index $i$, returns the item at that index. The user of this data structure should not need to know about the chunks or their implementation. Therefore, if $s=10$, and we access index $27$, it should receive the element in chunk $3$, index $7$. Assume that $i$ is in bounds.
    \item Design the \ttt{void resizeChunks(int n)} method that resizes each chunk to the input argument $n$. Depending on this value, you will need to either reallocate each underlying array or shift values around. For example, if we have a chunk array list with $150$ elements whose chunks hold up to $50$ elements each, and we resize the chunks to be $25$ in maximum capacity, we will double the number of necessary chunks. On the other hand, if we resize the chunks to hold $100$ elements, then the values in chunk two are shifted into chunk one, and those in chunk three are shifted into chunk two.
    \item Design the \ttt{int getChunkCapacity()} method that returns the maximum capacity of each chunk.
    \item Design the \ttt{int size()} method that returns the total number of elements in the chunk array list.
    \item Design the \ttt{int getChunkSize()} method that returns the number of chunks currently in-use.
\end{enumerate}

\myexercise{3}{chapter-classes}{This exercise has seven parts.}

A \emph{persistent data structure}\index{persistent data structure} is one that saves intermittent data structures after applying operations that would otherwise alter the contents of the data structure. Take, for instance, a standard FIFO queue. When we invoke its `enqueue' method, we modify the underlying data structure to now contain the new element. If this were a persistent queue, then enqueueing a new element would, instead, return a new queue that contains all elements and the newly-enqueued value, thereby leaving the original queue unchanged.

\begin{enumerate}[label=(\alph*)]
    \item First, design the generic, private, and static class \ttt{Node} inside a generic \ttt{PQueue} class skeleton. It should store, as instance variables, a pointer to its next element as well as its associated value.
    \item Then, design the \ttt{PQueue} class, which represents a persistent queue data structure. As instance variables, store ``first'' and ``last'' pointers as \ttt{Node} objects, as well as an integer to represent the number of existing elements. In the constructor, instantiate the pointers to \ttt{null} and the number of elements to zero.
    \item Design the \ttt{private PQueue<T> copy()} method that returns a new queue with the same elements as the current queue. You should divide this method into a case analysis: one where \ttt{this} queue is empty and another where it is not. In the former case, return a new queue with no elements. In the latter case, iterate over the elements of the queue, enqueuing each element into a new queue. You will need instantiate a new \ttt{Node} (reference) for each element.
    \item Design the \ttt{PQueue<T> enqueue(T t)} method that enqueues a value onto the end of a new queue containing all the old elements, in addition to the new value. You should use the \ttt{copy} method to your advantage.
    \item Design the \ttt{PQueue<T> dequeue()} method that removes the first element of the queue, returning a new queue without this first value. You should use the \ttt{copy} method to your advantage.
    \item Design the \ttt{T peek()} method that returns the first element of the queue.
    \item Design the \ttt{static <T> PQueue<T> of(T... vals)} method that creates a queue with the values passed as \ttt{vals}. Note that this must be a variadic method. Do not create a series of \ttt{PQueue} objects by enqueueing each element into a distinct queue; this is incredibly inefficient. Instead, allocate each \ttt{Node} one-by-one, thereby never calling \ttt{enqueue}.
    \item Design the \ttt{int size()} method that returns the number of elements in the queue. You should not traverse the queue to compute this value. 
\end{enumerate}

\myexercise{3}{chapter-classes}{This exercise has three parts.}

A \emph{deterministic finite state automaton} is an extremely primitive machine that represents transitions between the different states of a system. Think, as an example, of a light switch; there is an ``OFF'' state and an ``ON'' state, where flipping the switch flops between the two. The switch flip represents the input that causes a transition from one state to another. Programming languages most often use finite automata for character recognition, i.e., what characters are valid in the language grammar. The following is an example of a DFA diagram that accepts input strings that contain an odd number of \ttt{\q{}a\q{}} characters from an input alphabet $\Sigma = \{a, b\}$.

\begin{enumerate}[label=(\alph*)]
    \item First, begin by designing the skeleton for the \ttt{DFA} class, which contains the following private and static class definitions:
    \begin{itemize}
        \item \ttt{State}, which stores a string identifier, an \ttt{"isStart"} boolean flag and an \ttt{"isFinal"} flag. The class should contain appropriate accessors but no mutators.
        \item \ttt{Transition}, which stores two \ttt{State} objects $a$ and $b$ representing the ``from'' and ``to'', as well as the required input to transition from $a$ to $b$. 
    \end{itemize}
    \item The \ttt{DFA} constructor should be empty, and the class definition should store a \ttt{Set<Transition>} as well as a \ttt{Set<State>}. 
    \item Design the \ttt{void addState(State s)} method, which adds a new \ttt{State} to the finite automaton.
    \item Design the \ttt{State transition(State s, String i)} method, which returns the state arrived after making the transition from $s$ via input $i$.
    \item Finally, design the \ttt{boolean accepts(String v)} method, which receives an input string $v$ and traverses over the automaton to determine if it accepts or rejects the input. We accept $v$ if the last state we end on is marked as a final state.
\end{enumerate}

\myexercise{3}{chapter-exceptions-io}{A binary relation $\mathcal{R}$ is a subset of the cartesian product of two sets $A$ and $B$. That is, $\mathcal{R} \subseteq A \times B$ such that $A \times B = \{\langle{x, y}\rangle \mid x \in A \text{ and } y \in B\}$. There are several ways that we can describe binary relations, including reflexive, symmetric, transitive, antisymmetric, asymmetric, irreflexive, and serial.}

Design the generic \ttt{BinaryRelation<T, U>} class to represent a mathematical binary relation. It should store a \ttt{Set<Pair<String, String>{>}}, where the inner pair is the associated tuples of the set. Its constructor should instantiate the set instance variable. 

Then, design the following methods:

\begin{enumerate}[label=(\alph*)]
    \item \ttt{void addTuple(T x, U y)} receives two values $x$ and $y$ of types $T$ and $U$ respectively, and adds them as a tuple to the underlying set.
    
    \item \ttt{boolean isReflexive()} returns true if the relation is reflexive. A relation $\mathcal{R}$ is reflexive if, for all $x \in S$, $\langle{x, x}\rangle \in \mathcal{R}$.
    
    \item \ttt{boolean isSymmetric()} returns true if the relation is symmetric. A relation $\mathcal{R}$ is symmetric if, for all $x, y \in S$, $\langle{x, y}\rangle \in \mathcal{R}$ and $\langle{y, x}\rangle \in \mathcal{R}$.
    
    \item \ttt{boolean isTransitive()} returns true if the relation is reflexive. A relation $\mathcal{R}$ is transitive if, for all $x, y, z \in S$, if $\langle{x, y}\rangle \in \mathcal{R}$ and $\langle{y, z}\rangle \in \mathcal{R}$, then $\langle{x, z}\rangle \in \mathcal{R}$.
    
    \item \ttt{boolean isEquivalence()} returns true if the relation is an equivalence relation. A relation $\mathcal{R}$ is an equivalence relation if it is reflexive, symmetric, and transitive.

    \item \ttt{boolean isIrreflexive()} returns true if the relation is irreflexive. A relation $\mathcal{R}$ is irreflexive if, for all $x \in S$, $\langle{x, x}\rangle \not\in \mathcal{R}$.
    
    \item \ttt{boolean isAntisymmetric()} returns true if the relation is antisymmetric. A relation $\mathcal{R}$ is antisymmetric if, for all $x, y \in S$, if $\langle{x, y}\rangle \in \mathcal{R}$ and $\langle{y, x}\rangle \in \mathcal{R}$, then $x \neq y$.
    
    \item \ttt{boolean isAsymmetric()} returns true if the relation is asymmetric. A relation is asymmetric if it is both antisymmetric and irreflexive.

    \item \ttt{boolean isSerial()} returns true if the relation is serial. A relation $\mathcal{R}$ is serial if, for all $x \in S$, there exists a $y \in S$ such that $\langle{x, y}\rangle \in \mathcal{R}$.

    \item \ttt{Set<Pair<String, String>{>} reflexiveClosure()} returns a set representing the reflexive closure of a binary relation, which is $\mathcal{R} \cup r(\mathcal{R})$, where $r$ returns a reflexive set over $S$.
    
    \item \ttt{Set<Pair<String, String>{>} isSymmetricClosure()} returns a set representing the symmetric closure of a binary relation, which is $\mathcal{R} \cup s(\mathcal{R})$, where $r$ returns a symmetric set over $S$.

    \item \ttt{Set<Pair<String, String>{>} transitiveClosure()} returns a set representing the transitive closure of a binary relation, which is $\mathcal{R} \cup t(\mathcal{R})$, where $t$ returns a transitive set over $S$.
\end{enumerate}

As an added optimization, we should cache whether the current relation is one of these properties when prompted. If we do not add a pair to the relation, then it makes little sense to recompute whether or not is, say, reflexive. Implement this as an optimization, however you wish, into the class.

\myexercise{2}{chapter-classes}{This exercise has five parts.}
Repeated string concatenation is a common performance issue in Java. 
As we know, Java \ttt{String} objects are immutable, which means that concatenation creates a new \ttt{String} objects. 
This is fine for small strings, but for larger strings (or concatenation operations performed in a loop), this can be a performance bottleneck. 
Each concatenation requires copying the entire string. 
Java provides the \ttt{StringBuilder} class to alleviate the issue. 
In this exercise, you will design a \ttt{MiniStringBuilder} class that mimics the behavior of \ttt{StringBuilder}. 
You cannot use \ttt{StringBuilder} or the older \ttt{StringBuilder} classes in your implementation.

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{MiniStringBuilder} class, which stores a \ttt{char[]} as an instance variable. The class should also store a variable to keep track of the number of ``logical characters'' that are in-use by the buffer.
    \item Design two constructors for the \ttt{MiniStringBuilder} class: one that receives no arguments and initializes the default capacity of the underlying \ttt{char[]} array to~$20$, and another that receives a \ttt{String}~$s$ and initializes the \ttt{char[]} array to the characters of~$s$. 
    \item Design the \ttt{void append(String s)} method, which appends the given string~$s$ onto the end of the current string stored in the buffer. The given string should not simply be appended onto the end of the buffer, but rather added to the end of the previous string in the buffer. If the buffer runs out of space, reallocate the array to be twice its current size, similar to how we reallocate the array in the \ttt{MiniArrayList} example class.
    \item Design the \ttt{void clear()} method, which resets the \ttt{char[]} array to the default size of~$20$.
    \item Override the \ttt{public String toString()} method, which returns the \ttt{char[]} array as a \ttt{String} object.
\end{enumerate}

\myexercise{2}{chapter-classes}{This exercise has twelve parts.} 
A complex number $c \in \mathbb{C}$ has two components: a real number~$a$ and an imaginary number~$b$. 
Together, these components compose into~$a + bi$. 
In this exercise you will design a class that operates over complex numbers.

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{ComplexNumber} class, whose constructor receives two \ttt{double} values: $a$ and $b$. Store these as instance variables.
    \item Design the empty constructor that initializes $a$ and $b$ to $0$ and $0$ respectively. 
    \item Implement the respective accessor and mutator methods for the real and imaginary components.
    \item Override the \ttt{toString} method to return a string representation of the complex number of the form \ttt{"a + bi"} or \ttt{"a - bi"} when $b$ is either positive or negative. 
    \item Override the \ttt{equals} method to compare two complex numbers. Of course, this entails comparing the real component and the imaginary component.
    \item Override the \ttt{hashCode} method to return a hashcode that encodes the \ttt{a} and \ttt{b} components respectively.
    \item Design the \ttt{double magnitude()} method, which returns the magnitude of \ttt{this} complex number. The magnitude of a complex number is the square root of the sum of its components.
    \item Design the \ttt{double argument()} method, which returns the argument, or angle, of \ttt{this} complex number in radians. The argument of a complex number is computed as $\tan^{-1}{\frac{b}{a}}$.
    \item Design the \ttt{ComplexNumber conjugate()} method, which returns the conjugate of \ttt{this} complex number. The conjugate of a complex number flips the parity of the imaginary component. That is, if we have a complex number $a + bi$, its conjugate is $a - bi$.
    \item Design the \ttt{ComplexNumber add(ComplexNumber c2)} method, which receives a \ttt{ComplexNumber} as an argument and returns a new \ttt{ComplexNumber} representing the sum of \ttt{this} complex number and the given number. The sum of two complex numbers is the sum of the real components and the imaginary components.
    \item Design the \ttt{ComplexNumber sub(ComplexNumber c2)} method, which receives a \ttt{ComplexNumber} as an argument and returns a new \ttt{ComplexNumber} representing the difference of \ttt{this} complex number and the given number. The difference of two complex numbers is the difference of the real components and the imaginary components.
    \item Design the \ttt{ComplexNumber mul(ComplexNumber c2)} method, which receives a \ttt{ComplexNumber} as an argument and returns a new \ttt{ComplexNumber} representing the product of \ttt{this} complex number and the given number. The product of two complex numbers is as follows:
    \[
        (a + bi)(c + di) = (ac - bd) + (ad + bc)i    
    \]
    Hint: use \ttt{add} and \ttt{mul} to your advantage.
\end{enumerate}

\myexercise{1}{chapter-classes}{This exercise has 2 parts.}
\begin{enumerate}[label=(\alph*)]
  \item Design the \ttt{Accumulator} class, which stores an instance variable of type \ttt{Number}. The \ttt{Accumulator} constructor receives a value of type \ttt{T} and stores it as an instance variable.
  \item Design the \ttt{apply} method, which receives a \ttt{Number} and adds it to the instance variable, then returns the instance variable. If \ttt{apply} has only received integers as arguments, then the result should be interpreted as an integer and not a floating-point value. We're recreating a challenge invented by Paul Graham called the ``Accumulator Factory.''

  As an example, consider the following sequence.
  \begin{verbnobox}[\small]
Accumulator acc1 = new Accumulator(1);
acc1.apply(5);
acc1.apply(7);
assertEquals(13, acc1.apply(0));
assertEquals(15.3, acc1.apply(2.3));
  \end{verbnobox}[\small]
\end{enumerate}

\myexercise{1}{chapter-classes}{This exercise has 3 parts.}

The \emph{Kotlin} programming language supports customized \emph{ranges}. That is, we can define an interval using dot notation, e.g., \ttt{1..10}, then query a value over that interval. For instance, \ttt{x in 1..10} returns whether or not \ttt{x} is between \ttt{1} and \ttt{10}, inclusive. This comparison, however, extends beyond primitive datatypes; ranges may operate over classes. For example, we can create a range \ttt{"hi".."howdy"}, which defines the range of strings in between \ttt{"hi"} and \ttt{"howdy"}.

\begin{enumerate}[label=(\alph*)]
    \item Design the generic \ttt{Range} class. It should store, as instance variables, a minimum and a maximum value, both of which are of type \ttt{<T extends Comparable<T>>}, meaning \ttt{T} must be a comparable type.
    \item The \ttt{Range} constructor should receive these two values as parameters and assign them to the instance variables accordingly. 
    \item Design the \ttt{boolean contains(T v)} method that returns whether or not $v$ is between the interval that this range operates over. 
\end{enumerate}

\myexercise{2}{chapter-classes}{Design the generic static method \ttt{T validateInput(String prompt, String errResp, U extends Predicate<T> p)} that receives a prompt, an error response, and an object that implements the \ttt{Predicate} interface to test whether or not the received value, received through standard input, is valid. If the value is invalid according to the predicate, print the error response and re-prompt the user. Otherwise, return the entered value.}

\myexercise{2}{chapter-classes}{This exercise has three parts.} In this exercise, you'll be developing a \ttt{Document} interface along with its implementing classes:
\begin{itemize}
\item \ttt{TextDocument}
\item \ttt{SpreadsheetDocument}
\item \ttt{PresentationDocument}
\end{itemize}

\noindent The \ttt{Document} interface is defined as follows:
\begin{verbnobox}[\small]
interface Document {

  /**
   * Returns the number of pages in this document.
   */
  int numberOfPages();

  /**
   * Returns a string representing that the Document
   * is being printed.
   */
  default String print() {
    return "Printing the document!";
  }
}
\end{verbnobox}

Notice that we have a \ttt{default} method, which is one that an implementing class does \textbf{not} have to implement. It provides ``default'' functionality, should the ``implementee'' not want to implement the method (hence the name!).

\begin{enumerate}[label=(\alph*)]
\item Implement the other three classes with the following specifications:
\begin{itemize}
\item A \ttt{TextDocument} consists of 100 pages. When it is printed, it should return a message \ttt{"Printing text document!"}.
\item A \ttt{SpreadsheetDocument} has 50 pages. When it is printed, it should return a message \ttt{"Printing spreadsheet document!"}.
\item A \ttt{PresentationDocument} contains 20 pages. It utilizes the default implementation of the \ttt{print} method.
\end{itemize}
\item Design the \ttt{PrintingOffice} class, which includes the following static method: \ttt{static OptionalDouble avgPages(List<Document> lodocs)}. This method calculates and returns the average number of pages across the provided list of \ttt{Document} objects. Remember why we use \ttt{Optional}: if there are no \ttt{Document} objects in the list, we would be dividing by zero if we took the average! 
\item Inside the \ttt{PrintingOffice} class, modify it to include the \ttt{static void printDocuments(List<Document> documents)} method, responsible for invoking the \ttt{print} method on each object in the list of \ttt{Document} instances.
\end{enumerate}

\myexercise{2}{chapter-classes}{This exercise has three parts.}
\begin{enumerate}[label=(\alph*)]
  \item Design the \ttt{INumberFormat} interface, which contains one method: \ttt{String format(int n)}. 
  \item Design the \ttt{DollarFormat} method, which implements \ttt{INumberFormat}, and returns a string where the number is prepended with a dollar sign \ttt{"\$"}.
  \item Design the \ttt{CommaFormat} method, which implements \ttt{INumberFormat}, and returns a string where the number contains commas where appropriate. For example, \ttt{format(4412)} should return \ttt{"4,412"}.
\end{enumerate}

\myexercise{3}{chapter-classes}{In the chapter, we described the \ttt{PizzaOrder} class. This exercise introduces readers to the visitor design pattern, which we explore in greater detail in~\Cref{chapter-modern}.}
\begin{enumerate}[label=(\alph*)]
  \item First, design the \ttt{GroupOrder} class, which keeps track of multiple pizzas in an order. Store a \ttt{Queue<PizzaOrder>} as an instance variable and instantiate it to a \ttt{PriorityQueue}. The \ttt{GroupObject} constructor should receive a \ttt{Comparator<PizzaOrder}. Pass this to the \ttt{PriorityQueue} instantiation.
  \item Design the \ttt{ITopping} interface, which represents a topping. For now, it contains no methods. Then, design four classes: \ttt{Pepperoni}, \ttt{Onion}, \ttt{Pineapple}, and \ttt{Anchovie}, all of which implement \ttt{ITopping}.
  \item Now, let's design a class that allows us to do multiple actions with toppings. Design the generic \ttt{IToppingVisitor} class, which has four methods: \ttt{T visit(Pepperoni p)}, \ttt{T visit(Onion o)}, \ttt{T visit(Pineapple p)}, and \ttt{T visit(Anchovie a)}.
  \item Design the \ttt{ToppingPriceVisitor} class, which implements the interface \ttt{IToppingVisitor}, whose type parameter is a \ttt{Double}. The idea is that the \ttt{ToppingPriceVisitor} class serves as a way of associating a property with toppings without having to modify/amend the class definitions. Override the four methods to return \ttt{3.50}, \ttt{2.50}, \ttt{5.75}, and \ttt{4.00} respectively.
  \item Modify the \ttt{PizzaOrder} class to have its map instance variable associate \ttt{ITopping} objects to \ttt{Integer}, rather than \ttt{String} to \ttt{Integer}.
  \item Amend the \ttt{ITopping} interface to now supply the \ttt{<T> T visit(IToppingVisitor<T> v)} method. Its subtypes should override \ttt{visit} by defining it as a call to \ttt{v.visit(this)}, where \ttt{v} is the visitor object parameter.
  \item Finally, design the \ttt{PizzaOrderPriceComparator} class, which implements \ttt{Comparator<PizzaOrder>}, and compares pizzas based on the price of its toppings. Pizzas with a higher cost are prioritized over pizzas with a lower cost.
\end{enumerate}

\myexercise{3}{chapter-classes}{A \emph{lazy list} is one that, in theory, produces infinite results! Consider the \ttt{ILazyList} interface below:}
\begin{lstlisting}[language=MyJava]
interface ILazyList<T> {
  T next();
}
\end{lstlisting}

When calling \ttt{next} on a lazy list, we update the contents of the lazy list and return the next result. We mark this as a generic interface to allow for any desired return type. For instance, below is a lazy list that produces factorial values:\footnote{We will ignore the intricacies that come with Java's implementation of the \ttt{int} datatype. To make this truly infinite (up to the system's memory limit), we could use \ttt{BigInteger}.}
\begin{lstlisting}[language=MyJava]
class FactorialLazyList implements ILazyList<Integer> {

  private int n;
  private int fact;
 
  FactorialLazyList() {
    this.n = 1;
    this.fact = 1;
  }

  @Override
  public Integer next() {
    this.fact *= this.n;
    this.n++;
    return this.fact;
  }
}
\end{lstlisting}

Testing it with ten calls to \ttt{next} yields predictable results.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class FactorialLazyListTester {

  @Test
  void testFactorialLazyList() {
    ILazyList<Integer> FS = new FactorialLazyList();
    assertAll(
      () -> assertEquals(1, FS.next()),
      () -> assertEquals(2, FS.next()),
      () -> assertEquals(6, FS.next()),
      () -> assertEquals(24, FS.next()),
      () -> assertEquals(120, FS.next()),
      () -> assertEquals(720, FS.next()),
      () -> assertEquals(5040, FS.next()),
      () -> assertEquals(40320, FS.next()),
      () -> assertEquals(362880, FS.next()),
      () -> assertEquals(3628800, FS.next()));
  }
}
\end{lstlisting}

Design the \ttt{FibonacciLazyList} class, which implements \ttt{ILazyList<Integer>} and correctly overrides \ttt{next} to produce Fibonacci sequence values. You code should \emph{not} use any loops or recursion. Recall that the Fibonacci sequence is defined as $f(n) = f(n - 1) + f(n - 2)$ for all $n\geq{2}$. The base cases are $f(0) = 0$ and $f(1) = 1$.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class FibonacciLazyListTester {

  @Test
  void testFibonacciLazyList() {
    ILazyList<Integer> FS = new FibonacciLazyList();
    assertAll(
      () -> assertEquals(0, FS.next()),
      () -> assertEquals(1, FS.next()),
      () -> assertEquals(1, FS.next()),
      () -> assertEquals(2, FS.next()),
      () -> assertEquals(3, FS.next()),
      () -> assertEquals(5, FS.next()),
      () -> assertEquals(8, FS.next()),
      () -> assertEquals(13, FS.next()),
      () -> assertEquals(21, FS.next()),
      () -> assertEquals(34, FS.next()));
  }
}
\end{lstlisting}

\myexercise{2}{chapter-classes}{Design the \ttt{LazyListTake} class. Its constructor should receive an \ttt{ILazyList} and an integer~$n$ denoting how many elements to take, as parameters. Then, write a \ttt{List<T> getList()} method, which returns a \ttt{List<T>} of~$n$ elements from the given lazy list.}


\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class LazyListTakeTester {

 @Test
 void testLazyListTake() {
  LazyListTake llt1 = new LazyListTake(new FactorialLazyList(), 8);
  LazyListTake llt2 = new LazyListTake(new FibonacciLazyList(), 10);

  assertAll(
    () -> assertEquals("[1, 2, 6, 24, 120, 720, 5040, 40320]",
                       llt1.getList().toString()),
    () -> assertEquals("[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]",
                       llt2.getList().toString()));
 }
}
\end{lstlisting}

\myexercise{2}{chapter-classes}{Java's functional API allows us to pass lambda expressions as arguments to other methods, as well as method references (as we saw in Chapter~\ref{chapter-arrays-collections}). Design the generic \ttt{FunctionalLazyList} class to implement \ttt{ILazyList}, whose constructor receives a unary function \ttt{Function<T, T> f} and an initial value \ttt{T t}. Then, override the \ttt{next} method to invoke $f$ on the current element of the lazy list and return the previous. For example, the following test case shows the expected results when creating a lazy list of infinite positive multiples of three.}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;
import static Assertions.assertAll;

class FunctionalLazyListTester {

  @Test
  void testMultiplesOfThreeLazyList() {
    ILazyList<Integer> mtll = new FunctionalLazyList<>(x -> x + 3, 0);
    assertAll(
      () -> assertEquals(0, mtll.next()),
      () -> assertEquals(3, mtll.next()),
      () -> assertEquals(6, mtll.next()),
      () -> assertEquals(9, mtll.next()),
      () -> assertEquals(12, mtll.next()));
  }
}
\end{lstlisting}

What's awesome about this exercise is that it allows us to define the elements of the lazy list as any arbitrary lambda expression, meaning that we could redefine \ttt{FactorialLazyList} and \ttt{FibonacciLazyList} in terms of \ttt{FunctionLazyList}. We can generate infinitely many ones, squares, triples, or whatever else we desire.

\myexercise{2}{chapter-classes}{Design the generic \ttt{CyclicLazyList} class, which implements \ttt{ILazyList}, whose constructor is variadic and receives any number of values. Upon calling \ttt{next}, the cyclic lazy list should return the first item received from the constructor, then the second, and so forth until reaching the end. After returning all the values, cycle back to the front and continue. For instance, if we invoke \ttt{new CyclicLazyList<Integer>(1, 2, 3)}, invoking \ttt{.next} five times will produce \ttt{1}, \ttt{2}, \ttt{3}, \ttt{1}, \ttt{2}.}

\myexercise{1}{chapter-classes}{Design the \ttt{static <T> Predicate<T> orEquals(Predicate<T> pred, T x)} method that, when given a predicate $p$ and an object $x$, returns a \emph{new} predicate that returns true if its argument $x'$ is equal (using \ttt{equals}) to $x$ or satisfies $p(x)$.}

\myexercise{2}{chapter-classes}{Design the \ttt{static <T> List<T> predicateOrEquals(List<T> ls, Predicate<T> pred, BiFunction<T, T, Boolean>, T x)} method that, when given a list of values $ls$, a predicate $p$, a function $f$, and a value $x$ that returns the list of values in $ls$ that either satisfy $p$ or are equal according to $f$. For the purposes of this question, $f$ is a method of two arguments of type $T$ that determines whether or not they are ``equal'' according to some criteria.}

\myexercise{1}{chapter-classes}{Design the \ttt{static <T> boolean andMap(List<T> ls, Predicate<T> pred)} method that returns whether or not all elements of the input list satisfy the given predicate. Use the stream API to solve this problem, but do \emph{not} use the \ttt{allMatch} method, as that method solves the problem we want \emph{you} to solve!}

\myexercise{2}{chapter-classes}{Design the \ttt{static <T, U> U foldr(List<T> ls, BiFunction<T, U, U> f, U u)} method that receives a list of values $ls$, a function $f$, and an initial value $u$. The method should return the result of folding the list from the right with the given function and initial value. By ``folding,'' we mean that we apply $f$ to the last element of the list and the initial value, then apply $f$ to the second-to-last element and the result of the previous application, and so forth. To think of this in terms of infix notation over some list, consider the list $[a, b, c, d]$. Folding it over the function $\circ$ and initial value $u$ is $a \circ (b \circ (c \circ (d \circ u)))$. Do \emph{not} use the \ttt{reduce} method, as that method solves the problem we want \emph{you} to solve!}

\myexercise{1}{chapter-classes}{Design the \ttt{static <T, U> List<U> buildList(int n, Function<T, U> f)} method that receives an integer $n$ and a function $f$ and returns a list of $n$ elements, where the $i^\text{th}$ element is $f(i)$. For example, if we invoke \ttt{buildList(5, x -> x * x)}, we should receive the list $[1, 4, 9, 16, 25]$.}

\myexercise{1}{chapter-classes}{This exercise involves the doubly-linked list we wrote in the chapter.}
Design the \ttt{int size()} method, which returns the number of elements in the list. You can do this either recursively or with a loop. For better practice, try (and thoroughly test) both implementations.

\myexercise{2}{chapter-classes}{This exercise involves the doubly-linked list we wrote in the chapter.}
Design the \ttt{void set(int i, T v)} method, which overwrites/assigns, at index $i$, the value $v$. If the provided index is out-of-bounds, do nothing.

\myexercise{2}{chapter-classes}{This exercise involves the doubly-linked list we wrote in the chapter.}
Design the \ttt{void insert(int i, T v)} method, which inserts the value $v$ at index $i$. As an example, if we insert $4$ into the list $[20, 5, 100, 25]$ at index $2$, the list then becomes $[20, 5, 4, 100, 25]$. If the provided index is out-of-bounds, do nothing.

\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Our interpreter, so far, is very memory inefficient. The reason is not apparent at first glance, but consider every time that we create a \ttt{NumberNode} or, especially, a \ttt{BooleanNode}. There are only two possibilities for a \ttt{BooleanNode}: true and false, which are immutable by design. So, the interpreter should never waste time allocating an instance thereof when it can simply reference an existing one. Such an optimization follows the ``factory'' design pattern, which we will explore in Chapter~\ref{chapter-modern}.

Privatize the \ttt{BooleanNode} constructor, then design the \ttt{static BooleanNode of(boolean b)} method. It receives a boolean value $v$ and returns a reference to a pre-allocated static true or false node. Similarly, also privatize the \ttt{NumberNode} constructor and design the \ttt{static NumberNode of(double v)} method. This method returns a new \ttt{NumberNode} if the given value $v$ is not an integer between $[0, 1000)$. Otherwise, precache those integer values and store them in a private lookup table.

\myexercise{1}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Add the \ttt{"read-number"} and \ttt{"print"} primitive operations to the language. The latter is polymorphic, meaning it can print both numbers and booleans.

\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Functional programming languages, in general, are a composition of expressions, wherein statements are more of an afterthought. To this end, design the \ttt{BeginNode} abstract syntax tree node, which receives a list of abstract syntax trees. At the interpreter level, the \ttt{BeginNode} should evaluate each of the abstract syntax trees in the list, and return the result of the last one.

\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Variables, in our language, are defined and bound exactly once, namely when they are defined within a let node. Though, in imperative programming, it is often crucial to allow variable reassignments. Design the \ttt{SetNode} class, which receives a variable and an abstract syntax tree, and reassigns the variable to the result of the abstract syntax tree. At the interpreter level, the \ttt{SetNode} should evaluate the abstract syntax tree, and reassign the variable to the result in the current environment (and only the current environment). This means that you'll need to modify the \ttt{Environment} class to allow for variable reassignments. Hint: create a \ttt{set} method in the \ttt{Environment} class.

\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.} Recursion is nice and intuitive, for the most part. Unfortunately, it is not always the most efficient way to solve a problem. For example, the Fibonacci sequence, as we saw in Chapter~\ref{chapter-crl}, is often defined recursively, but it is much more efficient to define it iteratively (or even with tail recursion). Design the \ttt{WhileNode} class, which receives a condition and an abstract syntax tree, and evaluates the abstract syntax tree until the condition is false. At the interpreter level, the \ttt{WhileNode} should evaluate the condition, and if it is true, evaluate the abstract syntax tree, and repeat until the condition is false. To test your implementation, you will need to combine the \ttt{WhileNode} with both the \ttt{SetNode} and \ttt{BeginNode} classes.

\myexercise{3}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.} Having to manually update our case analysis on the primitive operator type is cumbersome and prone to mistakes. A better solution would be to store the operator and its corresponding ``handler'' method, i.e., the method that receives the operands and does the logic of the operator. We can do this via a map where the keys are the string operators and the values are functional references to the handlers. Unfortunately, Java does not directly support passing methods as parameters, meaning they are not first-class. Conversely, we can make use of Java's functional interfaces to achieve our goal. Namely, the interface will contain one method: \ttt{AstNode apply(List<AstNode> args, Environment env)}, where \ttt{args} is the list of evaluated arguments. We will call the interface \ttt{IFunction} and make it generic, with the first type quantified to a list of \ttt{AstNode} instances, and the second type quantified to \ttt{AstNode}. Hopefully, the connection between these quantified types and the signature of \ttt{apply} is apparent. Using the below definition of \ttt{IFunction}, update \ttt{PrimNode} to no longer perform a case analysis in favor of the map. We provide an example of populating the map with the initial operators in a \ttt{static} block.

\begin{lstlisting}[language=MyJava]
@FunctionalInterface
interface IFunction<T, R> {
  
  R apply(T t);
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.Map;
import java.util.HashMap;

class PrimNode extends AstNode {
  
  private static final Map<String, IFunction<List<AstNode>, AstNode>> OPS;
  
  static {
    OPS = new HashMap<>();
    OPS.put("+", this.primPlus);
  }

  @Override
  AstNode eval(Environment env) { /* TODO. */  }

  private AstNode primPlus(List<AstNode> args, Environment env) { 
    /* Details omitted. */ 
  }
}
\end{lstlisting}

\myexercise{3}{chapter-classes}{This exercise is multi-part and involves the interpreter we wrote in the chapter.}
\begin{enumerate}[label=(\alph*)]
  \item First, design the \ttt{ProgramNode} class, which allows the user to define a program as a sequence of statements rather than a single expression.
  \item Design the \ttt{DefNode} class, which allows the user to create a global definition. Because we're now working with definitions that do not extend the environment, we should use the set method in environment. When creating a global definition via \ttt{DefNode}, we're expressing the idea that, from that point forward, the (root) environment should contain a binding from the identifier to whatever value it binds.
  \item Design the \ttt{FuncNode} node. We will consider a function definition as an abstract tree node that begins with \ttt{FuncNode}. This node has two parameters to its constructor: a list of parameter (string) identifiers, and a single abstract syntax tree node representing the body of the function. We will only consider functions that return values; void functions do not exist in this language.
  \item Design the \ttt{ApplyNode} class, which applies a function to its arguments. You do not need to consider applications in which the first argument is a non-function. 

  Calling/Invoking a function is perhaps the hardest part of this exercise. Here's the idea, which is synonymous and shared with almost all programming languages: 

  \begin{enumerate}[label=(\roman*)] 
  \item First, evaluate each argument of the function call. This will result in several evaluated abstract syntax trees, which should be stored in a list. 
  \item We then want to create an environment in which the formal parameters are bound to their arguments. Overload the extend method in \ttt{Environment} to now receive a list of string identifiers and a list of (evaluated) AST arguments. Bind each formal to its corresponding AST, and return the extended environment. 
  \item Evaluate the function abstract syntax tree to get its function definition as an abstract syntax tree.
  \item Call \ttt{eval} on the function body and pass the new (extended) environment.
  \end{enumerate}
  This seems like a lot of work (because it is), but it means you can write really cool programs, including those that use recursion!
  %\enlargethispage{2\baselineskip}
  \begin{verbnobox}[\small]
new ProgramNode(
  new DefNode("!", 
    new FuncNode(
      List.of("n"),
      new IfNode(
        new PrimNode("eq?", 
          new VarNode("n"), 
          new NumNode(0)),
        new NumNode(1),
        new PrimNode("*", 
          new VarNode("n"), 
          new ApplyNode("!", 
            new PrimNode("-", 
            new VarNode("n"), 
            new NumNode(1))))))),
  new ApplyNode("!", new NumNode(5)))
\end{verbnobox}
\end{enumerate}

\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter, and relies on the addition of \ttt{FuncNode} and \ttt{ApplyNode}.}
Our current version of the interpreter uses \textit{dynamic scoping}. A dynamically-scoped interpreter is one that uses the value of the closest declaration of a variable. This seems like nonsense without an example, so consider the following code listing.
\begin{lstlisting}[language=MyScheme, frame=single]
(define f
  (let ([x 10])
    ((*;$\lambda$;*) ()
      x)))

(let ([x 3])
  (f))
\end{lstlisting}

Under dynamic scoping, this program outputs \ttt{3}, because the binding of \ttt{x} takes on the value \ttt{3}. On the other hand, if we were using a \textit{lexically-scoped} interpreter, the program would output \ttt{10}, which seems to make more sense due to the binding that exists immediately above the function declaration. The question is: how do we implement lexical scoping into our interpreter? The answer is via \textit{closures}, which are data structures that couple a function definition with an environment. Then, when we apply a closure to an argument (if it exists), we restore the environment that was captured by the closure. 

To this end, design the \ttt{ClosureNode} class, whose constructor receives a \ttt{FuncNode} and an \ttt{Environment}. The respective \ttt{eval} method returns \ttt{this}, but \ttt{FuncNode} changes slightly. Rather than returning \ttt{this}, we return a \ttt{ClosureNode}, which wraps the current \ttt{FuncNode} and the environment passed to \ttt{eval}. Finally, inside \ttt{ApplyNode}, evaluating the function definition should resolve to a closure. Evaluate the arguments to the closure inside the passed environment, but \textit{extend} the captured environment, and bind the formals to the arguments in this extended environment. The body of the closure's function definition is then evaluated inside this new environment. 

Making this alteration not only causes our programs to output the ``common sense'' result, but also means we can implement recursive functions using \textit{only} a \ttt{LetNode}. See if you can figure out how to do this!

\myexercise{3}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Data structures are a core and fundamental feature of programming languages. A language without them, or at least one to build others on top of, suffers severely in terms of usability. We will implement a \emph{cons}-like data structure for our interpreter. In functional programming, we often use three operations to act on data structures akin to linked lists: \emph{cons}, \emph{first}, and \emph{rest}, to construct a new list, retrieve the first element, and retrieve the rest of the list respectively. We can inductively define a cons list as follows:

\begin{verbnobox}[\small]
A ConsList is one of:
 - new ConsList()
 - new ConsList(x, ConsList)
\end{verbnobox}

Implement the cons data structure into your interpreter. This should involve designing the \ttt{ConsNode} class that conforms to the aforementioned data definition. Moreover, you will need to update \ttt{PrimNode} to account for the \ttt{first} and \ttt{rest} primitive operations, as well as an \ttt{empty?} predicate, which returns whether or not the cons list is empty. Finally, override \ttt{toString} inside \ttt{ConsNode}, which amounts to printing each element, separated by spaces, inside of brackets, e.g., \ttt{[$l_0, l_1, \ldots, l_{n-1}]$}.

\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Having to manually type out the abstract syntax tree constructors when writing tests is extremely tedious. Design a \emph{lexer} for the language described by the interpreter. That is, the text is broken up into tokens that are then categorized. For example, \ttt{'('} might become \ttt{OPEN\_PAREN}, \ttt{"lambda"} might become \ttt{SYMBOL}, \ttt{"variable-name"} might become \ttt{SYMBOL}, and \ttt{123.45} might become \ttt{NUMBER}. The output of the lexer is a list of tokens. Part of the trick is to ensure that after reading an open parenthesis, the next token is not grabbed as part of the open parenthesis.

\myexercise{3}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
Design a parser for the language described by the interpreter. The idea is to tokenize a raw string, then parse the tokens to create an abstract syntax tree that represents the program. A good starting point would be to parse \emph{all} parenthesized expressions into what we will call \ttt{SExprNode}, then traverse over the tree to ``correct'' them into their true nodes, e.g., whether they are \ttt{IfNode}, \ttt{LetNode}, and so forth. Realistically, all programs in our language are, at their core, either primitive values or s-expressions.

\myexercise{2}{chapter-classes}{This exercise involves the interpreter we wrote in the chapter.}
The Scheme programming language and its derivatives support \emph{code quotation}, i.e., the ability to convert an evaluable expression into data. As an example, if we evaluate \ttt{new QuoteNode(new VarNode("x"))}, we receive a symbol as the output, rather than the evaluated symbol via environment lookup. Add the \ttt{QuoteNode} class to your interpreter.

\myexercise{3}{chapter-classes}{In Chapter~\ref{chapter-crl}, we discussed tail recursion and an action performed by some programming languages known as tail-call optimization. We know that we can convert any (tail) recursive algorithm into one that uses a loop, and we described said process in the chapter. There is yet another approach that we can mimic in Java with a bit of trickery and interfaces.}

The problem with tail recursion (and recursion in general) in Java is the fact that it does not convert tail calls into iteration, which means the stack quickly overflows with activation records. We can make use of a \emph{trampoline} to force the recursion into iteration through \emph{thunks}. In essence, we have a tail recursive method that returns either a value or makes a tail recursive call, such as the factorial example below.\footnote{We omit the driver method to shorten the code, as the important part lies inside the recursive implementation.} Inside our base case, we invoke the \ttt{done} method with the accumulator value. Otherwise, we invoke the \ttt{call} method containing a lambda expression of no arguments, whose right-hand side is a recursive call to \ttt{factTR}. Functions, or lambda expressions, that receive no arguments are called thunks.


\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class FactorialTailRecursiveTester {
  
  @Test 
  void testFactTailRecursiveTrampoline() {
    assertAll(
      () -> assertEquals(BigInteger.valueOf(1), 
                         factTailCall(BigInteger.valueOf(0), BigInteger.ONE)),
      () -> assertEquals(BigInteger.valueOf(120), 
                         factTailCall(BigInteger.valueOf(5), BigInteger.ONE)),
      () -> assertDoesNotThrow(StackOverflowException.class,
                               () -> factTailCall(BigInteger.valueOf(50000), 
                                                  BigInteger.ONE)),
    )
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.lang.BigInteger;

class FactorialTailRecursive {
 
  /**
   * Tail-recursive factorial function. Uses BigInteger to 
   * avoid number overflow and thunks to avoid stack overflow.
   * @param n - the number to compute the factorial of.
   * @param ac - the accumulator.
   * @return a tail call that is either done or not done.
   */
  static ITailCall<BigInteger> factTailCall(BigInteger n, BigInteger ac) {
    if (n.equals(BigInteger.ZERO)) {
      return TailCallUtils.done(ac);
    } else {
      return TailCallUtils.call(() -> 
               factTailCall(n.subtract(BigInteger.ONE), ac.multiply(n)));
    }
  }
}
\end{lstlisting}

The idea is that we have a helper class and method, namely \ttt{invoke}, that continuously applies the thunks, \textbf{inside a while loop}, until the computation is done. The trampoline analogy is used because we bounce on the trampoline while invoking thunks and jump off when we are ``done.''

First, design the generic \ttt{ITailCall<T>} interface. It should contain only one (non-default) method: \ttt{ITailCall<T> apply()}, which is necessary for the \ttt{invoke} method. The remaining methods are all default, meaning they must have a body. Design the \ttt{boolean isDone()} method to always return false. Design the \ttt{T getValue()} method to simply return \ttt{null}. Finally, design the \ttt{T invoke()} method that stores a local variable and constantly calls \ttt{apply} on itself until it is ``done.'' 

Second, design the \ttt{TailCallUtils} final class to contain a private constructor (this class will only utilize and define two static methods). The two methods are as follows:

\begin{itemize}
  \item \ttt{static <T> ITailCall<T> call(ITailCall next)}, which receives and returns the next tail call to apply. This definition should be exactly one line long and as simple as it seems.
  \item \ttt{static <T> ITailCall<T> done(T val)}, which receives the value to return from the trampoline. We need to create an instance of an interface, which sounds bizarre, but is possible only when we provide an implementation of its methods. So, return a \ttt{new ITailCall<>()}, and inside its body, override the \ttt{isDone} and \ttt{getValue} methods with the correct bodies.
\end{itemize}

Finally, run the factorial test that we provided earlier in its JUnit suite. It should pass and not stack overflow, hence the inclusion of an \ttt{assertDoesNotThrow} call.

\myexercise{3}{chapter-classes}{Recall the unification exercise from Chapter~\ref{chapter-arrays-collections}. We can take the idea of unification a step further, which is the basis for almost all logic programming languages such as Prolog. For instance, take the expression \ttt{p(X, f(Y))}; attempting to unify this with \ttt{p(q(r(x)), f(b(x)))} returns a unification assignment of \ttt{X : q(r(x)), Y : b(x)}. It is possible for a unification to not return any possible assignment. As an example, unifying \ttt{p(a, b)} with \ttt{p(Y, Y)} returns an empty assignment because it is not possible to unify \ttt{a} with \ttt{Y}, then unify \ttt{b} with \ttt{Y}.}

Design three classes: \ttt{Variable}, \ttt{Constant}, and \ttt{Predicate}. Each of these should implement the \ttt{IUnifiable} interface, which supplies one method: \ttt{Assignment unify(IUnifiable u, Assignment as)}. An \ttt{Assignment} is simply a mapping of \ttt{IUnifiable} objects to \ttt{IUnifiable} objects, resembling a map data structure. Variables in this small language will be represented as uppercased letters, whereas constants are lowercase. If two \ttt{IUnifiable} objects cannot be unified, then \ttt{unify} should return \ttt{null}.

Constants are straightforward: constants can only be unified with other constants if they are equivalent. Constants can only be unified with variables if that variable does not have an existing assignment and, if it does, it must be equal to \ttt{this} constant. Constants cannot be unified with predicates.

Variables can only be unified with constants if the variable does not have an existing assignment and, if it does, it must be equal to the constant passed as an argument. Variables can only be unified with other variables if at least one is bound to a constant; if they are both bound, then they must be equivalent constants. 

Predicates can only be unified with variables if the variable does not have an existing assignment and, if it does, it must be equal to \ttt{this} predicate. Predicates can only be unified with predicates if it is possible to successfully unify all of its arguments. E.g., \ttt{p(a, z(b), c)} unifies with \ttt{p(X, z(Y), Z)} because we return the assignment \ttt{X : a, Y : b, Z : c}. 

\myexercise{3}{chapter-classes}{In this series of problems, you will design several methods that act on very large \emph{natural numbers} resembling the \ttt{BigInteger} class. You \emph{\textbf{cannot}} use any methods from \ttt{BigInteger}, or the \ttt{BigInteger} class itself.} 

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{BigNat} class, which has a constructor that receives a string. The \ttt{BigNat} class stores a \ttt{List<Integer>} as an instance variable. You will need to convert the given string into said list. Store the digits in reverse order, i.e., the least-significant digit (the ones digit) of the number is the first element of the list.
    \item Override the \ttt{public String toString()} method to return a string representation of the \ttt{BigNat} object. 
    % In particular, place commas between the digits where necessary, e.g., \ttt{"1,000"} and \ttt{"12,345,678"}.
    \item Design the \ttt{BigNat clone()} method that returns a new \ttt{BigNat} instance that contains the same number.
    \item Override the \ttt{public boolean equals(Object obj)} method to compare two \ttt{BigNat} values for equality. Remember that you have to cast the given parameter to an instance of the \ttt{BigNat} class. 
    \item Implement the \ttt{Comparable<BigNat>} interface, and override the \ttt{public int compareTo(BigNat b)} method to return the sign of the result of comparing the given \ttt{BigNat} (which we will call $b$) to \ttt{this} \ttt{BigNat} (which we will call $a$). Namely, if $a < b$, return $-1$, if $a > b$, return $1$, otherwise return $0$.
    \item Design the \ttt{void add(BigNat bn)} method, which adds a \ttt{BigNat} to \ttt{this} \ttt{BigNat}. The method should not return anything. Note: this problem is harder than it may look at first glance!
    \item Design the \ttt{void sub(BigNat bn)} method, which subtracts a \ttt{BigNat} from \ttt{this} \ttt{BigNat}. If the subtrahend (the right-hand side of the subtraction) is greater than the minuend, the result is zero. Over the natural numbers, this is called the \emph{monus} operator.
    \item Design the \ttt{void mul(BigNat bn)} method, which multiplies a \ttt{BigNat} with \ttt{this} \ttt{BigNat}. Note: remember how we implement multiplication recursively? You shouldn't use recursion for this problem, but what \emph{is} multiplication? Think about the performance implications of this approach.
    \item Design the \ttt{void div(BigNat bn)} method, which divides a \ttt{BigNat} with \ttt{this} \ttt{BigNat}. If the divisor is greater than the dividend, assign the dividend to be zero. If the divisor is zero, do nothing at all. Otherwise, perform integer division. Note: we can implement division recursively. You shouldn't use recursion for this problem, but what \emph{is} division? Think about the performance implications of this approach.
\end{enumerate}

\myexercise{3}{chapter-classes}{Quine's method of truth resolution~\cite{methodsoflogic} is a method of automatically reasoning about the truth of a propositional logic statement (recall the exercise from Chapter~\ref{chapter-crl}). The method is as follows:}

\begin{enumerate}
    \item Choose an atom $P$ from the statement. Consider two cases: when $P$ is true and when $P$ is false. Derive the consequences of each case. The rules follow those of the propositional logic connectives.
    \item Repeat this process for each sub-statement until there are no more sub-statements, and you have only true or false results. If you have \emph{both} true and false results, the statement is a contingency. If all branches lead to true, the statement is a tautology. If all branches lead to false, the statement is a contradiction. 
\end{enumerate}

Design several classes to represent a series of well-formed schemata in propositional logic, namely \ttt{CondNode}, \ttt{BicondNode}, \ttt{NegNode}, \ttt{AndNode}, \ttt{OrNode}, and \ttt{AtomNode}, all of which extend a root \ttt{Node} class, similar to our representation of the abstract syntax trees within the ASPL interpreter. Then, design three methods: \ttt{boolean isTautology(Node t)}, \ttt{boolean isContingency(Node t)}, and \ttt{boolean isContradiction(Node t)}, which return whether or not the given statement is a tautology, contingency, or contradiction, respectively. You may assume that the input is a well-formed schema. Note that only one of these methods needs a full-fledged recursive traversal over the data; the other two can be implemented in terms of the first.