\section{Classes}
\label{chapter-classes-classes}

From the first page, we have made prolific use of classes, but in this chapter, we finally venture into the inner workings of a class, and how to create our own.

\emph{Classes}\index{classes}\index{class} are blueprints for \emph{objects}\index{object}. 
When we create a class, we declare a new type of object. 
Classes encapsulate data and method definitions for later use.

As we stated, we have repeatedly used classes \emph{and} objects, e.g., strings, arrays, \ttt{Scanner}, \ttt{Random}, as well as classes from the Collections framework. 
Until now, however, we viewed these as forms of abstraction, whose details were not important. 

To create a class, we use the \ttt{class} keyword, followed by the name of the class. 
The name of the class should be capitalized and, in general, describe a noun. 
All Java files describe a class and must be named accordingly. 
We previously omitted the details of class creation and merely used them as a means to design methods.

Classes can \emph{inherit} methods from other classes, a relationship called the superclass/subclass hierarchy. 
For now, we will only mention that the \ttt{Object} class is the ``ultimate'' superclass, in which all classes are implicit subclasses. 
The \ttt{Object} class, in particular, has three methods that we will override in almost every class that we design: \ttt{equals}, for comparing two classes for equality, \ttt{toString}, a means of ``stringifying'' an object, and a third: \ttt{hashCode}, the significance of which we will return to soon. 
In subsequent sections, we dive more into inheritance and hierarchies.

\myexample{Let's design the \ttt{Point} class, which stores two \ttt{int} values representing two Cartesian coordinates~$x$ and~$y$.} 
By ``store,'' we mean to say that~$x$ and~$y$ are \emph{instance variables}\index{instance variables} of the \ttt{Point} class, also sometimes called \emph{attributes}, \emph{fields}, or \emph{members} (in Java, we conventionally use the ``instance variables'' term). 
Instance variables denote the values associated with an arbitrary \emph{instance} of that object (an instance may also be defined as an entity). 
For example, if we declare a \ttt{Point} object \ttt{p}, then \ttt{p} has two instance variables, \ttt{x} and \ttt{y}, which are the~$x$ and~$y$ coordinates of \ttt{p}.
If we declare another \ttt{Point} object \ttt{p2}, then \ttt{p2} has its own instance variables \ttt{x} and \ttt{y}, which are independent of \ttt{p}'s instance variables. 
In almost all circumstances, instance variables of a class should be marked as \ttt{private}. 
Instance variables that are \ttt{private} are accessible only to those methods within the class definition. 
For the time being, instance variables are immutable. 
Thus, every instance variable will use the \ttt{final} keyword in its declaration, alongside the \ttt{UPPER\_CASE} naming convention.

Speaking of \emph{access modifiers}\index{access modifier}, we should mention the four that Java provides, even though we make prolific use of only three:

\begin{itemize}
  \item A class, variable, or method declared with the \ttt{public} modifier is accessible to/by any other class. Variables that are \ttt{public} should be used sparingly.
  \item A class, variable, or method declared with the \ttt{private} modifier is accessible only to/by the class in which it is declared. 
  \item A class, variable, or method declared without an access modifier, also called the \emph{default access modifier}, behaves similarly to \ttt{public}, only that it is accessible only to/by classes in the same package. Packages are a means of organizing classes into groups, similar to directories.
\end{itemize}

The fourth and final access modifier is \ttt{protected}, which is similar to the default access modifier, but allows subclasses to access the variable or method.\footnote{If you have not heard of inheritance/subclasses yet, do not worry, as we will cover this in the next chapter; we explain it here to describe the relevant difference between the access modifiers.} 
We will not use \ttt{protected} in this text, but it is worth mentioning. 
As a corollary of sorts, any time that \ttt{protected} \emph{can} be used, there is almost certainly a better design alternative, whether that means marking the variable/method as \ttt{private} or \ttt{public}, we are of the opinion that \ttt{protected} has few benefits. 
Moreover, because we will not use \ttt{protected}, the use of \ttt{public} will be infrequent and only when necessary.\footnote{Some methods, as we will soon see and have seen previously, are required to be \ttt{public}. For example, the \ttt{main} method must be marked as \ttt{public}.}

\begin{lstlisting}[language=MyJava]
class Point {

  private final int X;
  private final int Y;
}
\end{lstlisting}

We now want a way to create an instance of a \ttt{Point}. 
Instances of objects are made using the \ttt{new} keyword, followed by the class constructor. 
\emph{Constructors}\index{constructor} are special methods that instantiate an instance of a class. 
Our \ttt{Point} class constructor receive parameters that we will use to initialize the relevant~$x$ and~$y$ instance variables. 
So, let's design the constructor for our \ttt{Point} class. 
Constructors, in general, should be \ttt{non-private}, as we need to call them from outside the class definition. 
On a case-by-case basis, this changes accordingly, as some classes are local to another class definition, and are thereby private.\footnote{There are also design patterns, as exemplified in Chapter~\ref{chapter-modern}, that rely on a class constructor being private to prohibit unnecessary object instantiation.} 

Constructors are also special in that they do not have an explicit return type, but they are non-void in that they return an object of the class type.

All classes in Java that can be instantiated have a \emph{default constructor} only when no constructor is specified by the class implementer.\footnote{Later in this chapter, we will see that some classes and types cannot be instantiated.} 
The default constructor of a class receives no arguments and serves only to be able to create an instance of the class.

\begin{lstlisting}[language=MyJava]
class Point {
  
  private final int X;
  private final int Y;
  
  Point(int x, int y) {
    this.X = x;
    this.Y = y;
  }
}
\end{lstlisting}

Remember that the purpose of the \ttt{Point} constructor is to initialize the class instance variables. 
So, unless we want to use distinct identifiers for referencing the parameters and instance variables, we need to use the \ttt{this} keyword.\footnote{Some software engineers and projects use identifier prefixes to refer to instance variables.} 
The \ttt{this} keyword refers to the current object, and aids in distinguishing between instance variables and parameters. 
The ``current object'' references the object that a method is called on. 

Inside the constructor, we assign the value of the parameter \ttt{x} to the instance variable \ttt{x}. 
Should we not use \ttt{this} on the left-hand variable identifier, then the parameter \ttt{x} would \emph{shadow}\index{variable shadowing}\index{shadow} the instance variable \ttt{x}, meaning that writing \ttt{x = x} assigns the parameter to itself. 
At last, we can create a \ttt{Point} object by calling the constructor, but wait, we have no way of accessing/referring to the instance variables of the \ttt{Point} object! 
We need to create \emph{accessor methods}\index{accessor method} to retrieve the values of the instance variables. 
Accessor methods are non-private and have strictly one purpose: to return the respective instance variable value.

%\enlargethispage{4\baselineskip}
\begin{lstlisting}[language=MyJava]
class Point {

  private final int X;
  private final int Y;
  
  Point(int x, int y) {
    this.X = x;
    this.Y = y;
  }
  
  int getX() { return this.X; }
  
  int getY() { return this.Y; }
}
\end{lstlisting}

The principle of hiding the implementation details of a class and its properties is called \emph{encapsulation}\index{encapsulation}. 
Encapsulation is a fundamental idea of object-oriented programming, and is one of the primary reasons why object-oriented programming is so powerful. 
It can be dangerous to directly modify or access the fields of an object.\footnote{By ``dangerous,'' we mean to suggest that it is prone to logic errors.} 

Creating an instance of the \ttt{Point} class is identical to creating an instance of any other arbitrary class.
Though, we should first explain a slight terminology distinction.

Declaring, or \emph{initializing}\index{initialize}\index{object initialization}, an object refers to typing the class name followed by the variable name. 
For instance, the following code declares/initializes a \ttt{Point} object~\ttt{p}.

\begin{verbnobox}[\small]
Point p;
\end{verbnobox}

By default,~$p$ points to \ttt{null}, since we have not yet created an instance of the \ttt{Point} class. 
We can create an instance of the \ttt{Point} class by invoking its constructor, an action otherwise called \emph{object instantiation}\index{object instantiation}\index{instantiation}. 
We use the \ttt{new} keyword and pass the desired~$x$ and~$y$ integer coordinates. 

\begin{verbnobox}[\small]
Point p = new Point(3, 4);
\end{verbnobox}

We should write some tests to ensure that our \ttt{Point} class is working as expected. 
We note that this may seem redundant for such a simple class, and the fact that the accessor methods do nothing more than retrieve instance variable values, but it is a good habit for beginning object-oriented programmers.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;

class PointTester {
  
  @Test
  void testPoint() {
    Point p = new Point(3, 4);
    assertEquals(3, p.getX());
    assertEquals(4, p.getY());
  }
}
\end{lstlisting}

Of course, testing the accessor methods is a little boring, so let's override the \ttt{toString} method to print a stringified representation of the \ttt{Point} class. 
Every object in Java has a \ttt{toString} method, which returns a string representation of the object. 
By default, the \ttt{toString} method returns the class name followed by the object's hashcode. 
We can override the \ttt{toString} method by declaring a method with the signature \ttt{public String toString()} (note that this is one instance where \ttt{public} cannot be avoided.) 
We can then return a string representation of the object. 
In this case, we will return a string of the form \ttt{"(x=$x$, y=$y$)"}, where~$x$ and~$y$ refer to the respecitve instance variables. 

%\enlargethispage{4\baselineskip}
\begin{lstlisting}[language=MyJava]
class Point {
  // ... previous code not shown.

  @Override
  public String toString() {
    return String.format("(x=%d, y=%d)", this.X, this.Y);
  }
}
\end{lstlisting}

Testing the \ttt{toString} method provides more interesting results, since it requires us to not only override the default implementation of \ttt{toString}, but it also ensures that our constructor correctly initializes the instance variables. 
%Because we will refer to~$p$ across several tester methods, we can declare it as an instance variable of our \ttt{PointTester} class so as to reduce redundant object instantiation.

\enlargethispage{2\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;

class PointTester {

  private final Point P = new Point(3, 4);

  @Test
  void testPointAccessors() {
    assertEquals(3, P.getX());
    assertEquals(4, P.getY());
  }

  @Test
  void testPointToString() {
    assertEquals("(x=3, y=4)", P.toString());
  }
}
\end{lstlisting}

In addition to the \ttt{toString} method, we might also design other methods associated with a \ttt{Point} object. 
For example, we might want to calculate the distance between two points. 
We can design a method that takes a \ttt{Point} object as a parameter and returns the distance between the two points, the first being the \emph{implicit parameter}, and the second being the \emph{explicit parameter}. 
We say the first is \emph{implicit} because, under the hood, all class methods receive an implicit parameter, which is the object on which the method is called, which is accessible through the \ttt{this} pointer. 
We say the second is \emph{explicit} because we explicitly pass the object as a parameter. 
So, in the following example,~\ttt{p1} is the implicit parameter, and \ttt{p2} is the explicit parameter.

\begin{verbnobox}[\small]
final Point P1 = new Point(3, 4);
final Point P2 = new Point(6, 42);
double dist = p1.distance(p2);
\end{verbnobox}

This is also a good time to bring up another terminology distinction. 
Some programming languages use \emph{functions}, others use \emph{procedures}, \emph{subroutines}, or \emph{methods}. 
Going from simplest to most complex, subroutines are simply a sequence of instructions that are executed in order. 
Procedures are subroutines that return a value. 
Functions are procedures that receive parameters. 
Methods are functions that are associated with a class. 
In Java, we use the term \emph{method} to refer to all functions, procedures, and subroutines, since all methods must be associated with a class. 
A language like C++, on the other hand, distinguishes between the two: \emph{functions} refer to subroutines, procedures, or parameter-receiving procedures that are not associated with a class; \emph{methods} are subroutines, procedures, or functions embedded inside a class definition.

Returning to the \ttt{Point} class, we will now design \ttt{distance}, which receives a \ttt{Point} as a parameter and returns the Euclidean distance from \ttt{this} point to the parameter. 
Before doing so, however, we should write a few tests. 
Conveniently, the three points that we test all have a distance of five between each other.

%\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {

  private final double DELTA = 0.01;
  private final Point P1 = new Point(3, 4);
  private final Point P2 = new Point(6, 8);
  private final Point P3 = new Point(0, 0);

  @Test
  void testPointDistance() {
    assertAll(
      () -> assertEquals(5, P1.distance(P2), DELTA),
      () -> assertEquals(5, P1.distance(P3), DELTA),
      () -> assertEquals(5, P2.distance(P3), DELTA));
  }
}
\end{lstlisting}

\enlargethispage{-6\baselineskip}
\begin{lstlisting}[language=MyJava]
class Point {
  // ... previous code not shown.

  /**
   * Determines the Euclidean distance between two points.
   * @param p the other point.
   * @return the distance between this point and p.
   */
  double distance(Point p) {
    int dx = this.X - p.X;
    int dy = this.Y - p.Y;
    return Math.sqrt(dx * dx + dy * dy);
  }
}
\end{lstlisting}

The \ttt{distance} method is called an \emph{instance method} because it is associated with an instance of the class. 
We can also write \emph{static methods}, which are not associated with an object, but rather the class holistically. 
Static methods are useful as utility methods that are not associated with a particular instance of the class. 
All methods that we designed up until this chapter were static methods, which were not associated with the class in which they resided, because the classes we designed were used only to hold the methods themselves.

\subsubsection*{Method Overloading}
A method is identified by two attributes: its name and its signature. 
Java allows us to \emph{overload}\index{method overloading} a method or constructor by using the same identifier, but different parameters.

\myexample{Let's overload the \ttt{distance} method by designing a version that does not receive a parameter at all, and instead returns the magnitude/distance from the point to the origin.} 
Fortunately, this is extremely easy, because we can make use of the existing \ttt{distance} method that \emph{does} receive a \ttt{Point}. 
Namely, we pass it the origin point, i.e., \ttt{new Point(0, 0)}, and everything works wonderfully. 
Because this version of \ttt{distance} merely refers to the existing definition, which we have thoroughly tested, we will omit a separate set of tests.

\begin{lstlisting}[language=MyJava]
class Point {
  // Previous code not shown.
  
  /**
   * Computes the distance from this point to the origin,
   * i.e., (0, 0).
   * @return returns the magnitude of this distance.
   */
   double distance() {
     return this.distance(new Point(0, 0));
   }
}
\end{lstlisting} 

We could, if desired, overload the \ttt{Point} constructor as well. 
Though, it makes little sense to do so in this specific context, because a point is defined by its two coordinate members. 
In subsequent sections, however, we will overload other class constructors to demonstrate its utility/practicality.

\myexample{Let's design the static \ttt{avgDist} method, which receives a \ttt{List<Point>} and computes the average distance away each \ttt{Point} is from the origin.} 
We already have a method to compute the distance of a point to the origin, so let's take advantage of the stream API to map \ttt{distance} to every point, then find the average of those resulting double values. 
The \ttt{avgDist} method returns an \ttt{OptionalDouble} in the event that the provided list is empty, which serves as a wrapper around the \ttt{Optional<Double>} type.

%\enlargethispage{4\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

import java.util.List;
import java.util.OptionalDouble;

class PointTester {

  @Test
  void testAvgDist() {
    List<Point> lop1 = List.of();
    List<Point> lop2 = List.of(new Point(4, 0), new Point(0, 4),
                               new Point(-4, 0), new Point(0, -4),
                               new Point(2, 2), new Point(-2, 2),
                               new Point(-2, -2), new Point(2, -2));
    assertAll(
      () -> assertEquals(OptionalDouble.empty(), Point.avgDist(lop1)),
      () -> assertEquals(3.414, Point.avgDist(lop2).get(), 0.01));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.List;
import java.util.OptionalDouble;

class Point {
  // ... previous code not shown. 

  /**
   * Computes the average distance to the origin of a list of points.
   * @param lop list of points.
   * @return empty Optional if the list is empty, 
   *         or OptionalDouble otherwise.
   */
  static OptionalDouble avgDist(List<Point> lop) {
    return lop.stream()
              .map(p -> p.distance())
              .mapToDouble(d -> d)
              .average();
  }
}
\end{lstlisting}

\myexample{Let's design the static \ttt{random} method, which returns a \ttt{Point} object with random~$x$ and~$y$ coordinates. 
We will use the \ttt{Random} class to generate a random radius and angle as a polar coordinate. 
Then, we will convert the polar coordinate to Cartesian coordinates. 
Let's also add a parameter that specifies a maximum radius.}

Because the \ttt{random} method generates a random point, we cannot reasonably write a test that asserts the exact location of the point without prior knowledge of the random seed. 
Instead, we can write a test that asserts whether the point is within a certain radius of the origin. 

\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertTrue;

class PointTester {

  @Test
  void testPointRandom() {
    assertAll(
      () -> assertTrue(Point.random(10).distance() <= 10);
      () -> assertTrue(Point.random(1).distance() <= 1);
      () -> assertTrue(Point.random(5).distance() <= 5);
      () -> assertTrue(Point.random(5000000).distance() <= 5000000));
  }
}
\end{lstlisting}

%\enlargethispage{1\baselineskip}
\begin{lstlisting}[language=MyJava]
import java.util.Random;

class Point {

  /**
   * Generates a random point with a maximum radius.
   * @param maxRadius the maximum radius.
   * @return a random point.
   */
  static Point random(double maxRadius) {
    Random r = new Random();
    double radius = r.nextDouble(maxRadius);
    double angle = r.nextDouble() * Math.PI * 2;
    int x = (int) (radius * Math.cos(angle));
    int y = (int) (radius * Math.sin(angle));
    return new Point(x, y);
  }
}
\end{lstlisting}

We have seen static methods, but what about static variables? 
A \emph{static variable}\index{static variable} is a variable that is associated with the class and not a specific instance thereof. 
Static variables are shared among all instances of a class.

\myexample{Suppose that we want to count how many instances of \ttt{Point} have been instantiated in a running program.}
Since counting instances is a property of the \ttt{Point} class, rather than an instance \emph{of} the class, we can declare a static variable \ttt{count} to keep track of the number of instances, which we increment inside the constructor. 
To remain consistent with our recurring theme of encapsulation, \ttt{count} will be declared as \ttt{private}, and we will design a static method \ttt{getCount} to retrieve the number of instances, which is invoked on the class.\footnote{It is also possible to invoke a static method on an instance of the class, but it is considered bad practice and unnecessary.} 
When testing, we need to be careful to only instantiate instances of \ttt{Point} when we are ready to check the status of \ttt{count}, since the static \ttt{count} variable is updated inside the constructor.

\enlargethispage{-5\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;

class PointTester {

  @Test
  void testPointCount() {
    assertEquals(0, Point.getCount())
    Point p1 = new Point(3, 4);
    assertEquals(1, Point.getCount());
    Point p2 = new Point(6, 8);
    assertEquals(2, Point.getCount());
    Point p3 = new Point(0, 0);
    assertEquals(3, Point.getCount());

    // Even though we lose reference to p, the static variable still increments!
    for (int i = 0; i < 10; i++) {
      Point p = new Point();
    }
    assertEquals(13, Point.getCount());
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Point {

  private static int count = 0;

  private final int X;
  private final int Y;

  Point(int x, int y) { 
    this.X = x; 
    this.Y = y; 
    count++; 
  }

  static int getCount() { 
    return count; 
  }
}
\end{lstlisting}

Notice that, inside the \ttt{getCount} method, we do not refer to \ttt{count} with \ttt{this}, because \ttt{count} is a static variable and not an instance variable. 
Prefixing the \ttt{count} variable with \ttt{this} results in a compiler error. 
Further note that the variable is not marked as \ttt{final}; it is not immutable and changes with every newly-instantiated \ttt{Point} object.

\myexample{Imagine we want to store a collection of \ttt{Point} objects in a data structure such as a \ttt{HashSet}.} 
The question that arises from this decision is apparent: how do we determine if a \ttt{Point} is already inside the set? 

We need to override two important methods from the \ttt{Object} class: \ttt{public boolean equals} and \ttt{public int hashCode}. 
The \ttt{equals} method of an object determines whether two instances of the class are ``equal.'' 
In the circumstance of points, let's say that two points are equal according to \ttt{equals} only if they have the same~$x$ and~$y$ coordinates. 
Overriding the \ttt{equals} method from the \ttt{Object} class requires correctly copying the signature, the sole parameter being an \ttt{Object} that we need to check for type equality. 
In other words, we first need to verify that the passed object to the \ttt{equals} method is, in fact, a \ttt{Point}, otherwise they cannot possibly be equal. 
To ``type check'' a parameter, we use the \ttt{instanceof} keyword. 
If the input parameter is, indeed, a \ttt{Point}, we cast it to a \ttt{Point} instance, then check whether the coordinates match. 
Moreover, like \ttt{toString}, the \ttt{equals} and \ttt{hashCode} methods are definitionally \ttt{public}, so do not omit the access modifier.

The \ttt{assertEquals} and \ttt{assertNotEquals} methods invoke an object's \ttt{.equals} method when determining equality, which by default compares object references. 
Because we are finally overriding its implementation in \ttt{Point}, we can test two arbitrary \ttt{Point} instances for definitional equality.

%\enlargethispage{-1\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;
import static Assertions.assertNotEquals;

class PointTester {

  @Test
  void testEquals() {
    assertAll(
      () -> assertEquals(new Point(3, 3), new Point(3, 3)),
      () -> assertNotEquals(new Point(3, 4), new Point(3, 7)),
      () -> assertNotEquals(new Point(7, 4), new Point(10, 4)),
      () -> assertNotEquals(new Point(10, 30), new Point(3, 7)));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Point {
  // ... previous code not shown.

  @Override
  public boolean equals(Object obj) {
    if (!(obj instanceof Point)) { return false; }
    else {
      Point othPt = (Point) obj;
      return this.x == othPt.x && this.y == othPt.y;
    }
  }
}
\end{lstlisting}

Let's create a \ttt{HashSet<Point>}, then iterate over the elements thereof after adding two of the same \ttt{Point} instances, i.e., points that share coordinates. 
Doing so demonstrates a glaring flaw: the set appears to have added both \ttt{Point} instances to the set, despite having identical coordinates. 
The reason is incredibly subtle and easy to miss: the \ttt{Object} class invariant states that, if two objects are equal according to \ttt{equals}, then their hash codes must also be equal. 
The \emph{hash code}\index{hash code} of an object is an integer used for quick access/lookup in hashable data structures such as \ttt{HashSet} and \ttt{HashMap}. 
Indeed, the problem is that we forgot to override \ttt{hashCode} after overriding the \ttt{equals} method in the \ttt{Point} class. 
\Citet{effectivejava} states, as a principle, that whenever we override \ttt{equals}, we should accompanyingly override the \ttt{hashCode} implementation. 

Now, you might wonder: ``How can I hash (compute the hash code of) an object?'' 
Fortunately Java has a method in the \ttt{Objects} class called \ttt{hash}, which receives any number of arguments and runs them through a hashing algorithm, thereby returning the hash of the arguments. 
When overriding \ttt{hashCode}, we should include all instance variables of the object to designate that all of the properties affect the object's hash code. 
After fixing the issue, we see that our \ttt{HashSet} now correctly contains only one of the \ttt{Point} objects that we add.

\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertTrue;

import java.util.Set;
import java.util.HashSet;

class PointTester {

  @Test
  void testHashSetPoint() {
    Set<Point> p = new HashSet<>();
    p.add(new Point(3, 3));
    p.add(new Point(3, 3));
    assertTrue(p.size() == 1);
  }
}
\end{lstlisting}

%\enlargethispage{6\baselineskip}
\begin{lstlisting}[language=MyJava]
import java.util.Objects;

class Point {
  // ... previous code not shown.

  @Override
  public int hashCode() {
    return Objects.hash(this.x, this.y);
  }
}
\end{lstlisting}

\myexample{Let's design the static \ttt{removeLinearPoints} method that, when given a \ttt{List<Point>}, filters out all points that are ``linear,'' meaning that their~$x$ and~$y$ coordinates are the same.} 
As with the previous example, streams make this exercise a walk in the park. 
When comparing lists, the \ttt{equals} method invokes \ttt{equals} on every element of the list, meaning that we call \ttt{Point}'s implementation of \ttt{equals}.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

import java.util.List;

class PointTester {
  // ... previous code not shown. 

  @Test
  void testRemoveLinearPoints() {
    List<Point> lop = List.of(new Point(5, 10), new Point(7, 7),
                              new Point(2, 3), new Point(4, 3),
                              new Point(1, 1), new Point(-6, -10),
                              new Point(-23, -23), new Point(1, 0));
    List<Point> lopRes = List.of(new Point(5, 10), new Point(2, 3), new Point(4, 3),
                                 new Point(-6, -10), `new Point(1, 0));
    assertAll(
      () -> assertEquals(List.of(), Point.removeLinearPoints(List.of())),
      () -> assertEquals(lopRes, Point.removeLinearPoints(lop)));
  }
}
\end{lstlisting}

\enlargethispage{-1\baselineskip}
\begin{lstlisting}[language=MyJava]
import java.util.List;

class Point {
  // ... previous code not shown. 

  /**
   * Returns a list of all points that are not "linear."
   * @param lop list of Point objects.
   * @return list where linear points are removed.
   */
  static List<Point> removeLinearPoints(List<Point> lop) {
    return lop.stream()
              .filter(p -> p.getX() != p.getY())
              .toList();
  }
}
\end{lstlisting}

\myexample{Suppose that we're writing a program that keeps track of orders for a local pizzeria.}
Let's design the \ttt{PizzaOrder} class, which stores a \ttt{Map<String, Integer>} as an instance variable.
The map associates toppings (as strings) to their respective quantities on the pizza order. 
Toppings can be \ttt{"Pepperoni"}, \ttt{"Onion"}, \ttt{"Pineapple"}, or \ttt{"Anchovie"}.
The \ttt{PizzaOrder} constructor instantiates the map to be a \ttt{LinkedHashMap} to ensure that the order of the toppings is respected.
As parameters to the constructor, it receives two arrays: \ttt{String[] toppings} and \ttt{int[] toppingCount}, where each entry is added to the map.
To make the constructor simpler, we will assume that \ttt{toppings} and \ttt{toppingCount} share the same length.
We'll also design the \ttt{Set<String> getToppings()} method to return the toppings in the order that they were added.
Finally, we'll design a method, \ttt{Optional<Integer> getToppingCount(String s)} to retrieve the number/quantity of a given topping.\footnote{The \ttt{getToppingCount} method uses \ttt{Optional.ofNullable} that, when given a \ttt{null} argument, returns the empty \ttt{Optional} and otherwise wraps the value in a non-empty \ttt{Optional}.}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

import java.util.Optional;

class PizzaOrderTester {

  @Test
  void testPizzaOrder() {
    PizzaOrder p1 = new PizzaOrder();
    PizzaOrder p2 = new PizzaOrder(new String[]{"Pepperoni", "Anchovie"},
                                   new int[]{3, 2});
    assertAll(
      () -> assertEquals(Set.of(), p1.getToppings()),
      () -> assertEquals(Set.of("Pepperoni", "Anchovie"), p2.getToppings())
      () -> assertEquals(Optional.of(3), p2.getToppingCount("Pepperoni")),
      () -> assertEquals(Optional.empty(), p2.getToppingCount("Pineapple")));
  }
}
\end{lstlisting}

\enlargethispage{-4\baselineskip}
\begin{lstlisting}[language=MyJava]
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

class PizzaOrder {

  private final Map<String, Integer> TOPPINGS;

  PizzaOrder(String[] toppings, int[] count) {
    this.TOPPINGS = new LinkedHashMap<>();
    for (int i = 0; i < toppings.length; i++) {
      TOPPINGS.put(toppings[i], count[i]);
    }
  }

  /**
   * Returns the toppings as a set.
   * @return new LinkedHashSet containing toppings.
   */
  Set<String> getToppings() {
    Set<String> set = new LinkedHashSet<>();
    this.TOPPINGS.keySet().forEach(k -> set.add(k));
    return set;
  }

  /**
   * Returns the number of a certain topping there are in this pizza order.
   * @param topping one of the four toppings.
   * @return Optional<Integer> containing value, or empty optional.
   */
  Optional<Integer> getToppingCount(String topping) {
    return Optional.ofNullable(this.TOPPINGS.get(topping));
  }
}
\end{lstlisting}

\myexample{Let's amplify the complexity a bit by designing a ``21'' card game, which is a card game where the players try to get a card value total of~$21$ without going over.} 
We should think about the design process of this game, i.e., what classes we need to design. 
It makes sense to start with a \ttt{Card} class, which stores its suit and its numeric value. 
A suit is one of four possibilities, each of which use a different symbol, meaning that we should create another class called \ttt{Suit}. 
In \ttt{Suit}, we instantiate four static instances of \ttt{Suit}, each of which represents one of the four valid suits. 
Its constructor is privatized because we, as the programmers, define the four possible suits.\footnote{Instantiating objects in this manner bears resemblance to a \emph{design pattern}\index{design pattern} called \emph{singleton}\index{singleton}.} 
Consequently, it should not be possible for the user to define their own custom suit, at least for this particular game. 
The notion of \ttt{Suit} being an instance variable of \ttt{Card}, and only existing as a means to support the \ttt{Card} class is called \emph{object composition}\index{object composition}. 
Lastly, we will provide a method that returns an \ttt{Iterator<Suit>} over the four suit possibilities to make our lives easier when designing the \ttt{Deck} class. 
The method should be static, so it is accessible through the class and not an instance.

\enlargethispage{-3\baselineskip}
\begin{lstlisting}[language=MyJava]
class Suit {

  static final Suit CLUBS = new Suit("(*;$\clubsuit$;*)");
  static final Suit DIAMONDS = new Suit("(*;$\diamondsuit$;*)");
  static final Suit HEARTS = new Suit("(*;$\heartsuit$;*)");
  static final Suit SPADES = new Suit("(*;$\spadesuit$;*)");
  static final int NUM_SUITS = 4;

  private final String S_VAL;

  private Suit(String s) { this.S_VAL = s; }

  static Iterator<Suit> iterator() {
    return new ArrayList<Suit>(List.of(CLUBS, DIAMONDS, HEARTS, SPADES))
                              .iterator();
  }

  @Override
  public String toString() { 
    return this.S_VAL; 
  }
}
\end{lstlisting}

Testing the \ttt{Card} class is straightforward; we only need to test one method, the \ttt{toString} method, since testing \ttt{getValue}, at this point, is superfluous. 
We could also test the \ttt{Suit} class, but we will not do so here, given that the only useful methods are accessors and the iterator retriever.

%\enlargethispage{1\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class CardTester {

  @Test
  void testCardToString() {
    assertAll(
      () -> assertEquals("2 of (*;$\clubsuit$;*)", new Card(Suit.CLUBS, 2).toString()),
      () -> assertEquals("3 of (*;$\diamondsuit$;*)", new Card(Suit.DIAMONDS, 3).toString()),
      () -> assertEquals("4 of (*;$\heartsuit$;*)", new Card(Suit.HEARTS, 4).toString()),
      () -> assertEquals("5 of (*;$\spadesuit$;*)", new Card(Suit.SPADES, 5).toString()));
  }
}
\end{lstlisting}

\enlargethispage{1\baselineskip}
\begin{lstlisting}[language=MyJava]
class Card {

  private final Suit SUIT;
  private final int VAL;

  Card(Suit suit, int value) { this.SUIT = suit; this.VAL = value; }
  
  @Override
  public String toString() { 
    return String.format("%d of %s", this.VAL, this.SUIT); 
  }

  int getValue() { 
    return this.VAL; 
  } 
}
\end{lstlisting}

In a standard fifty-two deck of cards, some are ``special,'' e.g., the Jacks, Queens, Kings, and Ace cards, otherwise called the ``face'' cards. 
To simplify the design of our game, the face cards will be treated the same as a ``ten'' card, showing neither a syntactic nor semantic difference. 
Now that we have a class to represents cards, let's design the \ttt{Deck} class, which stores an \ttt{ArrayList<Card>} representing the current state of the deck. 
It also contains a static variable representing the maximum number of allowed cards. 
For our purposes, as we alluded to, the maximum is fifty-two. 
In the \ttt{Deck} constructor, we call the \ttt{populateDeck} method, which adds four cards of the same value, but of each suit. 
So, to exemplify, there are four cards whose value is three, where each is one of the four suits. 
We make use of the iterator from the \ttt{Suit} class to simplify our deck population. 
Only the \ttt{Deck} class needs to know how to populate an initial (empty) deck, so we privatize its access.

To test a \ttt{Deck}, we can design the \ttt{drawCard} method, which retrieves the ``top-most'' card on the deck. 
According to our implementation of the iterator, the top-most cards should have values of ten and be of the same suit. 
From there, we can draw three more cards to ensure they have the values nine, eight, and seven, all of the same suit. 
The iterator places \ttt{DIAMOND} as the final suit, so this is what we will assume in our tester. 
It might also be beneficial to test the \ttt{isEmpty} method, which returns \ttt{true} if the deck is empty, and \ttt{false} otherwise. 
We can test \ttt{isEmpty} by drawing all fifty-two cards from the deck and ensuring that the deck is empty afterwards. 
Note that we draw four tens because there are no ``Kings,'' ``Queens,'' or ``Jacks'' in the deck.

%\enlargethispage{5\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;
import static Assertions.assertTrue;
import static Assertions.assertFalse;

class DeckTester {

  @Test
  void testDeckDrawCard() {
    Deck d = new Deck();
    assertAll(
      () -> assertEquals("10 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("10 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("10 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("10 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("9 of (*;$\diamondsuit$;*)", d.drawCard().toString()));
  }

  @Test
  void testDeckIsEmpty() {
    Deck d = new Deck();
    for (int i = 0; i < 52; i++) {
      assertFalse(d.isEmpty());
      d.drawCard();
    }
    assertTrue(d.isEmpty());
  }
}
\end{lstlisting}

\enlargethispage{-5\baselineskip}
\begin{lstlisting}[language=MyJava]
import java.util.ArrayList;
import java.util.Iterator;

class Deck {

  private static final int MAX_NUM_CARDS = 52;
  private final ArrayList<Card> CARDS;

  Deck() {
    this.CARDS = new ArrayList<Card>();
    this.populateDeck();
  }

 /**
  * Retrieves a card from the "top" of the deck. If the
  * deck is empty, we return null.
  * @return the top-most card in the deck, or null if the deck is empty.
  */
  Card drawCard() {
    if (this.CARDS.isEmpty()) {
      return null;
    } else {
      return this.CARDS.remove(this.CARDS.size() - 1);
    }
  }

  /**
   * Determines if the deck is empty.
   * @return true if the deck contains no cards, and false otherwise.
   */
  boolean isEmpty() { 
    return this.CARDS.isEmpty(); 
  }

  /**
   * Instantiates the deck to contain all 52 cards.
   * Note that the deck contains cards in-order by suit. There are 
   * no face cards in the deck, i.e., no Jack, Queen, King, nor Ace.
   * All cards have a value between 1 and 10.
   */
  private void populateDeck() {
    // For every suit, create 13 cards, the last four of which all have
    // a value of ten.
    Iterator<Suit> it = Suit.iterator();
    while (it.hasNext()) {
      Suit s = it.next();
      for (int i = 1; i <= MAX_NUM_CARDS / Suit.NUM_SUITS; i++) {
        Card c = new Card(s, Math.min(10, i));
        this.CARDS.add(c);
      }
    }
  }
}
\end{lstlisting}

\newpage % ugh
Hopefully, the \ttt{populateDeck} method is intuitive and not intimidating. 
We create fifty-two card instances, split into four equal-sized groups of suits, and add them to the deck.
We use the \ttt{Math.min} method to ensure that the value of the card is at most ten, since we do not have ``King,'' ``Queen,'' or ``Jack'' cards. 
We also use the ternary operator to check if the deck is empty before drawing a card. 
If the deck is empty, we return \ttt{null}.

Finally, we come to the \ttt{Player} class, which stores a ``hand'' containing the cards in their possession. 
Fortunately, this is a very straightforward class, containing four one-line methods: \ttt{addCard}, \ttt{clearHand}, \ttt{getScore}, and \ttt{toString}. 
The former two are trivial to explain, as is \ttt{toString}, whereas \ttt{getScore} is the only slightly convoluted method. 
The idea is to return an integer that represents the total value of the cards in the player's hand. 
Since streams were introduced in the previous chapter, we will once again use them to our advantage.

\begin{lstlisting}[language=MyJava]
import java.util.ArrayList;

class Player {

  private final ArrayList<Card> HAND;

  Player() { this.HAND = new ArrayList<Card>(); }

  /**
   * Adds a card to the player's hand.
   * @param c card to add to the player's hand.
   */
  void addCard(Card c) { this.HAND.add(c); }

  /**
   * Removes all cards from the player's hand.
   */
  void clearHand() { this.HAND.clear(); }

  /**
   * Determines the player's score.
   * @return the player's score.
   */
  int getScore() {
    return this.HAND.stream()
                    .map(c -> c.getValue())
                    .reduce(0, Integer::sum);
  }

  @Override
  public String toString() {
    return String.format("Score: %d\nHand: %s\n", 
                         this.getScore(), this.HAND.toString());
  }
}
\end{lstlisting}

Using the capabilities of \ttt{Player}, \ttt{Deck}, and \ttt{Card}, we will design \ttt{TwentyOne}: the class that runs a game of ``twenty-one.'' 
The game logic is as follows: if the game is still running, clear the player's hand, create a new deck of cards, shuffle them, and give the player two. 
Then, ask the player if they want to draw another card. 
If they do, draw a card (from the deck) and add it to their hand. 
If they do not, then the game is over. 
If the player's score is greater than twenty-one, then the player loses. Otherwise, the player wins. 
We will also write a \ttt{main} method that runs the game. 
We will not write any tests for this class, since it interacts with the user through the \ttt{Scanner} class.

It should be noted that this version of ``twenty-one'' only has the objective of getting as close as possible to a hand containing cards with a value that sums to twenty one, compared to a more traditional card game where multiple players exist, with a dealer to distribute cards. 
As exercises, there are many ways to enhance the game, including adding a ``high score'' board to keep track of previous game outcomes, introducing CPU players to automatically poll cards from the deck to beat the main player, or even adding more human players through standard input/output interactions. 

\enlargethispage{1\baselineskip}
\begin{lstlisting}[language=MyJava]
import java.util.Scanner;

class TwentyOne {

  private static final int MAX_SCORE = 21;
  private final Player PLAYER;

  TwentyOne() { this.PLAYER = new Player(); }

  /**
   * Plays a game of "21", where the player has to draw cards until they
   * get as close to 21 as possible without going over.
   */
  void playGame() {
    Scanner in = new Scanner(System.in);
    boolean continuePlaying = true;
    while (continuePlaying) {
      // Clear the player's hand.
      this.player.clearHand();

      // Create and shuffle the deck.
      Deck d = new Deck();
      d.shuffleDeck();

      // First, deal two cards.
      this.PLAYER.addCard(d.drawCard());
      this.PLAYER.addCard(d.drawCard());

      // While the player has not "busted", 
      // ask them to draw a card or stand.
      while (this.PLAYER.getScore() <= MAX_SCORE) {
        System.out.println(this.PLAYER);
        System.out.println("Do you want to draw? (Y/n)");
        String resp = in.nextLine();
        if (resp.equals("Y")) { this.PLAYER.addCard(d.drawCard()); }
        else { break; }
      }

      // Print the final results of the player.
      System.out.println(this.PLAYER);
      if (this.PLAYER.getScore() > MAX_SCORE) {
        System.out.println("You lose!");
      } else {
        System.out.printf("You did not go over %d!", MAX_SCORE);
      }

      System.out.println("Do you want to continue playing?");
      String resp = in.nextLine();
      continuePlaying = resp.equals("Y");
    }
  }
}
\end{lstlisting}

Designing interactive games is a great exercise in object-oriented programming, as well as the culmination of other discussed topics.

\myexample{Suppose that we are asked to design a simple library management system for a local library.}
That is, the system wants to be able to check out books, determine if they are in the system, and how much stock remains.
Let's think about the components of such a system.
At a minimum, we need an \ttt{Author} and a \ttt{Book} class.
Authors contain only a name out of conciseness.
Books contain a title, author, release date, edition number, and page count.
Because books contain authors, we again use object composition. 
Both classes, namely \ttt{Author} and \ttt{Book} are straightforward to design. Both classes also override the \ttt{equals}, \ttt{hashCode}, and \ttt{toString} methods for use in a hashable data structure and equality comparison.

\begin{lstlisting}[language=MyJava]
class LibraryTester {

  private static final Author A1 = new Author("Michael Spivak");
  private static final Author A2 = new Author("Joshua Crotts");
  private static final Author A3 = new Author("Douglas Hofstader");
  private static final Author A4 = new Author("William Van Orman Quine");
  
  private static final Book B1 
    = new Book("Calculus", A1, 4, 680);
  private static final Book B2 
    = new Book("Principles of Computer Science", A2, 1, 754);
  private static final Book B3 
    = new Book("Godel, Escher, Bach", A3, 2, 824);
  private static final Book B4 
    = new Book("Methods of Logic", A4, 4, 344);

  @Test
  void testBook() {
    assertAll(
      () -> assertEquals("Calculus", b1.getTitle()),
      () -> assertEquals(new Author("Joshua Crotts"), b2.getAuthor()),
      () -> assertEquals(2, b3.getEditionNumber()),
      () -> assertEquals(344, b4.getPageCount()));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Author {

  private final String NAME;

  Author(String name) { this.NAME = name; }

  @Override 
  public boolean equals(Object o) {
    if (!(o instanceof Author)) {
      return false;
    } else {
      Author othAuthor = (Author) o;
      return this.NAME.equals(othAuthor.getName());
    }
  }

  @Override
  public int hashCode() {
    return this.NAME.hashCode();
  }

  @Override
  public String toString() {
    return this.NAME;
  }

  String getName() {
    return this.NAME;
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.Objects;

class Book {

  private final String TITLE;
  private final Author AUTHOR;
  private final int EDITION;
  private final int NUM_PAGES;

  Book(String title, Author author, int edition, int numPages) {
    this.TITLE = title;
    this.AUTHOR = author;
    this.EDITION = edition;
    this.NUM_PAGES = numPages;
  }

  @Override
  public boolean equals(Object o) {
    if (!(o instanceof Book)) {
      return false;
    } else {
      Book othBook = (Book) o;
      return this.NAME.equals(othBook.NAME)
          && this.AUTHOR.equals(othBook.AUTHOR)
          && this.EDITION == (othBook.EDITION)
          && this.NUM_PAGES == (othBook.NUM_PAGES);
    }
  }
  
  @Override
  public int hashCode() {
    return Objects.hashCode(this.NAME, this.AUTHOR, 
                            this.EDITION, this.NUM_PAGES);
  }

  @Override
  public String toString() {
    return String.format("%s [%s]. Edition: %d. Page Count: %d",
                         this.NAME, this.AUTHOR, 
                         this.EDITION, this.NUM_PAGES);
  }

  // Getters omitted.
}
\end{lstlisting}

\newpage %ugh
With these two classes complete, let's begin to think about the \ttt{Library} class. 
Let's say that it stores an alphabetized \ttt{Map<Book, Integer>} of book instances to the number of copies that are not checked out. 
We want to be able to add books, check books out, and determine if the book is in the library.
So, let's design the \ttt{void addBook(Book b, int qty)}, \ttt{Book checkout(String title)}, \ttt{int getQuantity(String title)}, and \ttt{boolean containsBook(String title)} methods.
The tests will reuse the \ttt{Author} and \ttt{Book} declarations from the previous test suite.

\enlargethispage{-3\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class LibraryTester {
  // ... previous test and declarations omitted.

  @Test
  void testLibrary() {
    Library l1 = new Library();
    l1.addBook(B1, 10);
    l1.addBook(B2, 1);
    l1.addBook(B3, 3);
    l1.addBook(B4, 5);
    assertAll (
      () -> assertEquals(1, l1.getQuantity("Principles of Computer Science")),
      () -> assertTrue(l1.containsBook("Methods of Logic")),
      () -> assertFalse(l1.containsBook("Frankenstein")),
      () -> assertEquals(B2, l1.checkout("Principles of Computer Science")),
      () -> assertNull(l1.checkout("Principles of Computer Science")),
      () -> assertEquals(0, l1.getQuantity("Principles of Computer Science")));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

import java.util.Map;
import java.util.TreeMap;

class Library {

  private final Map<Book, Integer> BOOKS;

  Library() {
    this.BOOKS = new TreeMap<>();
  }

  /**
   * Inserts a Book/quantity association to the map. If the book already
   * exists, we add qty to its frequency.
   * @param b Book to add to map.
   * @param qty quantity of provided book.
   */
  void addBook(Book b, int qty) {
    this.BOOKS.put(b, this.BOOKS.getOrDefault(b, 0) + qty);
  }

  /**
   * "Checks out" a book to someone. By checking out, we mean
   * that it searches for the book with the given title, and
   * returns its instance while decrementing its book counter.
   * If the associated counter is zero, we return null.
   * @param t title to search.
   * @return Book instance if it exists, or null otherwise.
   */
  Book checkout(String t) {
    for (Book b : this.BOOKS.keySet()) {
      if (b.getTitle().equals(t) && this.BOOKS.get(b) > 0) {
        this.BOOKS.put(b, this.BOOKS.get(b) - 1);
        return b;
      }
    }
    return null;
  }

  /** 
   * Searches through the books to determine if a book
   * with the given title exists.
   * @param t title of book to search for.
   * @return true if a book with title t exists, false otherwise.
   */
  boolean containsBook(String title) {
    for (Book b : this.BOOKS.keySet()) {
      if (b.getTitle().equals(t)) {
        return true;
      }
    }
    return false;
  }
}
\end{lstlisting}

\myexample{Along the lines of the previous example, let's design the \ttt{VideoGame} class, which represents a video game.}
A \ttt{VideoGame} contains a title and a rating. 
A rating is one of \ttt{"C"}, \ttt{"E"}, \ttt{"E10+"}, \ttt{"T"}, \ttt{"MA"}, and \ttt{"A"}, corresponding to parental and content warnings.
Our \ttt{VideoGame} class also overrides the \ttt{equals} and \ttt{hashCode} methods, since we will store instances thereof in hashable data structures later on.
Though, we have overridden \ttt{equals} and \ttt{hashCode} several times at this point, so our code listings will not include them, but it is extremely important to not forget about them when writing the code yourself.

\begin{lstlisting}[language=MyJava]
class VideoGame {

  private final String TITLE;
  private final String RATING;

  VideoGame(String title, String rating) {
    this.TITLE = title;
    this.RATING = rating;
  }

  // Getters omitted.
}
\end{lstlisting}

To coexist with \ttt{VideoGame} instances, let's design the \ttt{VideoGameStore} class, which rents out video games to customers.
It also keeps records about its users, namely what video games are rented to them at any point.
Each user is uniquely identified via an integer, which is associated to a set of \ttt{VideoGame} instances. The constructor instantiates the stock and rental maps.

We will design two methods, the first being \ttt{boolean rent(int id, String t)}, which rents out the video game with the given title~$t$ to the user with the identifier~$\emph{id}$.
If the user is not in the ``system,'' they are newly-instantiated and added to the rentals map.
If the video game is out of stock, not at all available, or already rented out to the passed user, then the method returns \ttt{false}.
Finally, if we are able to rent the video game to the user, its stock count is decremented by one, and a \emph{new} instance of the \ttt{VideoGame} is added to the user's video game set.

The second method, \ttt{int mostFrequentRating()}, returns the most common rating, as a number, of all video games that are rented out to users.
For example, if there are~$2$ \ttt{"E"} games,~$18$ \ttt{"E10+"} games,~$6$ \ttt{"T"} games,~$3$ \ttt{"MA"} games, and~$1$ \ttt{"A"} game rented across all users in the system, then \ttt{mostFrequentRating} returns \ttt{2} because \ttt{"E10+"} is the most common rating and is associated with~\ttt{2}.

As an auxiliary method for populating the store stock, we will also create the \ttt{addGame} method to receive a title, rating, and number of copies to add to the store.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class VideoGameStoreTester {

  static VideoGameStore populateStore() {
    VideoGameStore vgs = new VideoGameStore();
    vgs.addGame("CuddleTime Bears Adventure", "C", 2);
    vgs.addGame("Fast Racers 2", "E", 7);
    vgs.addGame("Knight of the Republic", "E10+", 4);
    vgs.addGame("Desolation IV", "T", 1);
    vgs.addGame("Fury Combat", "M", 0);
    vgs.addGame("Alien Dating Simulator", "A", 5);
    return vgs;
  }

  @Test
  void testVideoGameStoreRent() {
    VideoGameStore vgs = populateStore();
    assertAll(
      () -> assertTrue(vgs.rent(1, "Fast Racers 2"));   // Case 4
      () -> assertTrue(vgs.rent(1, "Desolation IV"));   // Case 4
      () -> assertFalse(vgs.rent(1, "Fury Combat"));    // Case 1
      () -> assertFalse(vgs.rent(1, "Fast Racers 2"));  // Case 3
      () -> assertFalse(vgs.rent(2, "Desolation IV"))); // Case 2
  }

  @Test
  void testVideoGameStoreMostFrequentRating() {
    VideoGameStore vgs = populateStore();
    vgs.rent(1, "Fast Racers 2");
    vgs.rent(1, "Desolation IV");
    vgs.rent(2, "Fast Racers 2");
    vgs.rent(2, "Alien Dating Simulator");
    vgs.rent(3, "Fast Racers 2");
    vgs.rent(4, "Fast Racers 2");
    vgs.rent(5, "Fast Racers 2");
    assertEquals("E", vgs.mostFrequentRating());
  }
}
\end{lstlisting}

\enlargethispage{-4\baselineskip}
\begin{lstlisting}[language=MyJava]
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

class VideoGameStore {

  private final Map<VideoGame, Integer> STOCK;
  private final Map<Integer, Set<VideoGame>> RENTALS;

  VideoGameStore() {
    this.STOCK = new HashMap<>();  
    this.RENTALS = new HashMap<>();
  }

  /**
   * Attempts to rent a video game with title t to a user with the given id.
   * If the store does not have the video game in stock (whether due to it not
   * being available or a count of zero) or if the user already has a game
   * with the given title, the rental fails. Otherwise, the stock is updated and
   * the rental is added to the user's video game set.
   * If the user is not in the system, they are added.
   * @param id identifier of user.
   * @param t title of video game.
   * @return true if the rental succeeded, and false otherwise.
   */
  boolean rent(int id, String t) {
    Set<VideoGame> userSet = this.RENTALS.computeIfAbsent(id, k -> new TreeSet<>());
    // Find the VideoGame instance, if it exists, or null otherwise.
    VideoGame g = this.STOCK.keySet().stream()
                                     .filter(vg -> vg.getTitle().equals(t))
                                     .findFirst()
                                     .orElse(null);

    // Condition 1: if the store does not contain the VideoGame.
    if (g == null) {
      return false;
    } 
    // Condition 2: if the store contains no copies.
    else if (this.STOCK.get(g) == 0) {
      return false;
    } 
    // Condition 3: if the user already has the VideoGame.
    else if (userSet.stream().anyMatch(g -> g.getTitle().equals(t))) {
      return false;
    }
    // Otherwise, we are good to rent.
    else {
      this.STOCK.put(g, this.STOCK.get(g) - 1);
      userSet.add(new VideoGame(g.getTitle(), g.getRating()));
      return true;
    }
  }

  /**
   * Returns the rating that occurs most frequently among the video games that
   * have been rented out to users.
   * @return the most frequent rating as an integer. If there is a tie, the
   *         method returns the highest rating.
   */
  String mostFrequentRating() {
    Map<String, Integer> M = new LinkedHashMap<>();
    M.put("C", 0); M.put("E", 0); M.put("E10+", 0); 
    M.put("T", 0); M.put("MA", 0); M.put("A", 0);
    for (Integer i : this.RENTALS.keySet()) {
      for (VideoGame g : this.RENTALS.get(i)) {
        M.put(g.getRating(), M.getOrDefault(g.getRating(), 0) + 1);
      }
    }
    return M.entrySet().stream()
                       .max((e1, e2) -> e1.getValue() - e2.getValue())
                       .get()
                       .getKey();
  }
}
\end{lstlisting}

\myexample{Suppose we have the following class that represents a position on a two-dimensional board of characters:}

\begin{lstlisting}[language=MyJava]
class BoardPosition {

  private final char CH;

  BoardPosition(char ch;) { this.CH = ch; }

  // Getter omitted.
}
\end{lstlisting}

Let's now design the \ttt{Board} class to represent a two-dimensional board of \ttt{BoardPosition} instances.
Each instance thereof contains a \ttt{BoardPosition} that stores a single arbitrary character literal.
The \ttt{Board} constructor receives integers representing the number of rows and columns of the board.
It also receives a one-dimensional array of characters, which it uses to populate the board.
This example helps to demonstrate how to convert a one-dimensional array into a two-dimensional array.
To convert between the two, we use the formula \ttt{rows * cols + cols}.

Let's also design the \ttt{Map<Integer, List<Character>> getPredecessors()} method, which returns a map of the logical indices that precede each character in the board.
That is, each key in the map is an index/position into the board, and its value is the list of characters that precede the character at that index on the board.
For example, if the board contains the characters \ttt{\q{}a\q{}, \q{}e\q{}, \q{}f\q{}, \q{}b\q{}, \q{}d\q{}, \q{}g\q{}, \q{}c\q{}}, then the map should contain the following key-value pairs:

\begin{itemize}
  \item \ttt{0} $\rightarrow$ \ttt{[]}
  \item \ttt{1} $\rightarrow$ \ttt{[\q{}a\q{}]}
  \item \ttt{2} $\rightarrow$ \ttt{[\q{}a\q{}]}
  \item \ttt{3} $\rightarrow$ \ttt{[\q{}a\q{}, \q{}e\q{}]}
  \item \ttt{4} $\rightarrow$ \ttt{[\q{}a\q{}, \q{}e\q{}]}
  \item \ttt{5} $\rightarrow$ \ttt{[\q{}a\q{}, \q{}e\q{}, \q{}f\q{}]}
  \item \ttt{6} $\rightarrow$ \ttt{[\q{}a\q{}, \q{}e\q{}, \q{}f\q{}]}
\end{itemize}

We note that, while this example is not particularly useful in practice, it is a good exercise in traversing a two-dimensional array and converting between one-dimensional and two-dimensional arrays.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

import java.util.List;
import java.util.Map;

class BoardTester {

  private static final char[] BOARD = {'a', 'b', 'c', 'd', 'e', 'f'};

  @Test
  void testBoard() {
    assertAll(
      () -> assertEquals(2, new Board(2, 3, BOARD).getRows()),
      () -> assertEquals(3, new Board(2, 3, BOARD).getCols())
      () -> assertEquals('a', new Board(2, 3, BOARD).getBoard()[0][0].getChar()),
      () -> assertEquals('f', new Board(2, 3, BOARD).getBoard()[1][2].getChar()));
  }

  @Test
  void testBoardPredecessors() {
    Map<Integer, List<Character>> map 
      = new Board(2, 3, BOARD).getPredecessors();
    assertAll(
      () -> assertEquals(List.of(), map.get(0)),
      () -> assertEquals(List.of('a'), map.get(1)),
      () -> assertEquals(List.of('a'), map.get(2)),
      () -> assertEquals(List.of('a', 'd'), map.get(3)),
      () -> assertEquals(List.of('a', 'd'), map.get(4)),
      () -> assertEquals(List.of('a', 'd', 'e'), map.get(5)));
  }
}
\end{lstlisting}

\enlargethispage{-4\baselineskip}
\begin{lstlisting}[language=MyJava]
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Board {

  private final BoardPosition[][] BOARD;

  Board(int rows, int cols, char[] chars) {
    this.BOARD = new BoardPosition[rows][cols];
    for (int i = 0; i < rows; i++) {
      for (int j = 0; j < cols; j++) {
        this.BOARD[i][j] = new BoardPosition(chars[i * cols + j]);
      }
    }
  }

  /**
   * Returns the predecessors of each character on the board.
   * A predecessor is a character that comes before the character.
   * @return map of predecessors.
   */
  Map<Integer, List<Character>> getPredecessors() {
    Map<Integer, List<Character>> map = new HashMap<>();
    for (int i = 0; i < this.BOARD.length; i++) {
      for (int j = 0; j < this.BOARD[0].length; j++) {
        int index = i * this.BOARD[0].length + j;
        List<Character> list = new ArrayList<>();
        for (int k = 0; k < index; k++) {
          int row = k / this.BOARD[0].length;
          int col = k % this.BOARD[0].length;
          list.add(this.BOARD[row][col].getChar());
        }
        map.put(index, list);
      }
    }
    return map;
  }
}
\end{lstlisting}

% \myexample{Let's create two classes for representing pieces of chocolate and chocolate boxes.}
% We will first design the \ttt{Chocolate} class, which stores its ``kind'' and its weight in ounces.
% Given that our example will not deal with comparing pieces of chocolate for equality (nor will we store them in a hashable data structure), we will not override the \ttt{equals} and \ttt{hashCode} methods.

% \begin{lstlisting}[language=MyJava]
% class Chocolate {

%   private final String KIND;
%   private final int WEIGHT_OZ;

%   Chocolate(String kind, int weightOz) {
%     this.KIND = kind;
%     this.WEIGHT_OZ = weightOz;
%   }

%   // Accessors omitted.
% }
% \end{lstlisting}

% The \ttt{ChocolateBox} class stores a two-dimensional array of \ttt{Candy} instances.
% Its constructor receives the number of rows and columns of the underlying box, and instantiates the array to that size.
% The \ttt{ChocolateBox} class contains six (instance) methods that we will incrementally define.


% The \ttt{numberOfChocolates} method returns the number of \ttt{Chocolate} objects in the box that are non-\ttt{null}.

% \begin{lstlisting}[language=MyJava]
% class ChocolateBoxTester {

%   ChocolateBox b1 = new ChocolateBox()
% }
% \end{lstlisting}

\myexample{Let's design the \ttt{Rational} class, which stores a rational number as a numerator and denominator.}
We will create methods for adding, subtracting, multiplying, and dividing rational numbers. 
Testing is paramount to designing a correct implementation, as is the case with all projects, but is of particular significance here. 
Recall the definition of a rational number: a number that can be expressed as the ratio of two integers~$p$~and~$q$, namely $p/q$. 
We are acutely familiar with how to perform basic operations on fractions from grade school, so we will gloss over the actual mathematics and prioritize the Java implementation and class design.

The \ttt{Rational} constructor receives two integers~$p$ and~$q$, and assigns them as instance variables. 
The \ttt{toString} method only involves placing a slash between our numerator and denominator. 
Though, let's back up for a second and think about the constructor. 
Do we really want to be able to store fractions that are not in their simplest form? 
For example, do we want to allow the user to create a \ttt{Rational} object with a numerator of $2$ and a denominator of $4$? 
The answer is probably not, meaning that we should add a method that simplifies/reduces the fraction into its lowest terms.
Fractions can be reduced by finding the greatest common divisor of the numerator and denominator, and dividing both by that value. 
Euclid's algorithm\index{Euclid's algorithm} for finding the greatest common divisor of two integers works wonderfully here. 
Due to its trivial implementation and the fact that it is a tail recursive algorithm exercise from the previous chapters, we will omit its implementation.

%\enlargethispage{4\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RationalTester {
  
  @Test
  void testRationalToString() {
    assertAll(
      () -> assertEquals("1/2", new Rational(1, 2).toString()),
      () -> assertEquals("3/400", new Rational(3, 400).toString()),
      () -> assertEquals("1/1305", new Rational(5, 6525).toString()),
      () -> assertEquals("3591/46562", new Rational(7182, 93124).toString()),
      () -> assertEquals("7/32", new Rational(7, 32).toString()),
      () -> assertEquals("9388/48122", new Rational("4694/24061").toString()),
      () -> assertEquals("1/1", new Rational(1, 1).toString()));
  }
}
\end{lstlisting}

\enlargethispage{-1\baselineskip}
\begin{lstlisting}[language=MyJava]
class Rational {
  
  private final long NUMERATOR;
  private final long DENOMINATOR;

  Rational(long numerator, long denominator) {
    long gcd = gcd(numerator, denominator);
    this.NUMERATOR = numerator / gcd;
    this.DENOMINATOR = denominator / gcd; 
  }

  @Override
  public String toString() {
    return String.format("%ld/%ld", this.NUMERATOR, this.DENOMINATOR);
  }
}
\end{lstlisting}

To add two rational numbers~$r_1$ and~$r_2$, they must share a denominator. 
If they do not, then we need to find a common denominator by multiplying the denominators together, then multiplying the relevant numerators by the reciprocals of the denominator. 
For instance, if we want to add~$2/3$ and~$7/9$, the (not-necessarily lowest) common denominator is $3\cdot{9} = 27$. 
We multiply~$2$ by~$9$ and~$7$ by~$3$ to get~$18/27$ and~$24/27$. 
Adding across the numerators produces~$42/27$, which then reduces to~$14/9$. 
Since we wish to preserve the original rational number, we will write a method that returns a new \ttt{Rational} rather than modifying the one we have in-place (this also allows us to omit a step in which we simplify the resulting fraction, since the constructor takes care of this task).

\enlargethispage{1\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RationalTester {

  @Test
  void testRationalAdd() {
    assertAll (
      () -> assertEquals("14/9", 
                         new Rational(2, 3).add(new Rational(7, 9)).toString()),
      () -> assertEquals("5/6", 
                         new Rational(1, 2).add(new Rational(1, 3)).toString()),
      () -> assertEquals("1/3", 
                         new Rational(1, 4).add(new Rational(1, 12)).toString()),
      () -> assertEquals("1/4", 
                         new Rational(1, 8).add(new Rational(1, 8)).toString()),
      () -> assertEquals("1/8", 
                         new Rational(1, 16).add(new Rational(1, 16)).toString()),
      () -> assertEquals("1/16", 
                         new Rational(1, 32).add(new Rational(1, 32)).toString()),
      () -> assertEquals("2/1", 
                         new Rational(32, 32).add(new Rational(32, 32)).toString()));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Rational {
  // Other details not shown.

  /**
   * Adds two rational numbers.
   * @param r the other rational number.
   * @return the (simplified) sum of this and r.
   */
  Rational add(Rational r) {
    long commonDenominator = this.DENOMINATOR * r.DENOMINATOR;
    long newNumerator = this.NUMERATOR * r.DENOMINATOR + r.NUMERATOR * this.DENOMINATOR;
    return new Rational(newNumerator, commonDenominator);
  }
}
\end{lstlisting}

Due to its correspondence to addition, we leave \ttt{subtraction} as an exercise to the reader. 
We can now implement multiplication, which is even simpler than addition; all that is needed is to multiply the numerators and denominators together. 
We also leave \ttt{division} as an exercise to the reader. 
We encourage the reader to write methods for comparing rationals for equality, as well as greater than/less than. 

Plus, we could extend this system to support \ttt{BigInteger} values for the numerator and denominator (rather than \ttt{long} types), which would allow us to represent arbitrarily large rational numbers. 
This, in turn, would require updating all methods to use \ttt{BigInteger} arithmetic, which is a good exercise in and of itself.

\enlargethispage{-4\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RationalTester {

  @Test
  void testRationalMultiply() {
    assertAll (
      () -> assertEquals("14/27", 
              new Rational(2, 3).multiply(new Rational(7, 9)).toString()),
      () -> assertEquals("1/6", 
              new Rational(1, 2).multiply(new Rational(1, 3)).toString()),
      () -> assertEquals("1/48", 
              new Rational(1, 4).multiply(new Rational(1, 12)).toString()),
      () -> assertEquals("1/64", 
              new Rational(1, 8).multiply(new Rational(1, 8)).toString()),
      () -> assertEquals("1/25", 
              new Rational(1, 5).multiply(new Rational(1, 5)).toString()),
      () -> assertEquals("1/1", 
              new Rational(1, 1).multiply(new Rational(1, 1)).toString()));
  }
}
\end{lstlisting}

\enlargethispage{6\baselineskip}
\begin{lstlisting}[language=MyJava]
class Rational {

  /**
   * Multiplies two rational numbers.
   * @param r the other rational number.
   * @return the (simplified) product of this and r.
   */
  Rational multiply(Rational r) {
    return new Rational(this.NUMERATOR * r.NUMERATOR, this.DENOMINATOR * r.DENOMINATOR);
  }
}
\end{lstlisting}

\myexample{Let's now use classes to demonstrate a theoretically powerful idea: translating standard recursive methods into ones that use iteration.} 
We have seen how to mechanically translate a tail recursive method, but standard recursion was left out of the discussion. 
In general, any recursive method can be rewritten to use iteration. 
The problem we encounter with standard recursive algorithms is that they often blow up the procedure call stack, which is limited in size for most programming languages. 
What if we did not push anything to the call stack at all, and instead implement our own stack? 
In doing so, we delegate the space requirements of the recursive calls from the (call) stack to the heap, where there is orders of magnitude more memory space. This solution is neither fast nor space-efficient, but serves to show that naturally standard recursive algorithms, e.g., factorial, can still use a standard recursion algorithm, in a sense.

To create our own stack, we first need to decide what to place onto the stack. 
We know that each method call pushes an activation record, or a stack frame, to the procedure call stack containing the existing local variables and parameters. 
For the sake of simplicity, let's assume that our methods never declare local variables. 
We need a class that stores variable identifiers to values, which can be any type. 
A simple solution to the ``any type'' problem is to use the \ttt{Object} class, because all classes \emph{are} a ``kind of'' \ttt{Object}. 
So, the \ttt{StackFrame} class stores a \ttt{Map<String, Object>} as an instance variable. 
Its constructor receives no arguments because we do not know a priori how many parameters any arbitrary user of \ttt{StackFrame} will require. 
To compensate, let's design the \ttt{addParam} method that receives a \ttt{String} and an \ttt{Object}, enters those into the existing map, and returns the existing instance.\footnote{This idea resembles the \emph{builder} design pattern, which we will discuss in Chapter~\ref{chapter-modern}.} We design the method in this fashion to prevent the need to separately instantiate the frame, then add its parameters on separate lines, which would be required if \ttt{addParam} were of type void.

\begin{lstlisting}[language=MyJava]
import java.util.HashMap;
import java.util.Map;

class StackFrame {

  private Map<String, Object> PARAMS;

  StackFrame() { 
    this.PARAMS = new HashMap<>(); 
  }

  Object getParam(String s) { 
    return this.PARAMS.get(s); 
  }

  StackFrame addParam(String s, Object o) {
    this.PARAMS.put(s, o);
    return this;
  }
}
\end{lstlisting}

Now, let's translate the standard recursive \ttt{fact} method, which will receive a \ttt{BigInteger}, and return its factorial. 
Below we show the recursive version. 
From the recursive definition, we design the \ttt{factLoop} method that instantiates a \ttt{Stack<StackFrame>} to replicate the call stack. 
We begin the process by pushing the initial frame comprised of the initial input argument. 
This is followed by a variable to keep track of the ``return value,'' which should match the type of the standard recursive method (for our purposes of factorial, this is a \ttt{BigInteger}). 
Our loop continues as long as there is a stack frame to pop, and the core logic of the algorithm, namely~$n!$, is identical to our standard recursive counterpart.

%\enlargethispage{3\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

import java.util.BigInteger;

class StackFrameTester {

  @Test
  void testFact() {
    assertAll (
      () -> assertEquals(new BigInteger("1"), fact(new BigInteger("0"))),
      () -> assertEquals(new BigInteger("3628800"), fact(new BigInteger("10"))));
  }

  @Test
  void testFactLoop() {
      assertAll (
      () -> assertEquals(new BigInteger("1"), factLoop(new BigInteger("0"))),
      () -> assertEquals(new BigInteger("3628800"), factLoop(new BigInteger("10"))));
  }
}  
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.Stack;
import java.util.BigInteger;

class StackFrameDriver {

  /**
   * Computes the factorial of a BigInteger using natural recursion.
   * @param n instance of BigInteger to compute factorial of.
   * @return n!
   */
  static BigInteger fact(BigInteger n) {
    if (n.compareTo(BigInteger.ONE) <= 0) {
      return n.add(BigInteger.ONE);
    } else {
      return n.multiply(fact(n.subtract(BigInteger.ONE)));
    }
  }

  /**
   * Computes the factorial of a BigInteger n using the StackFrame approach.
   * @param n instance of BigInteger to compute factorial of.
   * @return n!
   */
  static BigInteger factLoop(BigInteger n) {
    Stack<StackFrame> sf = new Stack<>();
    BigInteger res = n;
    sf.push(new StackFrame().addParam("n", n));
    while (!sf.isEmpty()) { 
      /* TODO. */ 
    }
    return res;
  }
}
\end{lstlisting}

Turning our attention to the innards of the loop, we must accurately replicate the procedure call stack actions. 
Thus, we first pop the existing frame, extract the desired parameters to work with from its map, then perform the algorithm's logic.

\begin{lstlisting}[language=MyJava]
class StackFrameDriver {

  /**
   * Computes the factorial of a BigInteger n using the StackFrame approach.
   * @param n instance of BigInteger to compute factorial of.
   * @return n!
   */
  static BigInteger factLoop(BigInteger n) {
    Stack<StackFrame> sf = new Stack<>();
    BigInteger res = BigInteger.ONE;
    sf.push(new StackFrame().addParam("n", n));

    while (!sf.isEmpty()) {
      StackFrame f = sf.pop();
      BigInteger pn = (BigInteger) f.get("n");
      if (pn.compareTo(BigInteger.ONE) <= 0) { 
        continue;
      } else {
        sf.push(new StackFrame().addParam("n", pn.subtract(BigInteger.ONE)));
        res = res.multiply(pn);
      }
    }

    return res;
  }
}
\end{lstlisting}

Notice two things: first, we manually mimic the behavior of the call stack. 
Second, by managing the stack ourselves, we drastically increase the limit to the number of possible ``recursive calls,'' since we push instances of our \ttt{StackFrame} onto the heap. 
Theoretically, we could continuously push new ``frames'' to our stack so long as we have active and available heap memory. 
Of course, that is impossible with current hardware limitations, so in due time, with a large-enough call to \ttt{factLoop}, the JVM terminates the program with an \ttt{OutOfMemory} error. 

In the relevant test suite, we do not include tests for extraordinarily large numbers to preserve space, but we encourage the readers to try out such test cases, e.g., $100000000!$. 
We should state that these tests will not complete in a reasonable amount of time.\footnote{On an AMD Ryzen 5 3600 with 16GB of DDR4 RAM, this test did not complete within a three hour time frame.} 