\section{Classes}
From the first page, we have made prolific use of classes, but in this section we will finally venture into the inner workings of a class, and how to create our own.

\emph{Classes}\index{classes}\index{class} are blueprints for \emph{objects}\index{object}. When we create a class, we declare a new type of object. We encapsulate data and methods inside class definitions for later usage.

As we stated, we have repeatedly used classes, e.g., strings, arrays, \ttt{Scanner}, \ttt{Random}, as well as those classes from the Collections API. Until now, however, we viewed these as forms of abstraction, whose details were not important. 

To create a class, we use the \ttt{class} keyword, followed by the name of the class. The name of the class should be capitalized, and should, in general, describe a noun. All Java files describe a class and must be named accordingly. We, of course, have seen this repeatedly before, but we omitted the details.

Classes can \emph{inherit} methods from other classes, a relationship called the superclass/subclass hierarchy. For now we will only mention that the \ttt{Object} class is the ``ultimate'' superclass, in which all classes are implicit subclasses. The \ttt{Object} class, in particular, has three methods that we will override in almost every class that we write: \ttt{equals}, for comparing two classes for equality, \ttt{toString}, a means of ``stringifying'' an object, and a third: \ttt{hashCode}, the significance of which we will return to soon. In subsequent chapters we will dive more into inheritance and hierarchies.

\myexample{Let's create a class called \ttt{Point}, which stores two \ttt{int} values representing a Cartesian coordinate $x$ and $y$. By ``store,'' we mean to say that $x$ and $y$ are \emph{instance variables}\index{instance variables} of the \ttt{Point} class, also sometimes called \emph{attributes}, \emph{fields}, or \emph{members} (in Java, we conventionally use the ``instance variables'' term). Instance variables denote the values associated with an arbitrary \emph{instance} of that object (an instance may also be defined as an entity). For example, if we have a \ttt{Point} object \ttt{p}, then \ttt{p} has two instance variables, \ttt{x} and \ttt{y}, which are the $x$ and $y$ coordinates of \ttt{p}. Then, if we declare another point \ttt{p2}, then \ttt{p2} will have its own instance variables \ttt{x} and \ttt{y}, which are independent of \ttt{p}'s instance variables. In almost all circumstances, instance variables of a class should be marked as \ttt{private}. Instance variables that are \ttt{private} denotes that direct access to their values is granted only within the class definition. Lastly, for the time being, instance variables are immutable and cannot change. Thus, every instance variable will use the \ttt{final} keyword in its declaration, alongside the \ttt{UPPER\_CASE} naming convention.}

Speaking of \emph{access modifiers}\index{access modifier}, we should mention the four that Java provides, even though we make prolific use of only three:

\begin{itemize}
  \item A class, variable, or method declared with the \ttt{public} modifier is accessible to/by any other class. Variables that are \ttt{public} should be used sparingly.
  \item A class, variable, or method declared with the \ttt{private} modifier is accessible only to/by the class in which it is declared. 
  \item A class, variable, or method declared without an access modifier, also called the \emph{default access modifier}, behaves similarly to \ttt{public}, only that it is accessible only to/by classes in the same package. Packages are a means of organizing classes into groups, similar to directories.
\end{itemize}

The fourth and final access modifier is \ttt{protected}, which is similar to the default access modifier, but allows subclasses to access the variable or method.\footnote{If you have not heard of inheritance/subclasses yet, do not worry, as we will cover this in the next chapter; we explain it here to describe the relevant difference between the access modifiers.} We will not use \ttt{protected} in this text, but it is worth mentioning. As a corollary of sorts, any time that \ttt{protected} \emph{can} be used, there is almost certainly a better design alternative, whether that means marking the variable/method as \ttt{private} or \ttt{public}, we are of the opinion that \ttt{protected} has few benefits. Moreover, because we will not use \ttt{protected}, the use of \ttt{public} will be infrequent and only when necessary.\footnote{Some methods, as we will soon see and have seen previously, are required to be \ttt{public}. For example, the \ttt{main} method must be marked as \ttt{public}.}

\begin{lstlisting}[language=MyJava]
class Point {

  private final int X;
  private final int Y;
}
\end{lstlisting}

We now want a way to create an instance of a \ttt{Point}. We declare instances of objects using the \ttt{new} keyword followed by the class constructor. \emph{Constructors}\index{constructor} are special methods that are called when we wish to create a new object of that class. Our \ttt{Point} class constructor can receive parameters, which we can use to initialize the relevant $x$ and $y$ instance variables. So, let's declare the constructor for our \ttt{Point} class. Constructors, in general, should be \ttt{non-private}, as we will need to call them from outside the class definition. On a case-by-case basis, this changes accordingly, as some classes are local to another class definition and are thereby private. Constructors are also special in that they do not have a return type, although phrasing it in this way leads to some confusion, because constructors have implicit return types. By implicit, we mean that we do not directly specify the return type, but Java knows that constructors are special, whose return types are of the class itself. We create a constructor by specifying the class name alongside any desired parameters.

\begin{lstlisting}[language=MyJava]
class Point {
  
  private final int X;
  private final int Y;
  
  Point(int x, int y) {
    this.X = x;
    this.Y = y;
  }
}
\end{lstlisting}
Remember that the purpose of the constructor is to initialize the class instance variables. So, unless we wish to use distinct identifiers for referencing the parameters and instance variables, we need to use the \ttt{this} keyword.\footnote{Some software engineers and projects use identifier prefixes to refer to instance variables.} The \ttt{this} keyword refers to the current object, and aids in distinguishing between instance variables and parameters. Inside the constructor, we assign the value of the parameter \ttt{x} to the instance variable \ttt{x}. Should we opt to not use \ttt{this} on the left-hand variable identifier, then the parameter \ttt{x} would shadow the instance variable \ttt{x}, meaning that writing \ttt{x = x} assigns the parameter to itself. At last, we can create a \ttt{Point} object by calling the constructor, but wait, we have no way of accessing/referring to the instance variables of the \ttt{Point} object! We need to create \emph{accessor methods}\index{accessor method} to retrieve the values of the instance variables. Accessor methods are non-private and should do exactly one thing: return the respective instance variable.

\begin{lstlisting}[language=MyJava]
class Point {

  private final int X;
  private final int Y;
  
  Point(int x, int y) {
    this.X = x;
    this.Y = y;
  }
  
  int getX() { return this.X; }
  
  int getY() { return this.Y; }
}
\end{lstlisting}

This principle of hiding the implementation details of a class is called \emph{encapsulation}\index{encapsulation}. Encapsulation is a key principle of object-oriented programming, and is one of the primary reasons why object-oriented programming is so powerful. It can be dangerous to directly modify or access the fields of an object.\footnote{By ``dangerous,'' we mean to suggest that it is prone to logic errors.} 

Creating an instance of the \ttt{Point} class is identical to creating an instance of any other arbitrary class. Though, we should first explain a slight terminology distinction.

Declaring, or initializing, an object refers to typing the class name followed by the variable name. For instance, the following code declares a \ttt{Point} object \ttt{p}.

\begin{verbnobox}[\small]
Point p;
\end{verbnobox}

By default, $p$ points to \ttt{null}, since we have not yet created an instance of the \ttt{Point} class. We can create an instance of the \ttt{Point} class by invoking its constructor, an action otherwise called \emph{object instantiation}\index{object instantiation}. We use the \ttt{new} keyword and pass the desired $x$ and $y$ coordinates. 

\begin{verbnobox}[\small]
Point p = new Point(3, 4);
\end{verbnobox}

We should write some tests to ensure that our \ttt{Point} class is working as expected. We note that this may seem redundant for such a simple class and the fact that the accessor methods do nothing more than retrieve instance variable values, but it is a good habit for beginning object-oriented programmers.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {
  
  @Test
  void testPoint() {
    Point p = new Point(3, 4);
    assertEquals(3, p.getX());
    assertEquals(4, p.getY());
  }
}
\end{lstlisting}

Of course, testing the accessor methods is a little boring, so let's override the \ttt{toString} method to print a stringified representation of the \ttt{Point} class. Every object in Java has a \ttt{toString} method, which returns a string representation of the object. By default, the \ttt{toString} method returns the class name followed by the object's hashcode. We can override the \ttt{toString} method by declaring a \ttt{public} method with the signature \ttt{public String toString()} (note that this is one instance where \ttt{public} cannot be avoided.) We can then return a string representation of the object. In this case, we will return a string of the form \ttt{"(x=$x$, y=$y$)"}, where $x$ and~$y$ refer to the respecitve instance variables. 

\begin{lstlisting}[language=MyJava]
class Point {
  // ... previous code not shown.

  @Override
  public String toString() {
    return String.format("(x=%d, y=%d)", this.X, this.Y);
  }
}
\end{lstlisting}

Testing the \ttt{toString} method provides more interesting results, since it requires us to not only override the default implementation of \ttt{toString}, but it also ensures that our constructor correctly initializes the instance variables. Because we will refer to $p$ across several methods, we can declare it as an instance variable of our \ttt{PointTester} class so as to reduce the redundant object instantiation.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {

  private final Point P = new Point(3, 4);

  @Test
  void testPointAccessors() {
    assertEquals(3, P.getX());
    assertEquals(4, P.getY());
  }

  @Test
  void testPointToString() {
    assertEquals("(x=3, y=4)", P.toString());
  }
}
\end{lstlisting}

In addition to the \ttt{toString} method, we might also write other methods associated with a \ttt{Point} object. For example, we might want to calculate the distance between two points. We can write a \ttt{public} method that takes a \ttt{Point} object as a parameter and returns the distance between the two points, the first being the \emph{implicit parameter}, and the second being the \emph{explicit parameter}. We say the first is \emph{implicit} because, under the hood, all class methods take an implicit parameter, which is the object on which the method is called, which is accessible through \ttt{this}. We say the second is \emph{explicit} because we explicitly pass the object as a parameter. 

This is also a good time to bring up another terminology distinction. Some programming languages use \emph{functions}, others use \emph{procedures}, \emph{subroutines}, or \emph{methods}. Going from simplest to most complex, subroutines are simply a sequence of instructions that are executed in order. Procedures are subroutines that return a value. Functions are procedures that take parameters. Methods are functions that are associated with a class. In Java, we use the term \emph{method} to refer to all of these, since all methods must be associated with a class. A language like C++, on the other hand, distinguishes between the two: \emph{functions} refer to subroutines, procedures, or parameter-receiving procedures that are not associated with a class; \emph{methods} are subroutines, procedures, or functions embedded inside a class definition.

Returning to the \ttt{Point} class, we will now write \ttt{distance}, which receives a \ttt{Point} as a parameter and returns the Euclidean distance from \ttt{this} to the parameter. Before doing so, however, we should write a few tests. Conveniently, the three points that we test all have a distance of five between each other.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {

  private static final double DELTA = 0.01;

  private final Point P1 = new Point(3, 4);
  private final Point P2 = new Point(6, 8);
  private final Point P3 = new Point(0, 0);

  @Test
  void testPointDistance() {
    assertAll(
      () -> assertEquals(5, P1.distance(P2), DELTA),
      () -> assertEquals(5, p2.distance(P1), DELTA),
      () -> assertEquals(5, P1.distance(P3), DELTA),
      () -> assertEquals(5, P3.distance(P1), DELTA),
      () -> assertEquals(5, P2.distance(P3), DELTA),
      () -> assertEquals(5, P3.distance(P2), DELTA));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Point {
  // ... previous code not shown.

  /**
   * Determines the Euclidean distance between two points.
   * @param p - the other point.
   * @return the distance between this point and p.
   */
  double distance(Point p) {
    int dx = this.X - p.X;
    int dy = this.Y - p.Y;
    return Math.sqrt(dx * dx + dy * dy);
  }
}
\end{lstlisting}

The \ttt{distance} method is called an \emph{instance method} because it is associated with an instance of the class. We can also write \emph{static methods}, which are not associated with an object, but rather the class as a whole. Static methods are declared using the \ttt{static} keyword. Static methods are useful for utility methods that are not associated with a particular instance of the class. All methods designed up until this chapter were static methods, which were not associated with the class in which they resided.

\subsubsection*{Method Overloading}
A method is identified by two attributes: its name, and its signature. Java allows us to \emph{overload}\index{method overloading} a method or constructor by using the same identifier but different parameters.

\myexample{Let's overload the \ttt{distance} method by writing a version that does not receive a parameter at all, and instead returns the magnitude/distance from the point to the origin. Fortunately this is extremely easy, because we can make use of the existing \ttt{distance} method that does receive a \ttt{Point}; we can pass it the origin point, namely \ttt{new Point(0, 0)}, and everything works out wonderfully! Because this version of \ttt{distance} simply refers to the existing definition, which we have thoroughly tested, we will omit a separate tester.}

\begin{lstlisting}[language=MyJava]
class Point {
  // Previous code not shown.
  
  /**
   * Computes the distance from this point to the origin,
   * i.e., (0, 0).
   * @return returns the magnitude of this distance.
   */
   double distance() {
     return this.distance(new Point(0, 0));
   }
}
\end{lstlisting} 

We could, if desired, overload the \ttt{Point} constructor as well. Though, it makes little sense to do so in this specific instance, since a point is defined by its two coordinate members. In subsequent sections, however, we will overload the constructor and demonstrate its utility/practicality.

\myexample{Let's design the static \ttt{averageDistance} method, which receives a \ttt{List<Point>} and computes the average distance away from the origin. We already have a method to compute the distance of a point to the origin, so let's take advantage of the stream API to map \ttt{distance} to every point, then find the average of those resulting double values. This method will return an \ttt{OptionalDouble} in the event that the provided list is empty, which serves as a wrapper around the \ttt{Optional<Double>} type.}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

import java.util.List;
import java.util.Optional;
import java.util.OptionalDouble;

class PointTester {
  // ... previous code not shown.

  @Test
  void testAverageDistance() {
    List<Point> lop = List.of(
            new Point(4, 0), new Point(0, 4),
            new Point(-4, 0), new Point(0, -4),
            new Point(2, 2), new Point(-2, 2),
            new Point(-2, -2), new Point(2, -2));
    assertAll(
      () -> assertEquals(3.414, Point.averageDistance(lop).get(), 0.01),
      () -> assertEquals(OptionalDouble.empty(), Point.averageDistance(List.of())));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.List;
import java.util.OptionalDouble;

class Point {
  // ... previous code not shown. 

  /**
   * Computes the average distance to the origin of a list of points.
   * @param lop - list of points.
   * @return empty Optional if the list is empty, or OptionalDouble otherwise.
   */
  static OptionalDouble averageDistance(List<Point> lop) {
    return lop.stream()
              .map(p -> p.distance())
              .mapToDouble(d -> d)
              .average();
  }
}
\end{lstlisting}

\myexample{Let's create the static \ttt{random} method, which returns a \ttt{Point} object with random $x$ and $y$ coordinates. We will use the \ttt{Random} class to generate a random radius and angle as a polar coordinate. Then, we will convert the polar coordinate to Cartesian coordinates. Let's also add a parameter that specifies the maximum radius.}

Because the \ttt{random} method generates a random point, we cannot reasonably write a test that asserts the exact location of the point without prior knowledge of the random seed. Instead, we can write a test that asserts that the point is within a certain radius of the origin. 

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertTrue;

class PointTester {

  @Test
  void testPointRandom() {
    assertAll(
      () -> assertTrue(Point.random(10).distance() <= 10);
      () -> assertTrue(Point.random(1).distance() <= 1);
      () -> assertTrue(Point.random(5).distance() <= 5);
      () -> assertTrue(Point.random(5000000).distance() <= 5000000));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.Random;

class Point {

  /**
   * Generates a random point with a maximum radius.
   * @param maxRadius - the maximum radius.
   * @return a random point.
   */
  static Point random(double maxRadius) {
    Random r = new Random();
    double radius = r.nextDouble(maxRadius);
    double angle = r.nextDouble() * Math.PI * 2;
    int x = (int) (radius * Math.cos(angle));
    int y = (int) (radius * Math.sin(angle));
    return new Point(x, y);
  }
}
\end{lstlisting}

We have seen static methods, but what about static variables? A static variable, as we mentioned before, is a variable that is associated with the class and not a specific instance thereof. We can declare a static variable using the \ttt{static} keyword. Static variables are useful for storing information that is shared across all instances of the class. Static variables may be either \ttt{private} or non-\ttt{private}, depending on whether we want to allow direct access to the variable. As with instance variables, however, be wary of granting direct access, since it may lead to logic errors.

\myexample{Suppose we want to keep track of how many instances of \ttt{Point} have been instantiated. Since this is a property of the \ttt{Point} class rather than an instance of the class, we can declare a static variable \ttt{count} to keep track of the number of instances, which is incremented inside the constructor. To remain consistent with our recurring theme of encapsulation, \ttt{count} will be declared as \ttt{private}, and we will write a static method \ttt{getCount} to retrieve the number of instances, which is invoked on the class.\footnote{It is possible to invoke a static method on an instance of the class, but it is considered bad practice and unnecessary.} When testing, we need to be careful to only instantiate instances of \ttt{Point} when we are ready to check the status of \ttt{count}, since the static \ttt{count} variable is incremented inside the constructor.}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {

  @Test
  void testPointCount() {
    assertEquals(0, Point.getCount())
    Point p1 = new Point(3, 4);
    assertEquals(1, Point.getCount());
    Point p2 = new Point(6, 8);
    assertEquals(2, Point.getCount());
    Point p3 = new Point(0, 0);
    assertEquals(3, Point.getCount());

    // Even though we lose reference to p, the static varible still increments!
    for (int i = 0; i < 10; i++) {
      Point p = new Point();
    }
    assertEquals(13, Point.getCount());
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Point {

  private static int count = 0;

  private final int X;
  private final int Y;

  Point(int x, int y) { this.X = x; this.Y = y; count++; }

  static int getCount() { return count; }
}
\end{lstlisting}

Notice that, inside the \ttt{getCount} method, we do not refer to \ttt{count} with \ttt{this}, since \ttt{count} is a static variable and not an instance variable. Prefixing the \ttt{count} variable with \ttt{this} results in a compiler error. Further note that the variable is not marked as \ttt{final}, since it is not immutable and changes with every newly-instantiated \ttt{Point} object.

\myexample{Imagine we want to store a collection of \ttt{Point} objects in a data structure such as a \ttt{HashSet}. The question that arises from this decision is apparent: how do we determine if a \ttt{Point} is already inside the set? We need to override two important methods from \ttt{Object}: \ttt{public boolean equals} and \ttt{public int hashCode}. The \ttt{equals} method of an object determines how we wish to compare two instances of the class. In this circumstance, let's say that two points are equal according to \ttt{equals} if and only if they share the same $x$ and $y$ coordinates. Overriding the \ttt{equals} method from the \ttt{Object} class requires correctly copying the signature, the sole parameter being an \ttt{Object} that we want to check for type equality. In other words, we first want to verify that the passed object to the \ttt{equals} method is, in fact, a \ttt{Point}, otherwise they cannot possibly be equal. We can use the \ttt{instanceof} operator to our advantage. From here, if the input parameter is a \ttt{Point}, we can cast the parameter to a \ttt{Point}, then check whether or not the coordinates match. Moreover, like \ttt{toString}, the \ttt{equals} and \ttt{hashCode} methods are definitionally \ttt{public}, so do not forget the access modifier.}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;
import static Assertions.assertNotEquals;

class PointTester {

  @Test
  void testEquals() {
    assertAll(
      () -> assertEquals(new Point(3, 3), new Point(3, 3)),
      () -> assertNotEquals(new Point(3, 4), new Point(3, 7)),
      () -> assertNotEquals(new Point(7, 4), new Point(10, 4)),
      () -> assertNotEquals(new Point(10, 30), new Point(3, 7)));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Point {
  // ... previous code not shown.

  @Override
  public boolean equals(Object obj) {
    if (!(obj instanceof Point)) { return false; }
    else {
      Point othPt = (Point) obj;
      return this.x == othPt.x && this.y == othPt.y;
    }
  }
}
\end{lstlisting}

Let's try to create an instance of a \ttt{HashSet}, then iterate over the elements of the set after adding two of the same \ttt{Point} instances, i.e., points that share coordinates. Doing so demonstrates a glaring flaw: the set appears to have added both \ttt{Point} instances to the set despite their sharing of coordinates! The reason is incredibly subtle and easy to miss: the \ttt{Object} class invariant states that, if two objects are equal according to \ttt{equals}, then their hashcodes must also be equal. The hashcode of an object is simply an integer used for quick access/lookup in hashable data structures such as \ttt{HashSet} and \ttt{HashMap}. Indeed, the problem is that we forgot to override \ttt{hashCode} after overriding the \ttt{equals} method. Bloch~\cite{effectivejava} states, as a principle, that whenever we override \ttt{equals}, we should accompanyingly override the \ttt{hashCode} implementation. Now, you might wonder: ``How can I hash an object?'' Fortunately Java has a method in the \ttt{Objects} class called \ttt{hash}, which receives any number of arguments and runs them through a hashing algorithm, thereby returning the hash of the parameters. When overriding \ttt{hashCode} we should include all instance variables of the object to designate that all of the properties affect the object's hashcode. After fixing the issue, we see that our \ttt{HashSet} now correctly contains only one of the \ttt{Point} objects that we add.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertTrue;

import java.util.Set;
import java.util.HashSet;

class PointTester {

  @Test
  void testHashSetPoint() {
    Set<Point> p = new HashSet<>();
    p.add(new Point(3, 3));
    p.add(new Point(3, 3));
    assertTrue(p.size() == 1);
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.Objects;

class Point {
  // ... previous code not shown.

  @Override
  public int hashCode() {
    return Objects.hash(this.x, this.y);
  }
}
\end{lstlisting}

\myexample{Let's design the static \ttt{removeLinearPoints(List<Point> lop)} method that, when given a \ttt{List<Point>}, filters out all points that are ``linear,'' meaning that they share an $x$ and $y$ coordinate. Fortunately, as with the previous example, streams make this exercise a walk in the park. Because we overrode the \ttt{equals} definition, the comparisons by \ttt{assertEquals} will work correctly. That is, we are comparing the elements of two lists of \ttt{Point} objects. The \ttt{assertEquals} method uses the object's \ttt{.equals} method implementation for object equivalence comparisons, meaning that it will check each element of both lists to determine if they are all equivalent.}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

import java.util.List;

class PointTester {
  // ... previous code not shown. 

  @Test
  void testRemoveLinearPoints() {
    List<Point> lop = List.of(new Point(5, 10), new Point(7, 7),
                              new Point(2, 3), new Point(4, 3),
                              new Point(1, 1), new Point(-6, -10),
                              new Point(-23, -23), new Point(1, 0));
    List<Point> lopRes = List.of(new Point(5, 10), new Point(2, 3),
                                 new Point(4, 3), new Point(-6, -10),
                                 new Point(1, 0));
    assertAll(
      () -> assertEquals(List.of(), Point.removeLinearPoints(List.of())),
      () -> assertEquals(lopRes, Point.removeLinearPoints(lop)));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.List;

class Point {
  // ... previous code not shown. 

  /**
   * Returns a list of all points that are not "linear."
   * @param lop - list of Point objects.
   * @return list where linear points are removed.
   */
  static List<Point> removeLinearPoints(List<Point> lop) {
    return lop.stream()
              .filter(p -> p.getX() != p.getY())
              .toList();
  }
}
\end{lstlisting}

\myexample{Let's amplify the complexity a bit by designing a ``21'' card game, which is a card game where the players try to get a card value total of $21$ without going over. We should think about the design process of this game, namely what classes we need to create. It makes sense to start off with a \ttt{Card} class, which stores its suit and its numeric value. Because a suit is one of four possibilities, each of which uses a different symbol, we can create another class called \ttt{Suit}. In \ttt{Suit} we instantiate four static instances of \ttt{Suit}, each of which represents one of the four valid suits. Its constructor is privatized because we, as the programmers, define the four possible suits; it should not be possible for the user to define their own custom suit, at least for this particular game. The notion of \ttt{Suit} being an instance variable of \ttt{Card}, and only exists due to \ttt{Card} is called \emph{object composition}. Lastly, we will provide a method that returns an \ttt{Iterator<Suit>} over the four suit possibilities to make our lives easier when designing the \ttt{Deck} class. The method should be static so it is accessible through the class.}

\begin{lstlisting}[language=MyJava]
class Suit {

  static final Suit CLUBS = new Suit("(*;$\clubsuit$;*)");
  static final Suit DIAMONDS = new Suit("(*;$\diamondsuit$;*)");
  static final Suit HEARTS = new Suit("(*;$\heartsuit$;*)");
  static final Suit SPADES = new Suit("(*;$\spadesuit$;*)");
  static final int NUM_SUITS = 4;

  private final String S_VAL;

  private Suit(String s) { this.S_VAL = s; }

  static Iterator<Suit> iterator() {
    return new ArrayList<Suit>(List.of(CLUBS, DIAMONDS, HEARTS, SPADES))
                              .iterator();
  }

  @Override
  public String toString() { return this.S_VAL; }
}
\end{lstlisting}

Testing the \ttt{Card} class is simple and straightforward; we only need to test one method, the \ttt{toString} method, since testing \ttt{getValue}, at this point, is superfluous. We could also test the \ttt{Suit} class, but we will not do so here, given that the only useful methods are to retrieve the instance variables and the iterator.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class CardTester {

  @Test
  void testCardToString() {
    assertAll(
      () -> assertEquals("2 of (*;$\clubsuit$;*)", new Card(Suit.CLUBS, 2).toString()),
      () -> assertEquals("3 of (*;$\diamondsuit$;*)", new Card(Suit.DIAMONDS, 3).toString()),
      () -> assertEquals("4 of (*;$\heartsuit$;*)", new Card(Suit.HEARTS, 4).toString()),
      () -> assertEquals("5 of (*;$\spadesuit$;*)", new Card(Suit.SPADES, 5).toString()));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Card {

  private final Suit SUIT;
  private final int VAL;

  Card(Suit suit, int value) { this.SUIT = suit; this.VAL = value; }
  
  @Override
  public String toString() { return String.format("%d of %s", this.VAL, this.SUIT); }

  int getValue() { return this.VAL; } 
}
\end{lstlisting}

In a standard fifty-two deck of cards, some are ``special,'' e.g., the Jacks, Queens, Kings, and Ace cards. To simplify our design, these cards will be treated the same as a ``ten'' card, showing no syntactic nor semantic difference. Now that we have a class to represents cards, let's design the \ttt{Deck} class, which stores an \ttt{ArrayList<Card>} representing the current state of the deck. It also contains a static variable representing the maximum number of allowed cards. For our purposes, as we alluded to, this quantity is fifty-two. In the \ttt{Deck} constructor, we will call the \ttt{populateDeck} method, which adds four cards of the same value, but of each suit. So, to exemplify, this means that there are four cards whose value is three, where each is one of the four suits. We make use of the iterator from the \ttt{Suit} class to simplify our deck population. Only the \ttt{Deck} class needs to know how to populate an initial (empty) deck, so we privatize its implementation.

To test a \ttt{Deck}, we can write a \ttt{drawCard} method, which retrieves the ``top-most'' card on the deck to see if it is in the correct order. According to our implementation of the iterator, the top-most cards should have values of ten and be of the same suit. From there, we can draw three more cards to ensure they are of values nine, eight, and seven of the same suit. The iterator places \ttt{DIAMOND} as the final suit, so this is what we will assume in our tester. It might also be beneficial to test the \ttt{isEmpty} method, which returns \ttt{true} if the deck is empty, and \ttt{false} otherwise. We can test this functionality by drawing all fifty-two cards from the deck and ensuring that the deck is empty afterwards. Note that we draw four tens because there are no ``Kings,'' ``Queens,'' or ``Jacks'' in the deck.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;
import static Assertions.assertTrue;
import static Assertions.assertFalse;

class DeckTester {

  @Test
  void testDeckDrawCard() {
    Deck d = new Deck();
    assertAll(
      () -> assertEquals("10 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("10 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("10 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("10 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("9 of (*;$\diamondsuit$;*)", d.drawCard().toString()));
  }

  @Test
  void testDeckIsEmpty() {
    Deck d = new Deck();
    for (int i = 0; i < 52; i++) {
      assertFalse(d.isEmpty());
      d.drawCard();
    }
    assertTrue(d.isEmpty());
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.ArrayList;
import java.util.Iterator;

class Deck {

  private static final int MAX_NUM_CARDS = 52;

  private final ArrayList<Card> CARDS;

  Deck() {
    this.CARDS = new ArrayList<Card>();
    this.populateDeck();
  }

 /**
  * Retrieves a card from the "top" of the deck. If the
  * deck is empty, we return null.
  * @return the top-most card in the deck, or null if the deck is empty.
  */
  Card drawCard() {
    return this.CARDS.isEmpty() ? null : this.CARDS.remove(this.CARDS.size() - 1);
  }

  /**
   * Determines if the deck is empty.
   * @return true if the deck contains no cards, and false otherwise.
   */
  boolean isEmpty() { 
    return this.CARDS.isEmpty(); 
  }

  /**
   * Instantiates the deck to contain all 52 cards.
   * Note that the deck contains cards in-order by suit. There are 
   * no face cards in the deck, i.e., no Jack, Queen, King, nor ace.
   * All cards have a value between 1 and 10.
   */
  private void populateDeck() {
    // For every suit, create 13 cards, the last four of which all have
    // a value of ten.
    Iterator<Suit> it = Suit.iterator();
    while (it.hasNext()) {
      Suit s = it.next();
      for (int i = 1; i <= MAX_NUM_CARDS / Suit.NUM_SUITS; i++) {
        Card c = new Card(s, Math.min(10, i));
        this.CARDS.add(c);
      }
    }
  }
}
\end{lstlisting}

Hopefully the \ttt{populateDeck} method is intuitive and not intimidating. All we do is create fifty two cards, thirteen of which are of the same suit, and add them to the deck. We use the \ttt{Math.min} method to ensure that the value of the card is at most ten, since we do not have ``King,'' ``Queen,'' or ``Jack'' cards. We also use the ternary operator to check if the deck is empty before drawing a card. If the deck is empty, we return \ttt{null}.

Finally we come to the \ttt{Player} class, which stores a ``hand'' containing the cards in their possession. Fortunately this is a very straightforward definition and contains four one-line methods: \ttt{addCard}, \ttt{clearHand}, \ttt{getScore}, and \ttt{toString}. The former two are trivial to explain, as is \ttt{toString}, whereas \ttt{getScore} is the only slightly convoluted method. The idea is to return an integer that represents the total value of the cards in the player's hand. Since streams were introduced a couple of chapters ago, we will once again use them to our advantage.

\begin{lstlisting}[language=MyJava]
import java.util.ArrayList;

class Player {

  private final ArrayList<Card> HAND;

  Player() { this.HAND = new ArrayList<Card>(); }

  /**
   * Adds a card to the player's hand.
   * @param c - card to add to the player's hand.
   */
  void addCard(Card c) { this.HAND.add(c); }

  /**
   * Removes all cards from the player's hand.
   */
  void clearHand() { this.HAND.clear(); }

  /**
   * Determines the player's score.
   * @return the player's score.
   */
  int getScore() {
    return this.HAND.stream()
                    .map(c -> c.getValue())
                    .reduce(0, Integer::sum);
  }

  @Override
  String toString() {
    return String.format("Score: %d\nHand: %s\n", 
                         this.getScore(), this.HAND.toString());
  }
}
\end{lstlisting}

Using the capabilities of \ttt{Player}, \ttt{Deck}, and \ttt{Card}, we will write \ttt{TwentyOne}: the class that runs a game of ``twenty-one.'' The game logic is simple: if the game is still running, clear the player's hand, create a new deck of cards, shuffle them, and give the player two. Then, ask the player if they want to draw another card. If they do, draw a card and add it to their hand. If they do not, then the game is over. If the player's score is greater than twenty-one, then the player loses. Otherwise, the player wins. We will also write a \ttt{main} method that runs the game. We will not write any tests for this class, since it interacts with the user through the \ttt{Scanner} class.

It should be noted that this version of ``twenty-one'' only has the objective of getting as close as possible to a hand containing cards with a value that sums to twenty one, compared to a more-traditional card game where multiple players exist, with a dealer to distribute cards. As exercises, there are many ways to enhance the game, including adding a ``high score'' board to keep track of previous game outcomes, introducing CPU players to automatically poll cards from the deck to beat the main player, or even adding more human players through standard input/output iteractions. 

\begin{lstlisting}[language=MyJava]
import java.util.Scanner;

class TwentyOne {

  private static final int MAX_SCORE = 21;

  private final Player PLAYER;

  TwentyOne() { this.PLAYER = new Player(); }

  /**
   * Plays a game of "21", where the player has to draw cards until they
   * get as close to 21 as possible without going over.
   */
  void playGame() {
    Scanner in = new Scanner(System.in);
    boolean continuePlaying = true;
    while (continuePlaying) {
      // Clear the player's hand.
      this.player.clearHand();

      // Create and shuffle the deck.
      Deck d = new Deck();
      d.shuffleDeck();

      // First, deal two cards.
      this.PLAYER.addCard(d.drawCard());
      this.PLAYER.addCard(d.drawCard());

      // While the player has not "busted", ask them to draw a card or stand.
      while (this.PLAYER.getScore() <= this.MAX_SCORE) {
        System.out.println(this.PLAYER);
        System.out.println("Do you want to draw? (Y/n)");
        String resp = in.nextLine();
        if (resp.equals("Y")) { this.PLAYER.addCard(d.drawCard()); }
        else { break; }
      }

      // Print the final results of the player.
      System.out.println(this.PLAYER);
      if (this.PLAYER.getScore() > this.MAX_SCORE) {
        System.out.println("You lose!");
      } else {
        System.out.println("You did not go over!");
      }

      // Determine if we're still playing.
      System.out.println("Do you want to continue playing?");
      String resp = in.nextLine();
      continuePlaying = resp.equals("Y");
    }
  }

  public static void main(String[] args) {
    new TwentyOne().playGame();
  }
}
\end{lstlisting}

Designing interactive games is a great exercise in object-oriented programming, as well as the culmination of other discussed topics.

\myexample{Let's design the \ttt{Rational} class, which stores a rational number as a numerator and denominator. In doing so we will create methods for adding, subtracting, multiplying, and dividing rational numbers. Testing is paramount with this example, so we will be sure to write plenty. Recall the definition of a rational number: a number that can be expressed as the ratio of two integers~$p$~and~$q$, namely $p/q$. We are acutely familiar with how to perform basic operations on fractions from grade school, so we will glide through the actual mathematics and focus more on the Java implementation and class design.}

The \ttt{Rational} constructor receives two integers $p$ and $q$, and assigns them as instance variables. The \ttt{toString} method is trivial to write and only involves us adding a slash between our numerator and denominator. Though, let's back up for a second and rethink the constructor. Do we really want to be able to store fractions that are not in their simplest form? For example, do we want to allow the user to create a \ttt{Rational} object with a numerator of $2$ and a denominator of $4$? The answer is probably not, meaning that we should add a method that simplifies the fraction. We can do this by finding the greatest common divisor of the numerator and denominator, and dividing both by that value. Euclid's algorithm for finding the greatest common divisor of two integers works wonderfully here. Due to its trivial implementation and the fact that it is a tail recursive algorithm exercise from the previous chapters, we will omit its implementation.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RationalTester {
  
  @Test
  void testRationalToString() {
    assertAll(
      () -> assertEquals("1/2", new Rational(1, 2).toString()),
      () -> assertEquals("3/400", new Rational(3, 400).toString()),
      () -> assertEquals("1/1305", new Rational(5, 6525).toString()),
      () -> assertEquals("3591/46562", new Rational(7182, 93124).toString()),
      () -> assertEquals("7/32", new Rational(7, 32).toString()),
      () -> assertEquals("9388/48122", new Rational("4694/24061").toString()),
      () -> assertEquals("1/1", new Rational(1, 1).toString()));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Rational {
  
  private final long NUMERATOR;
  private final long DENOMINATOR;

  Rational(long numerator, long denominator) {
    long gcd = gcd(numerator, denominator);
    this.NUMERATOR = numerator / gcd;
    this.DENOMINATOR = denominator / gcd; 
  }

  @Override
  public String toString() {
    return String.format("%ld/%ld", this.NUMERATOR, this.DENOMINATOR);
  }
}
\end{lstlisting}

To add two rational numbers $r_1$ and $r_2$, they must share a denominator. If they do not, then we must find a common denominator by multiplying the denominators together, then multiplying the relevant numerators by the reciprocals of the denominator. For instance, if we want to add $2/3$ and $7/9$, the (not-necessarily lowest) common denominator is $3\cdot{9} = 27$. We then multiply $2$ by $9$ and $7$ by $3$ to get $18/27$ and $24/27$. Adding across the numerators results in $42/27$, which reduces to $14/9$. Since we wish to preserve the original rational number, we will write a method that returns a new \ttt{Rational} rather than modifying the one we have in-place (this also allows us to omit a step in which we simplify the resulting fraction, since the constructor takes care of this task).

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RationalTester {

  @Test
  void testRationalAdd() {
    assertAll (
      () -> assertEquals("14/9", 
                         new Rational(2, 3).add(new Rational(7, 9)).toString()),
      () -> assertEquals("5/6", 
                         new Rational(1, 2).add(new Rational(1, 3)).toString()),
      () -> assertEquals("1/3", 
                         new Rational(1, 4).add(new Rational(1, 12)).toString()),
      () -> assertEquals("1/4", 
                         new Rational(1, 8).add(new Rational(1, 8)).toString()),
      () -> assertEquals("1/8", 
                         new Rational(1, 16).add(new Rational(1, 16)).toString()),
      () -> assertEquals("1/16", 
                         new Rational(1, 32).add(new Rational(1, 32)).toString()),
      () -> assertEquals("2/1", 
                         new Rational(32, 32).add(new Rational(32, 32)).toString()));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Rational {
  // Other details not shown.

  /**
   * Adds two rational numbers.
   * @param r - the other rational number.
   * @return the (simplified) sum of this and r.
   */
  Rational add(Rational r) {
    long commonDenominator = this.DENOMINATOR * r.DENOMINATOR;
    long newNumerator = this.NUMERATOR * r.DENOMINATOR 
                        + r.NUMERATOR * this.DENOMINATOR;
    return new Rational(newNumerator, commonDenominator);
  }
}
\end{lstlisting}

Due to the correspondence to addition, we will leave \ttt{subtraction} as an exercise to the reader. We can now do multiplication, which is even simpler than addition; all that is needed is to multiply the numerators and denominators together. We will also leave \ttt{division} as an exercise to the reader. We also encourage the reader to write methods for comparing rationals for equality, as well as greater than/less than. Plus, we could extend this system to support \ttt{BigInteger} values for the numerator and denominator, which would allow us to represent arbitrarily large rational numbers. This, in turn, would require updating all methods to use \ttt{BigInteger} arithmetic, which is a good exercise in itself.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RationalTester {

  @Test
  void testRationalMultiply() {
    assertAll (
      () -> assertEquals("14/27", 
                         new Rational(2, 3).multiply(new Rational(7, 9)).toString()),
      () -> assertEquals("1/6", 
                         new Rational(1, 2).multiply(new Rational(1, 3)).toString()),
      () -> assertEquals("1/48", 
                         new Rational(1, 4).multiply(new Rational(1, 12)).toString()),
      () -> assertEquals("1/64", 
                         new Rational(1, 8).multiply(new Rational(1, 8)).toString()),
      () -> assertEquals("1/25", 
                         new Rational(1, 5).multiply(new Rational(1, 5)).toString()),
      () -> assertEquals("1/1", 
                         new Rational(1, 1).multiply(new Rational(1, 1)).toString()));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Rational {
  // ... previous code not shown.

  /**
   * Multiplies two rational numbers.
   * @param r - the other rational number.
   * @return the (simplified) product of this and r.
   */
  Rational multiply(Rational r) {
    return new Rational(this.NUMERATOR * r.NUMERATOR, 
                        this.DENOMINATOR * r.DENOMINATOR);
  }
}
\end{lstlisting}

\myexample{Let's now use classes to demonstrate a theoretically powerful idea: translating standard recursive methods into ones that use iteration. We have seen how to translate a tail recursive method, but standard recursion was left out of the discussion. In general, any recursive method can be rewritten to use iteration. The problem we encounter with standard recursive algorithms is that they often blow up the procedure call stack, of which is very limited in size for most programming languages. What if we did not push anything to the call stack at all, and instead implement our own stack? In doing so, we delegate the space requirements of the recursive calls from the (call) stack to the heap, of which there is orders of magnitude more space. This solution is neither fast nor space-efficient, but serves to show that naturally standard recursive algorithms, e.g., factorial, can still use standard recursion in a sense.}

To create our own stack, we first need to decide what goes inside the stack. We know that each method call pushes an activation record, or a stack frame, to the procedure call stack containing the existing local variables and parameters. For the sake of simplicity, let's assume that our methods never declare local variables. We need a class that stores variable identifiers to values, which can be any type. A simple solution to the ``any type'' problem is to use the \ttt{Object} class that all classes implicitly extend. So, the \ttt{StackFrame} class stores a \ttt{Map<String, Object>} as an instance variable. Its constructor receives no arguments because we do not know a priori how many parameters any arbitrary user of \ttt{StackFrame} will require. To compensate, let's write the \ttt{addParam} method that receives a \ttt{String} and an \ttt{Object}, enters those into the existing map, and returns the existing instance.\footnote{This idea resembles the \emph{builder} design pattern, which we will discuss in Chapter~\ref{chapter-modern}.} We design the method in this fashion to prevent the need to separately instantiate the frame, then add its parameters on separate lines, which would be required if \ttt{addParam} were of type void.

\begin{lstlisting}[language=MyJava]
import java.util.HashMap;
import java.util.Map;

class StackFrame {

  private Map<String, Object> PARAMS;

  StackFrame() { 
    this.PARAMS = new HashMap<>(); 
  }

  Object getParam(String s) { 
    return this.PARAMS.get(s); 
  }

  StackFrame addParam(String s, Object o) {
    this.PARAMS.put(s, o);
    return this;
  }
}
\end{lstlisting}

Now, let's translate the standard recursive \ttt{fact} method, which will receive a \ttt{BigInteger}, and return its factorial. Below we show the recursive version. From this, we write the \ttt{factLoop} method that instantiates a \ttt{Stack<StackFrame>} to replicate the call stack. We begin the process by pushing the initial frame, which stores the initial input argument. This is followed by a variable to keep track of the ``return value,'' which should match the type of the standard recursive method (for our purposes of factorial, this is a \ttt{BigInteger}). Our loop continues as long as there is a stack frame to pop, and the core logic of the algorithm, namely $n!$, is identical to our standard recursive counterpart.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

import java.util.BigInteger;

class StackFrameTester {

  @Test
  void testFact() {
    assertAll (
      () -> assertEquals(new BigInteger("1"), 
                         fact(new BigInteger("0"))),
      () -> assertEquals(new BigInteger("120"), 
                         fact(new BigInteger("5"))),
      () -> assertEquals(new BigInteger("3628800"), 
                         fact(new BigInteger("100"))),
    );
  }

  @Test
  void testFactLoop() {
      assertAll (
      () -> assertEquals(new BigInteger("1"), 
                         factLoop(new BigInteger("0"))),
      () -> assertEquals(new BigInteger("120"), 
                         factLoop(new BigInteger("5"))),
      () -> assertEquals(new BigInteger("3628800"), 
                         factLoop(new BigInteger("100"))),
    );
  }
}  
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.Stack;
import java.util.BigInteger;

class StackFrameDriver {

  static BigInteger fact(BigInteger n) {
    if (n.compareTo(BigInteger.ONE) <= 0) {
      return n.add(BigInteger.ONE);
    } else {
      return n.multiply(fact(n.subtract(BigInteger.ONE)));
    }
  }

  static BigInteger factLoop(BigInteger n) {
    Stack<StackFrame> sf = new Stack<>();
    BigInteger res = n;
    sf.push(new StackFrame().addParam("n", n));
    while (!sf.isEmpty()) { /* TODO. */ }
    return res;
  }
}
\end{lstlisting}

Turning our attention to the innards of the loop, we must accurately replicate the procedure call stack actions. Thus, we first pop the existing frame, extract the desired parameters to work with from its map, then perform the algorithm's logic.

\begin{lstlisting}[language=MyJava]
class StackFrameDriver {
  // ... previous code not shown.

  static BigInteger factLoop(BigInteger n) {
    Stack<StackFrame> sf = new Stack<>();
    BigInteger res = BigInteger.ONE;
    sf.push(new StackFrame().addParam("n", n));

    while (!sf.isEmpty()) {
      StackFrame f = sf.pop();
      BigInteger pn = (BigInteger) f.get("n");
      if (pn.compareTo(BigInteger.ONE) <= 0) { continue; }
      else {
        sf.push(new StackFrame().addParam("n", pn.subtract(BigInteger.ONE)));
        res = res.multiply(pn);
      }
    }

    return res;
  }
}
\end{lstlisting}

With this, notice two things: first, we mimic the behavior of the call stack manually. This consequently means that, unless there is a method inside that uses the stack, we never push any activation records. Second, by managing the stack ourselves, we drastically increase the limit to the number of possible ``recursive calls,'' since we push instances of our \ttt{StackFrame} onto the heap. Theoretically, we could continuously push new ``frames'' to our stack so long as we have active and available heap memory. This, of course, is impossible with current hardware limitations, so in due time, with a large-enough call to \ttt{factLoop}, the JVM terminates the program with an \ttt{OutOfMemory} exception. In the relevant test suite, we do not include tests for extraordinarily large numbers to preserve space, but we encourage the readers to try out such test cases, e.g., $100000000!$. We should state that these tests will not complete in a reasonable amount of time.\footnote{On an AMD Ryzen 5 3600 with 16GB of DDR4 RAM, this test did not complete within a three hour time frame.} 