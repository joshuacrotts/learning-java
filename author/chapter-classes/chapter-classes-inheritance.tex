\section{Inheritance}

When we introduced interfaces, we stated that they group classes that enact similar behaviors. 
\emph{Inheritance} describes an ``IS-A'' relationship between two classes. 
That is, one class~$C_1$ ``is'' another class if it extends the~$C_2$ class. 
In the example,~$C_1$ is called the \emph{subclass}, and~$C_2$ is called the \emph{superclass}. 
A subclass inherits all the non-private methods and fields from its superclass. 
Classes can only extend one class at a time, unlike other programming languages such as C++~\citep{cpp}. 

In Java, every class has an implicit superclass: \ttt{Object}, which introduced the paradigm that ``everything is an object in Java.'' 
The \ttt{Object} class serves as a barebones ``template,'' of sorts, that provides the essentials for a class definition. 
These essentials include methods for comparing one object against another via \ttt{equals}, computing the hash code via \ttt{hashCode}, and stringifying the class via \ttt{toString}. 
We have seen these three methods before in a variety of contexts, but we now elaborate on their origins.

\myexample{When inheriting from a class, as we described, all non-private properties are inherited.} 
So, let's consider an example that we have seen before: the \ttt{Point} class. As we recall, it stores~$x$ and~$y$ coordinates. 
Though, what if we want to store a ``color'' value inside the \ttt{Point} class? 
Does it make sense to modify the implementation of \ttt{Point} to now include a color? 
Absolutely not, because any existing code that makes use of \ttt{Point} presumes only knowledge of two coordinate values and not a color. 
Consequently, we should \emph{extend} the \ttt{Point} class in a new subclass called \ttt{ColorPoint}. 
Importantly, do \textbf{not} copy any code from the \ttt{Point} class into \ttt{ColorPoint}, because that defeats the purpose of class extension/inheritance. 
Our \ttt{ColorPoint} class constructor will call the superclass constructor, via \ttt{super}, to pass the provided~$x$ and~$y$ coordinates up to the superclass definition. 
Remember that \ttt{x} and \ttt{y} have private access inside \ttt{Point}, meaning \ttt{ColorPoint} cannot initialize their values directly.

In designing the \ttt{ColorPoint} class, we will override the superclass implementation of \ttt{equals}, \ttt{hashCode}, and \ttt{toString} to also include the color of the point. 
What's convenient is that we do not need to repeat the existing comparison, hash code calculation, concatenation code respectively. 
Instead, we call the superclass variant of the method via `\ttt{super.equals}' or `\ttt{super.toString}'. 
Two \ttt{ColorPoint} instances are equal according to \ttt{equals} if their colors are the same and their coordinate values are equal. 
What we mean by ``we do not need to repeat the existing comparison,'' is that the \ttt{equals} method inside \ttt{ColorPoint} should not (and will not) compare its~$x$ and~$y$ coordinates to those of the parameter.

Identical to interfaces, we should initialize an instance as its superclass, but instantiate it as a subclass type.

\begin{lstlisting}[language=MyJava]
class ColorPointTester {

  @Test
  void testColorPoint() {
    Point p1 = new ColorPoint(3, 4, "RED");
    Point p2 = new ColorPoint(4, 3, "GREEN");
    Point p3 = new ColorPoint(3, 4, "RED");
    assertAll(
      () -> assertEquals("Color=RED, [x=3, y=4]", p1.toString()),
      () -> assertEquals("Color=GREEN, [x=4, y=3]", p2.toString()),
      () -> assertEquals(p1, p3),
      () -> assertNotEquals(p1, p2));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.Objects;

class ColorPoint {

  private String color;

  ColorPoint(int x, int y, String color) {
    super(x, y);
    this.color = color;
  }

  @Override
  public boolean equals(Object o) {
    ColorPoint pt = (ColorPoint) o;
    return this.color.equals(pt.color) && super.equals(pt);
  }

  @Override
  public int hashCode() {
    return Objects.hash(this.color) + super.hashCode();
  }

  @Override
  public String toString() {
    return String.format("Color=%s, %s", this.color, super.toString());
  }
}
\end{lstlisting}

Some readers may question the need for inheritance; after all, could \ttt{Point} not be an interface and have \ttt{ColorPoint} implement said interface? 
The answer is no, because \ttt{Point} contains fields and private methods, neither of which are possible with an interface.

\myexample{Suppose we have the \ttt{Alien} class defined as follows, which can move forward by one unit and turn left by 90 degrees in some world that it resides within.\footnote{We base this example off of Karel J. Robot from~\cite{kareljrobot} and~\cite{pattiskarel}.}}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class AlienTester {

  @Test
  void testAlien() {
    Alien r1 = new Alien();
    assertAll(
      () -> r1.moveForward(),
      () -> assertEquals(1, r1.getX()),
      () -> r1.turnLeft(),
      () -> assertEquals(Alien.Direction.NORTH, r1.getDir()),
      () -> r1.moveForward(),
      () -> assertEquals(1, r1.getY()),
      () -> r1.turnLeft(),
      () -> assertEquals(Alien.Direction.WEST, r1.getDir()),
      () -> r1.moveForward(),
      () -> assertEquals(0, r1.getX()),
      () -> r1.turnLeft(),
      () -> assertEquals(Alien.Direction.SOUTH, r1.getDir()),
      () -> r1.moveForward(),
      () -> assertEquals(0, r1.getY()),
      () -> r1.turnLeft(),
      () -> assertEquals(Alien.Direction.EAST, r1.getDir()),
      () -> r1.moveForward(),
      () -> assertEquals(1, r1.getX()));
  }
}
\end{lstlisting}

%\enlargethispage{2\baselineskip}
\begin{lstlisting}[language=MyJava]
class Alien {

  enum Direction { NORTH, SOUTH, EAST, WEST };

  private int x;
  private int y;

  private Direction dir;

  Alien() {
    this.x = 0;
    this.y = 0;
    this.dir = Direction.EAST;
  }

  /**
   * Moves the alien forward by one unit in the direction it is facing.
   */
  void moveForward() {
    switch (this.dir) {
      NORTH -> this.y++;
      SOUTH -> this.y--;
      EAST -> this.x++;
      WEST -> this.x--;
    }
  }

  /**
   * Turns the alien left by 90 degrees.
   */
  void turnLeft() {
    switch (this.dir) {
      NORTH -> this.dir = Direction.WEST;
      SOUTH -> this.dir = Direction.EAST;
      EAST -> this.dir = Direction.NORTH;
      WEST -> this.dir = Direction.SOUTH;
    }
  }

  // Accessors and mutators omitted for brevity.
}
\end{lstlisting}

We defined an incredibly primitive alien class that stores its position and direction in a two-dimensional plane. 
Testing the alien, as we have done, is straightforward, but even such a simple alien must turn left three times to mimic the behavior of turning right once. 
One solution to this problem is to write the \ttt{turnRight} method directly inside \ttt{Alien}. 
Though, consider a situation where the code for \ttt{Alien}, or any arbitrary class, is hidden or immutable. 
In such circumstances, any extendability of functionality must come via another means. 

Let's extend the \ttt{Alien} class to add a \ttt{turnRight} method. 
We will call this class \ttt{RightAlien}, which adds a single method: \ttt{turnRight}. 
The other methods remain the same, since we do not want to overwrite their behavior. 
One important detail is that we invoke the superclass constructor without parameters, because the superclass (namely \ttt{Alien}) has no constructor that receives parameters. 
We invoke the superclass constructor to ensure that the~$x$,~$y$, and direction fields are initialized.\footnote{Not invoking the superclass constructor may result in a \ttt{NullPointerException} when trying to access the superclass fields, because those fields were never initialized nor instantiated.}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RightAlienTester {

  @Test
  void testMoverAlien() {
    Alien r1 = new RightAlien();
    assertAll(
      () -> r1.turnRight(),
      () -> assertEquals(RightAlien.Direction.SOUTH, r1.getDir()),
      () -> r1.turnRight(),
      () -> assertEquals(RightAlien.Direction.WEST, r1.getDir()),
      () -> r1.turnLeft(),
      () -> assertEquals(RightAlien.Direction.SOUTH, r1.getDir()));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class RightAlien extends Alien {

  RightAlien() { 
    super(); 
  }

  /**
   * Turns the Alien right by 90 degrees.
   */
  void turnRight() {
    turnLeft();
    turnLeft();
    turnLeft();
  }
}
\end{lstlisting}

Great, we can turn right with this flavor of the alien! 
Though, moving forward by one unit is absurdly slow, so let's now design the \ttt{MileMoverAlien} class, which moves ten units for every \ttt{moveForward} call. 
A mile, in this two-dimensional world, is equal to ten units. 
Because we want to override the functionality of \ttt{moveForward} from \ttt{Alien}, we must redefine the method in the subclass, and add the \ttt{@Override} annotation. 
Moreover, we define this particular version of \ttt{moveForward} in terms of \ttt{moveForward} from the superclass. 
This is a common pattern when overriding methods: we want to reuse the functionality of the superclass, but add some additional behavior. 
In this case, we want to move ten units forward, instead of one. 
In order to invoke the superclass' \ttt{moveForward}, we prefix the method call with `\ttt{super.}', rather than `\ttt{this.}'. 
Should we accidentally prefix the method call with `\ttt{this.}', we would be invoking the subclass definition of \ttt{moveForward}, resulting in an infinite loop!\footnote{Omitting `\ttt{this.}' still causes the method to infinitely loop, since not having the qualifier will cause Java to look in the current class definition.} 
One could make the argument and say that this is, in fact, a form of recursion, and while this is not incorrect, it is ``nonsensical recursion'' because the outcome is not only undesired, but it also never terminates.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;

class MileMoverAlienTester {

  @Test
  void testMileMoverAlien() {
    Alien r1 = new MileMoverAlien();
    r1.moveForward(),
    assertEquals(10, r1.getX()),
    r1.turnLeft(),
    r1.moveForward(),
    assertEquals(10, r1.getY());
  }
}
\end{lstlisting}

%\enlargethispage{4\baselineskip}
\begin{lstlisting}[language=MyJava]
class MileMoverAlien extends Alien {

  MileMoverAlien() { super(); }

  @Override
  void moveForward() {
    for (int i = 0; i < 10; i++) { super.moveForward(); }
  }
}
\end{lstlisting}

Now suppose we want a alien that ``bounces'' throughout the world. 
A bouncing alien will pick a random direction to face, then move two spots in that direction, simulating a bounce. 
Because the alien chooses a random direction, testing its implementation is difficult without predetermined knowledge of the random number generator. 
Therefore we will omit a tester for this class. 
All we must do is override the \ttt{moveForward} method, and invoke \ttt{super.moveForward} twice after facing a random direction.

\begin{lstlisting}[language=MyJava]
import java.util.Random;

class BouncerAlien extends Alien {

  private final Random RNG;

  BouncerAlien() {
    super();
    this.RNG = new Random();
  }

  @Override
  void moveForward() {
    switch (this.rand.nextInt(4)) {
      case 0: { this.setDir(Direction.NORTH); break; }
      case 1: { this.setDir(Direction.SOUTH); break; }
      case 2: { this.setDir(Direction.EAST); break; }
      case 3: { this.setDir(Direction.WEST); break; }
    }
    super.moveForward();
    super.moveForward();
  }
}
\end{lstlisting}

Why not create a world for this alien to live within, and objects to interact with or collide into? 
Let's design the \ttt{World} class, which stores a two-dimensional array of \ttt{WorldPosition} instances.
The \ttt{WorldPosition} class is a very general wrapper class to store what we will call \ttt{WorldObject} instances. 
Because a \ttt{WorldObject} is not very specific, we will expand upon its implementation with a single subclass, that being a \ttt{StarObject}. 
Stars are objects that an alien in the world can pick up and drop. 

This is a lot of information to consider, so let's back up a bit and start by designing the \ttt{WorldPosition} class. 
A \ttt{WorldPosition} contains a list of \ttt{WorldObject} instances. 
Therefore, we know that \ttt{WorldPosition} encapsulates objects that exist on that particular position. 
We also need to write the \ttt{WorldObject} class, which does nothing but acts as a placeholder for other objects to extend; one of those being \ttt{StarObject}.

We, ideally, want aliens to be able to pick and place stars on a world position. 
It is nonsensical, though, for a aliens to pick stars on a \ttt{WorldPosition} that has no existing stars. 
Therefore, in the \ttt{WorldPosition} class, we will write a method that returns the number of instances of a given object. 
Doing so raises a question of, ``How do we specify a class to count?,'' the answer to which comes via \emph{reflection}. 

Reflection is a programming language feature that allows us to inspect the structure of a class at runtime. 
We can use reflection to determine the class of an object, and then compare that class to the class we are using to search through the data structure. 
If the classes instances match (i.e., an object in the list is an instance of the desired searching class), in the case of our ``counter'' method, we increment the counter. 
To access an object's class information through reflection, we use the \ttt{getClass} method, which returns a \ttt{Class} instance. 
To receive any type of class as the parameter to a method, we parameterize the type of \ttt{Class} with a wildcard, \ttt{<?>}.

Why are we worrying about reflection in the first place? 
Would it not be easier to simply write a method that, say, returns the number of \ttt{StarObject} instances in the \ttt{WorldPosition} through perhaps an enumeration describing the type of object? 
The answer is a resounding yes, but forcing the programmer to write an enumeration just to describe the type of some class is cumbersome and unnecessary. 
Moreover, when we want to extend the functionality to include a new type, we must update the enumeration, which is an additional responsibility that may be overlooked. 
Reflection allows us to write a single method that can count the number of instances of any class, without having to continuously/repeatedly rewrite the method.

\begin{lstlisting}[language=MyJava]
class WorldObject {

  WorldObject() {}
}
\end{lstlisting}

%\enlargethispage{3\baselineskip}
\begin{lstlisting}[language=MyJava]
class StarObject extends WorldObject {
  
  StarObject() { super(); }
}
\end{lstlisting}


\begin{lstlisting}[language=MyJava]
import java.lang.Class;
import java.util.ArrayList;
import java.util.List;

class WorldPosition {

  private List<WorldObject> WORLD;

  WorldPosition() { 
    super(); 
    this.WORLD = new ArrayList<>();  
  }

  /**
   * Using streams, returns the number of occurrences 
   * of a given class type.
   * @param cls - the class to search for.
   * @return those instances of a class that exist on the position.
   */
  int count(Class<?> cls) {
    return this.WORLD.stream()
                     .filter(o -> obj.getClass().equals(cls))
                     .count();
  }
}
\end{lstlisting}

Finally we arrive at the \ttt{World} class. 
Perhaps we make it a design choice to disallow extension of this class. 
To block a class from being extended, we label it as \ttt{final}\index{final class}. 
The \ttt{World} class stores, as we stated, a two-dimensional array of \ttt{WorldPosition} instances, simulating a two-dimensional grid structure (where the plane origin lies in the top-left rather than the traditional bottom-left). 
Our constructor receives two integers denoting the number of rows and columns in the world. 
Each position in the world is directly instantiated thereof to prevent later null pointer references. 
Said \ttt{World} class contains two methods: \ttt{addObject}, and \ttt{countStars}, where the former adds an object to a given position in the world, and the latter counts the number of stars on a given position.

In Chapter~\ref{chapter-modern}, we revisit reflection and explore its potential in greater detail. 
Remember that reflection is a runtime mechanism and, consequently, program performance may be penalized in certain situations.

\begin{lstlisting}[language=MyJava]
final class World {
  
  private final WorldPosition[][] WORLD;

  World(int numRows, int numCols) {
    this.WORLD = new WorldPosition[numRows][numCols];
    for (int i = 0; i < numRows; i++) {
      for (int j = 0; j < numCols; j++) {
        this.WORLD[i][j] = new WorldPosition();
      }
    }
  }

  /**
   * Assigns a WorldObject to a given position in the world by adding
   * it to the list of objects.
   * @param obj - the object to assign.
   * @param x - the x-coordinate of the position.
   * @param y - the y-coordinate of the position.
   */
  void add(WorldObject obj, int x, int y) {
    this.WORLD[x][y].add(obj);
  }

  /**
   * Counts the number of stars on a given position in the world.
   * @param x - the x-coordinate of the position.
   * @param y - the y-coordinate of the position.
   * @return the number of stars.
   */
  int countStars(int x, int y) {
    return this.WORLD[x][y].count(StarObject.class);
  }
}
\end{lstlisting}

\myexample{Let's design a ``role hierarchy'' system for business users.} 
In this system, there are employees that have different roles. 
For instance, we have managers and developers. 
An employee may be promotable if it implements the \ttt{IPromotable} interface. 
First, let's consider the hierarchy and what properties each of these roles have to offer.

An \ttt{Employee} contains a name and a unique identifier. 
Employees can be either hourly or salaried, meaning they receive an hourly payrate or a yearly salary. 
Let's categorize these into \ttt{HourlyEmployee} and \ttt{SalaryEmployee}, where both extend the \ttt{Employee} class. 
Accordingly, the \ttt{HourlyEmployee} class stores an hourly rate, whereas the \ttt{SalaryEmployee} class stores an annual salary amount.

A \ttt{Manager} is an \ttt{Employee} (either salaried or hourly), and contains a list of \ttt{Employee} objects that they supervise. 

A \ttt{Developer} writes code in a programming language defined as a string instance variable. 
They also store an integer denoting their number of years of experience. 
Developers are strictly salaried employees. 
Also, a developer can be either ``junior'' or ``senior,'' and a junior developer is promotable to a senior developer after they have at least five years of experience.

Let's start by designing the \ttt{Employee} class. 
In addition to its properties, employees can \ttt{String work()} and must override the \ttt{toString} method. 
The \ttt{work} method is \emph{polymorphic}\index{polymorphism}\index{polymorphic}, meaning that an \ttt{Salesperson} may ``work'' differently compared to a \ttt{JuniorDeveloper}, but they both ``work,'' in essence. 
We will say that an \ttt{Employee} works by returning a string with their name and \ttt{" is working."} appended. 
The unique identifier that an employee has is generated by a statically-incremented counter variable, similar to how we counted instances of the \ttt{Point} class in Chapter~\ref{chapter-classes}.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class EmployeeTester {

  @Test
  void testEmployee() {
    Employee e1 = new Employee("Chaitrali");
    Employee e2 = new Employee("Owen");
    assertAll(
      () -> assertEquals("Chaitrali is working.", e1.work()),
      () -> assertEquals("Owen is working.", e2.work()));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Employee {

  private static int empCounter = 1;

  private String name;
  private int id;

  Employee(String name) {
    this.name = name;
    this.id = empCounter;
    Employee.empCounter++;
  }

  String work() {
    return this.name + " is working.";
  }

  @Override
  public String toString() {
    return String.format("Name=%s, ID=%d", this.name, this.id);
  } 
}
\end{lstlisting}

The \ttt{HourlyEmployee} and \ttt{SalaryEmployee} classes, as aforementioned, extend the \ttt{Employee} class, the only difference being that they also receive a hourly rate and yearly salary value respectively. 
To keep the conversation interesting, we refrain from overriding the \ttt{work} method, because there is no significant difference between how a generic \ttt{Employee} works and one of its direct subclasses work. 
By not overriding the implementation of a method, Java defaults to the existing implementation in a superclass. 
The \ttt{toString} method, on the other hand, will change to contain the hourly rate or salary, depending on the subclass.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class EmployeeTester {

  @Test
  void testHourlySalaryEmployee() {
    Employee es1 = new SalaryEmployee("Andrew", 67500);
    Employee eh1 = new HourlyEmployee("Priyanka", 42.80);
    assertAll(
      () -> assertEquals("Andrew is working.", es1.work()),
      () -> assertEquals("Priyanka is working.", eh1.work()),
      () -> assertEquals("Name=Andrew, ID=1, Salary=$67500.00", es1.toString()),
      () -> assertEquals("Name=Priyanka, ID=2, Hourly=$42.80", eh1.toString()));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class HourlyEmployee extends Employee {

  private double hrRate;

  HourlyEmployee(String name, double hrRate) {
    super(name);
    this.hrRate = hrRate;
  }

  @Override
  public String toString() {
    return String.format("%s, Hourly=%.2f", super.toString(), this.hrRate);
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class SalaryEmployee extends Employee {

  private double annualSalary;

  HourlyEmployee(String name, double annualSalary) {
    super(name);
    this.annualSalary = annualSalary;
  }

  @Override
  public String toString() {
    return String.format("%s, Salary=%.2f", super.toString(), this.annualSalary);
  }
}
\end{lstlisting}

Up next we have the \ttt{Developer} class, who programs in a language, and has two supporting subclasses: \ttt{JuniorDeveloper} and \ttt{SeniorDeveloper}. 
The difference between these two subclasses is their years of experience and whether they are a mentee or a mentor. 
Junior developers have exactly one mentor, and senior developers can have many mentees, those of which are junior developers. 
Because a \ttt{SeniorDeveloper} cannot be promoted, only the \ttt{JuniorDeveloper} class will implement the \ttt{IPromotable} interface. 
Promotion from junior to senior developer also comes with a $25\%$ raise in salary.

Upon instantiating a \ttt{JuniorDeveloper}, it must receive the \ttt{SeniorDeveloper} who is their mentor. 
Inside the \ttt{SeniorDeveloper} class, we will expose a method that adds a \ttt{JuniorDeveloper} to their list of mentees.\footnote{If this were a more robust and realistic system, we may choose to override \ttt{equals} and \ttt{hashCode} to take advantage of set lookups.}

Lastly we must account for how \ttt{SeniorDeveloper}s and \ttt{JuniorDevelopers} ``work.'' 
A senior developer works by mentoring their mentees. 
A junior developer works by writing in their programming language, mentored by whomever.

\begin{lstlisting}[language=MyJava]
import java.util.Set;

class EmployeeTester {
   
  @Test
  void testDeveloper() {
    Developer sd1 = new SeniorDeveloper("Ron", 89500, "C", 10);
    Developer d1 = new JuniorDeveloper("Calvin", 55000, "C", 1, sd1);
    Developer d2 = new JuniorDeveloper("Kushagra", 61000, "Java", 6, sd1);
    Developer d3 = new JuniorDeveloper("Tim", 57000, "C++", 2, sd1);
    assertAll(
      () -> assertEquals(Set.of(d1, d2, d3), sd1.getMentees()),
      () -> assertEquals("Ron is a senior developer mentoring Calvin, 
                          Kushagra, Tim.", sd1.work()),
      () -> assertEquals("Calvin is a junior developer working in C, 
                          mentored by Ron.", d1.work()),
      () -> assertEquals("Kushagra is a junior developer working in 
                          Java, mentored by Ron.", d2.work()),
      () -> assertEquals("Tim is a junior developer working in Java, 
                          mentored by Ron.", d3.work()),
      () -> assertEquals("Name=Ron, ID=1, Salary=$89500.00, Senior 
                          Developer in C with 10yoe", sd1.toString()),
      () -> assertEquals("Name=Calvin, ID=2, Salary=$55000.00, Junior 
                          Developer in C with 1 yoe.", d1.toString()),
      () -> assertEquals("Name=Kushagra, ID=3, Salary=$61000.00, Junior 
                          Developer in Java with 6yoe.", d3.toString()),
      () -> assertEquals("Name=Calvin, ID=4, Salary=$57000.00, Junior 
                          Developer in C++ with 2yoe", d3.toString()));
  }

  @Test
  void testJuniorDeveloperPromotion() {
    Developer d1 = new JuniorDeveloper("Cole", 75000, "Python", 6);
    Developer d = new JuniorDeveloper("Adam", 45000, "Python", 0);
    assertAll(
      () -> assertTrue(d1.promote() instanceof SeniorDeveloper),
      () -> assertFalse(d1.promote() instanceof JuniorDeveloper));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
interface IPromotable {

  Employee promote();
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Developer extends SalaryEmployee {

  private String language;
  private int yearsOfExperience;

  Developer(String name, double salary, String language, int yoe) {
    super(name, salary);
    this.language = language;
    this.yearsOfExperience = yoe;
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class SeniorDeveloper extends Developer {

  private List<JuniorDeveloper> mentees;

  Developer(String name, double salary, String language, int yoe) {
    super(name, salary, language, yoe);
    this.mentees = new ArrayList<>();
  }

  void addMentee(JuniorDeveloper jd) {
    this.mentees.add(jd);
  }

  @Override
  String work() {
    String names = mentees.stream()
                          .map(m -> m.getName())
                          .collect(Collectors.join(", "));
    return String.format("%s is a senior developer mentoring %s.", 
                         this.getName(), names);
  }

  @Override
  public String toString() {
    return String.format("%s, Senior Developer in %s with %d yoe", 
                              super.toString(), 
                              super.getLanguage(),
                              super.getYearsOfExperience());
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class JuniorDeveloper extends Developer implements IPromotable {

  private static final double RAISE_FACTOR = 1.25;
  private static final int PROMOTION_YEARS = 5;

  private SeniorDeveloper mentor;

  Developer(String name, double salary, String language, int yoe, SeniorDeveloper mentor) {
    super(name, salary, language, yoe);
    this.mentor = mentor;
    this.mentor.addMentee(this);
  }

  @Override
  public Employee promote() {
    if (super.getYearsOfExperience() >= PROMOTION_YEARS) {
      return new SeniorDeveloper(super.getName(), 
                                 super.getSalary() * RAISE_FACTOR, 
                                 super.getLanguage(), 
                                 super.getYearsOfExperience());
    } else {
      return this;
    }
  }

  @Override
  String work() {
    return String.format("%s is a junior developer working in %s, 
                          mentored by %s.", 
                         super.getName(),
                         super.getLanguage(),
                         this.mentor.getName());
  }

  @Override
  public String toString() {
    return String.format("%s, Junior Developer in %s with %dyoe", 
                          super.toString(),
                          super.getLanguage(),
                          super.getYearsOfExperience());
  }
}
\end{lstlisting}

The developer series of classes were certainly a lot to write and design. The last class, namely \ttt{Manager}, is an hourly employee who supervises any kind of employee, including other managers. Their ``work'' is that they are ``supervising'' employee names, sorted alphabetically. The only part of this that is more complex than the others is the comparator that we provide to the \ttt{TreeSet}. Because the set stores employee instances, our comparator must receive two employees, but return a comparison based on their name. Let's see what this looks like:

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class EmployeeTester {

  @Test
  void testManager() {
    HourlyEmployee m1 = new Manager("Abby", 30.00);
    m1.addDirectReport(new JuniorDeveloper("Cole", 75000, "Python", 6));
    m1.addDirectReport(new JuniorDeveloper("Adam", 45000, "Python", 0));
    m1.addDirectReport(new SalaryEmployee("Pete", 46000));
    assertAll(
      () -> assertEquals("Abby manages Adam, Cole, Pete.", 
                         m1.work()),
      () -> assertEquals("Abby, ID=1, Hourly=30.00, Manager", 
                         m1.toString()));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.Collectors;
import java.util.Set;
import java.util.TreeSet;

class Manager extends HourlyEmployee {

  private Set<Employee> EMPS;

  Manager(String name, double hrRate) {
    super(name, hrRate);
    this.EMPS = new TreeSet(new Comparator<Employee>() {
      @Override
      public int compare(Employee e1, Employee e2) {
        return e1.getName().compareTo(e2.getName());
      }
    });
  }

  void addDirectReport(Employee e) {
    this.DIRECT_REPORTS.add(e);
  }

  @Override
  String work() {
    return String.format("%s supervises %s", 
                         super.getName(),
                         this.EMPS.stream()
                                  .map(x -> x.getName())
                                  .collect(Collectors.joining(", ")));
  }

  @Override
  public String toString() {
    return String.format("%s, Manager", super.toString());
  }
}
\end{lstlisting}

\myexample{Let's design a class hierarchy for a series of Mythicritters objects. In the exotic land of Mythicritters, there are three kinds of creatures: \ttt{Mage}, \ttt{Warrior}, and \ttt{Rogue}. Beneath these, each creature can transform into a more powerful form: \ttt{Archmage}, \ttt{Berserker}, and \ttt{Assassin}.}

Mythicritters have a set number of health points, statistics about their power/strength/speed, and two kinds of ``attacks.'' 
Additionally, they have a level to indicate how strong they are. 
We will come back to the notion of an attack later. 
Finally, they also have either one or two types, which are returned via the \ttt{getTypes} method as a \ttt{Set<IType>}.\footnote{We will design \ttt{IType} in a few paragraphs.} 
Let's design the \ttt{Mythicritter} class. Aside from the accessors and mutators, we will add one instance method for adding attacks to the \ttt{Mythicritter}, as long as there are less than two. 

\begin{lstlisting}[language=MyJava]
import java.util.HashSet;
import java.util.Set; 

class Mythicritter {
  
  private int maxHealth;
  private int currentHealth;
  private int level;
  private int power;
  private Set<IAttack> attacks;

  Mythicritter(int maxHealth, int level, int power) {
    this.maxHealth = maxHealth;
    this.currentHealth = this.maxHealth;
    this.level = level;
    this.power = power;
    this.attacks = new HashSet<>();
  }

  void addAttack(Attack a) { 
    if (this.attacks.size() < 4) {
      this.attacks.add(a);
    }
  }

  Set<IType> getTypes() {
    return Set.of();
  }
}
\end{lstlisting}

As we stated, Mythicritter have attacks, or ways to combat an opponent. 
Attack have a type, a base power statistic, and a number representing how many ``uses'' that the attack has remaining. 
Each time an attack is used, its usage counter is decremented. 
Once it reaches zero, the attack can no longer be used. Attacks also inhabit exactly one type, which cannot change.

\begin{lstlisting}[language=MyJava]
class Attack {

  private final IType TYPE;
  private final int NUM_USES;
  private int remainingUses;
  private int basePower;

  Attack(String name, int numUses, int basePower, IType type) {
    this.name = name;
    this.baseDamage = baseDamage;
    this.NUM_USES = numUses;
    this.TYPE = type;
  }

  // Accessors and mutators omitted.
}
\end{lstlisting}

Finally, Mythicritters, as well as attacks, have associated types. 
Types in the world of Mythicritters are a property thereof, which affect the power of their attacks, as well as what types they are vulnerable to/strong against. 
All in all, it is akin to a game of ``Rock, paper, scissors.'' 
That is, scissors beats paper, paper beats rock, and rock beats scissors. Mythicritters and attack types work similarly: if an attack is \ttt{ZapType} and the Mythicritter it is used against is \ttt{OceanicType}, the attack is ``enhanced'' against the Mythicritter. 
The defending Mythicritter thus takes more damage than it would otherwise. 
Conversely, if an attack is \ttt{InfernoType} and the Mythicritter is \ttt{BoulderType}, the attack is ``vulnerable'' against the Mythicritter. 
The defending Mythicritter thus takes less damage than it would otherwise. 

Now, let's design a ``base interface'' that other classes implement. 
An \ttt{IType} contains two methods: \ttt{Set<IType> vulnerableTo()} and \ttt{Set<IType> strongAgainst()}, which returns sets to represent the types that a type is vulnerable to or strong against. 
These methods will call upon a data structure that we will denote as a ``type registry,'' which defines the relationships from one type to another. 
Interestingly, this means that the methods inside \ttt{IType} should have a body to reference the type registry, but in the previous section we stated that the methods of an interface must not have bodies. 
\emph{Default methods}\index{default method} of an interface, on the contrary, may have bodies, and serve as a ``default implementation'' of a method in the event that an interface does not override its definition.

\begin{lstlisting}[language=MyJava]
import java.util.Set;

interface IType {

  default Set<IType> vulnerableTo() {
    return TypeRegistry.vulnerableTo(this);
  }

  default Set<IType> strongAgainst() {
    return TypeRegistry.strongAgainst(this);
  }
}
\end{lstlisting}

Out of conciseness, let's design only three types: \ttt{ZapType}, \ttt{OceanicType}, and \ttt{FlameType}. Repeating the rock-paper-scissors analogy, zap types are strong against oceanic type but weak to flame type. Oceanic types are strong against flame type but weak to zap. Flame types are strong against zap but weak to oceanic. 

These three types, namely zap, oceanic, and flame, are designed as classes that exist solely for the purposes of instantiating exactly one instance thereof. 
Types do not need to be instantiated multiple times since they are immutable and do not contain any relevant state. 
We are taking advantage of a \emph{design paradigm} called \emph{singleton}. 
The class constructors are private to prevent outside instantiation of the types, but the sole instance is public, static, and final for global, unrestricted, and immutable access.

\begin{lstlisting}[language=MyJava]
class FlameType implements IType {

  static final IType FLAME_TYPE = new FlameType();

  private FlameType() {}
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class OceanicType implements IType {

  static final IType OCEANIC_TYPE = new OceanicType();

  private OceanicType() {}
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class ZapType implements IType {

  static final IType ZAP_TYPE = new ZapType();

  private ZapType() {}
}
\end{lstlisting}

The aforementioned type registry is a class that stores two maps of type weaknesses and strengths. 
It provides two static methods: \ttt{vulnerableTo} and \ttt{strongAgainst}, identical to the \ttt{IType} interface, which tap into the map data structures for querying.

\begin{lstlisting}[language=MyJava]
import java.util.Map;
import java.util.Set;

class TypeRegistry {

  private static final Map<IType, Set<IType>> vulnerabilities =
    Map.of(OceanicType.OCEANIC_TYPE, Set.of(ZapType.ZAP_TYPE),
           ZapType.ZAP_TYPE, Set.of(FlameType.FLAME_TYPE),
           FlameType.FLAME_TYPE, Set.of(OceanicType.OCEANIC_TYPE));

  private static final Map<IType, Set<IType>> strengths =
    Map.of(OceanicType.OCEANIC_TYPE, Set.of(FlameType.FLAME_TYPE),
           ZapType.ZAP_TYPE, Set.of(OceanicType.OCEANIC_TYPE),
           FlameType.FLAME_TYPE, Set.of(ZapType.ZAP_TYPE));

  private TypeRegistry() {};

  static Set<IType> vulnerableTo(IType t) {
    return vulnerabilities.getOrDefault(t, Set.of());
  }

  static Set<IType> strongAgainst(IType t) {
    return strengths.getOrDefault(t, Set.of());
  }
}
\end{lstlisting}

Inside the \ttt{Mythicritter} class, let's design two methods: \ttt{vulnerableTo} and \ttt{strongAgainst}, both of which invoke the type registry. 
The problem, though, is that we potentially need to take the union of two sets, since a \ttt{Mythicritter} stores a set of types. 
To compensate, we can use streams to take the union of multiple sets, which collapses the problem from handling both one and two sets independently into just handling a stream. 
To combine the sets, we can use the \ttt{flatMap} stream method, which is a higher-order method to apply a lambda expression to a list of collections, then flatten the result into a single collection. 
Namely, we take the sets of types, map the \ttt{vulnerableTo} or \ttt{strongAgainst} over those types, creating a stream of sets of types. 
These are then converted into streams themselves and then flattened into a single stream. 
Finally, we collect those results into a set. 

Before we write these two methods, however, let's actually create a \ttt{Mythicritter} instance to show off our hard work. 
Let's design the \ttt{Mage} class, which is a zap type \ttt{Mythicritter}, hence the subclass/superclass relationship. 
We will instantiate it to start off with 50 health, level 1, and have a base ``power'' statistic of 4. 
Because we must also pass the type information to the superclass constructor, we need to invoke \ttt{super(...)} with information provided from the subclass contructor in addition to the type(s). 
After creating the subclass instance, we can write tests for the type registry. 

\begin{lstlisting}[language=MyJava]
import java.util.Set;

class Mage extends Mythicritter {

  Mage(int health, int level, int power) {
    super(health, level, power);
  }

  @Override
  Set<IType> getTypes() {
    return Set.of(ZapType.ZAP_TYPE);
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

import java.util.Set;

class MythicritterTester {

  @Test
  void testMythicritter() {
    Mythicritter p1 = new Mage(50, 1, 4);
    assertAll(
      () -> assertEquals(Set.of(FlameType.FLAME_TYPE),
                         p1.weakTo()),
      () -> assertEquals(Set.of(OceanicType.OCEANIC_TYPE),
                         p1.strongAgainst()));
  }
}
\end{lstlisting}

Finally, let's represent an important component of Mythicritters: transformations! A Mythicritter can transform from one form to another. 
From this, a Mythicritter's type can change, as do its base statistics and health. 
For example, the transformation of Mage into Archmage adds the \ttt{MythicalType} to its type set. 
We can change the type that a \ttt{Mythicritter} inhabits by overriding the \ttt{getTypes} method: we retrieve the superclass type set, then add the new type earned by transforming, should it exist.

To make transformation a bit more interesting, we will design the \ttt{ITransformable} interface, which is implemented by any transformable Mythicritter. 
This interface contains two methods: \ttt{boolean canTransform()} and \ttt{Mythicritter transform()}. 
The former describes the requirements before a Mythicritter can transform, e.g., whether or not it has to be at a certain level. 
The latter \ttt{transform} method returns a new instance of the transformation if it can transform, and itself otherwise. 

Designing an interface in this way means that Mythicritters that transform once, but cannot transform thereafter must also override the methods in the \ttt{ITransformable} interface to return \ttt{false} and themselves respectively.

For contextualization, Mages transform into Archmages. A Mage can transform into an Archmage once it reaches level 30. Because \ttt{MythicalType} is almost a carbon copy of the other three types, we omit its inclusion.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class MythicritterTester {

  @Test 
  void testTransformation() {
    Mythicritter p1 = new Mage(20, 1, 4);
    Mythicritter p2 = new Mage(1000, 40, 100);
    assertAll(
      () -> assertFalse(p1.canTransform()),
      () -> assertTrue(p1.transform() instanceof Mage),
      () -> assertTrue(p2.canTransform()),
      () -> assertTrue(p2.transform() instanceof Archmage));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
interface ITransformable {

  boolean canTransform();

  Mythicritter transform();
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class Mage extends Mythicritter implements ITransformable {
  // ... previous methods not shown.

  @Override
  public boolean canTransform() {
    return this.getLevel() >= 30;
  }

  @Override
  public Mythicritter transform() {
    if (!this.canTransform()) {
      return this;
    } else {
      return new Archmage(super.getHp() * 2, super.getLevel(), super.getPower() * 3);
    }
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
import java.util.Set;
import java.util.Stream;
import java.util.Collectors;

class Archmage extends Mage implements ITransformable {

  Archmage(int health, int level, int power) {
    super(health, level, power);
  }

  @Override 
  public boolean canTransform() {
    return false;
  }

  @Override
  public Mythicritter transform() {
    return this;
  }

  @Override
  Set<Type> getTypes() {
    Stream<IType> ot = super.getTypes().stream();
    Stream<IType> nt = Set.of(MythicalTypeType.MYTHICAL_TYPE).stream();
    return Stream.concat(ot, nt)
                 .collect(Collectors.toSet());
  }
}
\end{lstlisting}

We went through all of this trouble to create a complex system, so what is its intended purpose? With a bit of work up front, we made it easy to extend this system to include new types, new kinds of Mythicritters, and much more.\footnote{We did not do anything with the attacks of a Mythicritter; this may be a good place to start expanding upon if you are interested!}