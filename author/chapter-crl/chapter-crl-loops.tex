\section{Loops}

Looping is a fundamental concept in computer programming. 
Loops allow for repetition of actions or tasks. 
As we stated in the previous section on recursion, any tail recursive algorithm may be translated into an algorithm that uses loops. 
In this section, we will describe this translation as a sequential pipeline of steps, then begin to distance ourselves from recursion when it is suboptimal.

\subsection{Translation Pipeline for Tail Recursive Methods}
\subsubsection*{A Coarse-Grained Approach}
What follows is a high-level introduction to converting from tail recursive methods to iteration. 
While you may not understand everything at first, we supplement this with a comprehensive translation schema.

Writing recursive methods is certainly fun.\footnote{The definition of ``fun'' is, of course, relative.} 
Though, recursion is not always the best approach to solve a problem according to some programmers/students. 
Many programming languages offer \emph{iteration} statements, which allow us to perform a task that we might otherwise use recursion to complete. 
Suppose we have a standard recursive \emph{fact} method. 

\begin{clrr}[]{Standard Recursive Factorial}
\begin{lstlisting}[language=MyJavaNF]
static int fact(int n) {
  if (isZero(n)) { 
    return 1; 
  } else {
    return n * fact(n - 1);
  }
}
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyJavaNF]
static int factTR(int n, 
                  int acc) {
  if (isZero(n)) { 
    return acc; 
  } else {
    return factTR(subOne(n), 
                  n * acc);
  }
}
\end{lstlisting}
\end{clrr}

The first step in converting a recursive method into its iterative counterpart is to rewrite it using tail recursion. 
Notice that, in order to ``tail-recursify'' \texttt{fact}, we had to add an extra parameter that keeps track of the ``current result.''\footnote{Some tail recursive methods need more than one extra parameter---it is a case-by-case basis.} 
We convert recursive methods into tail recursion because of their direct relation to iteration.\footnote{A method definition may already be tail recursive depending on the circumstance.} 
Let us look a little deeper into this idea and discover why the relation is true.

Our iterative version of \texttt{fact} moves all ``accumulator'' variables into the method body. 
For instance, \texttt{acc} is now declared locally within the \texttt{fact} method. 
In addition to this modification, all accumulator-to-local variables should have an ``iterative purpose statement,'' which mimics the documentation comment for the accumulator parameter.

\begin{lstlisting}[language=MyJava]
static int fact(int n) {
  // acc stores the current factorial value as n goes to zero.
  int acc = 1;
  // TODO.
}
\end{lstlisting}

Second, we must describe the syntax of a loop. 
A \texttt{while} loop is the construct of choice, and it has two components: a condition denoted as a predicate, and a body. 
The loop checks to see if the given predicate is true and, if so, executes the body of the loop. 
On the other hand, if the predicate is false, program control jumps down to immediately below the loop body. 
Each pass through the loop, it re-verifies that the predicate has not been falsified. 
Unlike expressions, however, a \texttt{while} loop itself does not resolve to a value and is therefore a statement. 
Let's continue by defining the predicate of our loop. 
To do so, we ask, then answer, the question of the base case(s) for our tail recursive method. 
As shown, the base case is true when~$n$ is zero. 
Therefore, our loop continues to execute its body as long as~$n$ is not zero. 
One tail recursive method call correlates directly with one loop iteration. 
So, let's remove the \texttt{if}/\texttt{else} statement chain, and substitute them with a loop, whose predicate is nothing more than the negated base case(s).

\begin{lstlisting}[language=MyJava]
static int fact(n) {
  // acc stores the current factorial value as n goes to zero.
  int acc = 1;
  while (!(n == 0)) {
    // TODO.
  }
}
\end{lstlisting}

Finally, we come to the heart of the loop: its body.
Within, we update variables according to how they are updated in the tail recursive call. 
Namely,~$n$ is decremented by~$1$, and $\emph{acc}$ is multiplied by~$n$. 
We must be cautious, however, because the order of these statements is significant! 
In the tail recursive method call to \texttt{fact}, the~$n$ that is decremented is passed to the method, whereas the original value of $n$ is used when multiplying by $\emph{acc}$. As a result, the accumulator update should come first.

\begin{lstlisting}[language=MyJava]
static int fact(int n) {
  // acc stores the current factorial value as n goes to zero.
  int acc = 1;
  while (!(n == 0)) {
    acc = acc * n;
    n = n - 1;
  }
}
\end{lstlisting}

We are almost done; the loop body is now complete, with each modification corresponding precisely with a piece of the tail recursive version. 
All that remains is the base case return statement. 
In our tail recursive method, once we hit the base case, we return \texttt{acc}. 
We model returning (a value) from the base case with a return statement beneath the loop.

\begin{lstlisting}[language=MyJava]
static int fact(int n) {
  // acc stores the current factorial value as n goes to zero.
  int acc = 1;
  while (!(n == 0)) {
    acc = acc * n;
    n = n - 1;
  }
  return acc;
}
\end{lstlisting}

Excellent, we now have an iterative version of the factorial method! 
Let's compare these two implementations side-by-side, color-coding their similarities. 
Base cases are \textcolor{red}{red}, accumulated variables/steps are \textcolor{darkyellow}{yellow}, and return values are \textcolor{darkgreen}{green}. 

\begin{clrr}[]{Tail Recursive versus Iterative Factorial}
\begin{lstlisting}[language=MyJavaNF]
static int fact(int n, int acc) {
  if (*;\textcolor{red}{(n == 0)};*) {
    return (*;\textcolor{darkgreen}{acc};*);
  } else {
    return fact((*;\textcolor{darkyellow}{n - 1};*), (*;\textcolor{darkyellow}{acc * n};*));
  }
}
(*;\phantom{};*)
(*;\phantom{};*)
(*;\phantom{};*)
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyJavaNF]
static int fact(int n) {
  // acc stores the current
  // factorial value as n 
  // goes to zero.
  int acc = 1;
  while (!(*;\textcolor{red}{(n == 0)};*)) {
    (*;\textcolor{darkyellow}{acc = acc * n};*);
    (*;\textcolor{darkyellow}{n = n - 1};*);
  }
  return (*;\textcolor{darkgreen}{acc};*);
}
\end{lstlisting}
\end{clrr}

\subsubsection*{A Fine-Grained Approach}
What we just saw was a fast-paced, high-level overview of the conversion process from tail recursive methods into methods that use while loops. 
Let's take a step back and slow our approach to better understand each part. 
We first want to describe a general outline of the steps-to-success in the translation pipeline. 

The goal, in due time, is to work our way from~\emph{$TR$} to~$I$, but there are a few highly important intermediary components to this process. 
Note that the lines from~$P$ to~$R$, and~$R$ to~$TR$ are not as important for this section of the transformation.

\begin{figure}[h!]
\centering
\begin{tikzpicture}
  % Define nodes for all elements
  \node (P) at (-2,0) {$P$};
  \node (R) at (-0.5,0) {$R$};
  \node (TR) at (1.2,0) {\emph{$TR$}};
  \node (TRH) at (3.2,0) {\emph{$TR_\mathbf{H}$}};
  \node (TRIVP) at (5.3,0) {\emph{$TR_\mathbf{IVP}$}};
  \node (TRC) at (8,0.7) {\emph{$TR_\mathbf{C}$}};
  \node (TRB) at (8,0) {\emph{$TR_\mathbf{B}$}};
  \node (TRRet) at (8,-0.7) {\emph{$TR_\mathbf{Ret}$}};
  \node (I) at (10,0) {$I$};

  % Draw arrows
  \draw[->] (P) -- (R) node[midway, above] {1};
  \draw[->] (R) -- (TR) node[midway, above] {2};
  \draw[->] (TR) -- (TRH) node[midway, above] {3};
  \draw[->] (TRH) -- (TRIVP) node[midway, above] {4};
  \draw[->] (TRIVP) -- (6.8,0) node[midway, above] {5};
  \draw[->] (TRC) -- (TRB);
  \draw[->] (TRB) -- (TRRet);
  
  % Draw dashed circle
  \draw[dashed] (8,0) circle (1.2);
  \draw[dashed,->] (9.2,0) -- (I);

\end{tikzpicture}
\caption{Fine-Grained Translation Pipeline}
\end{figure}

$TR$ is the tail recursive method derived either from the problem statement~$P$ or the standard recursive step~$R$. 
From here, we make our way to~\emph{$TR_\mathbf{H}$}, denoting the ``color-coding'' phase, wherein we mark the three sub components of a tail recursive method, those being the base case(s), updated variables in the tail recursive call, and returned values from the base case. 

\emph{$TR_\mathbf{IVP}$}, or ``Iterative Variable Purpose,'' is a step following the method signature, but preceding the loop definition. 
In~\emph{$TR_\mathbf{IVP}$}, we examine the updated variables/accumulators marked in~\emph{$TR_\mathbf{H}$} and localize them into variables that are not passed as arguments to a method, but rather as a sequence of value updates. 
Moreover, we add comments to these variable declarations explaining their purpose.

\emph{$TR_\mathbf{C}$} is the step wherein we write the \ttt{while} keyword, followed by the negated base case condition(s) as a series of conjunctions (i.e., logical AND).

\emph{$TR_\mathbf{B}$} is where we design the body of our loop, which contains update statements to our localized iterative variables, rather than arguments to a recursive call.

Finally, in~\emph{$TR_\mathbf{Ret}$}, we add the line to return the accumulated local variable(s). $I$ is the output translation.

\paragraph{\emph{$TR_\mathbf{H}$:}} When designing a tail recursive method, there are several values to keep in mind: base cases (i.e., terminating conditions), returned values that are not method calls, and accumulators. 
Each of these play a crucial role in the transition to~$I$, and quickly yet correctly identifying these as they fit in tail recursive methods, is paramount. 
Let us re-look at our old factorial friend to see what this entails.

%\enlargethispage{\baselineskip}
\begin{lstlisting}[language=MyJava]
static int fact(int n, int acc) {
  if (n == 0) {
    return acc;
  } else {
    return fact(n - 1, acc * n);
  }
}
\end{lstlisting}

Marking the base case(s) is usually rather simple, as they are most often the selection statements that return a value rather than a recursive method invocation. 
So, the only instance of this in the above definition is~$n == 0$, meaning we highlight it in \textcolor{red}{red}.

\begin{lstlisting}[language=MyJava]
static int fact(int n, int acc) {
  if ((*;\textcolor{red}{n == 0};*)) {
    return acc;
  } else {
    return fact(n - 1, acc * n);
  }
}
\end{lstlisting}

To coincide with the base case(s), we also want to highlight the returned values that are not recursive calls. 
Only one exists, namely~$\emph{acc}$. 
Let's highlight~$\emph{acc}$ in \textcolor{darkgreen}{green}.

\begin{lstlisting}[language=MyJava]
static int fact(int n, int acc) {
  if ((*;\textcolor{red}{n == 0};*)) {
    return (*;\textcolor{darkgreen}{acc};*);
  } else {
    return fact(n - 1, acc * n);
  }
}
\end{lstlisting}

Now, we want to highlight updated variables that are passed to the (tail) recursive call(s). 
When we say updated, we mean ``modified'' insofar as they are not copied verbatim, e.g., $f(n) = f(n)$, in which we see~$n$ remains unaltered across method calls. 
Conveniently, both~$n$ and~$\emph{acc}$ are updated ($n$ is decremented by one; $\emph{acc}$ is multiplied by~$n$). 
Let's highlight these changes in \textcolor{darkyellow}{yellow}. 

\begin{lstlisting}[language=MyJava]
static int fact(int n, int acc) {
  if ((*;\textcolor{red}{n == 0};*)) {
    return (*;\textcolor{darkgreen}{acc};*);
  } else {
    return fact((*;\textcolor{darkyellow}{n - 1};*), (*;\textcolor{darkyellow}{acc * n};*));
  }
}
\end{lstlisting}

\paragraph{\emph{$TR_\mathbf{IVP}$}:} All accumulator variables in tail recursive methods serve some purpose, one way or another, hence their necessity. 
The necessity also holds true for local variables defined as accumulator substitutions. 
Conveniently enough, every variable designated as an accumulator morphs nicely into a local variable when writing the iterative counterpart. 
Consider, once more, the tail recursive factorial definition. 
We use $\emph{acc}$ to accumulate the result as a parameter, indicating the need for an accumulator statement. 
We can simply insert this as an addendum to our Java documentation comment.

\begin{lstlisting}[language=MyJava]
/**
 * @accumulator acc stores the current factorial product. 
 */
static int fact(int n, int acc) {
  if ((*;\textcolor{red}{n == 0};*)) {
    return (*;\textcolor{darkgreen}{acc};*);
  } else {
    return fact((*;\textcolor{darkyellow}{n - 1};*), (*;\textcolor{darkyellow}{acc * n};*));
  }
}
\end{lstlisting}

In the translation to a loop, we move~$\emph{acc}$ to the body of the method, and write a similar iterative variable purpose.\footnote{By ``move,'' we mean ``remove'' but not ``delete.''} 
The value that we initialize a local accumulator variable to depends on the problem/context, but it always matches whatever value is passed to a tail recursive helper method.

\begin{lstlisting}[language=MyJava]
static int fact(int n) {
  // acc stores the current factorial product. 
  int acc = 1;
}
\end{lstlisting}

Writing these imperative variable purposes, akin to accumulator statements, help us organize what variables change and, more importantly, how they change. 

\paragraph{\emph{$TR_\mathbf{C}$}:} Up next is where we take our base case condition, highlighted in red, and insert it as the negated condition for our loop. 
First, we add the \ttt{while} keyword to our method, then follow this with a set of parentheses, and an exclamation point immediately after the opening parenthesis but before the closing parenthesis. 
Inside these parentheses, we place the base case condition. 
To be safe, one should also insert parentheses for the base case, which ensures that the correct expression is negated by the logical `not' operator. 
Follow this with an opening and closing brace set.

\begin{lstlisting}[language=MyJava]
static int fact(int n) {
  // acc stores the current factorial product. 
  int acc = 1;
  while (!(n == 0)) { 
    // TODO.
  }
}
\end{lstlisting}

\paragraph{\emph{$TR_\mathbf{B}$}:} Finally, we get to the fun part of this translation process: the body of our loop. 
We need to make a design choice of what variables to update and how they should be updated. 
We take the \textcolor{darkyellow}{yellow} highlighted tail recursive arguments, create assignment statements out of them, and insert them into the body of our loop. 
To this end, we need to follow two principles:

\textbf{Rule of Reassignment}: In any tail recursive call, if we pass an expression~$e$ which updates parameter~$p$, then in the loop body, we directly reassign~$p$ to~$e$.

\textbf{Rule of Update}: If we have two parameters~$p$ and~$q$ that are updated as part of the tail recursive call, and~$p$'s value is used as part of updating~$q$, then~$q$ must be modified before~$p$.

The rule of reassignment is straightforward: we have an expression that resolves to some value, which corresponds precisely to those highlighted arguments. 
This expression is converted into an assignment statement to the locally-declared variable. 

The rule of update, on the other hand, is not as straightforward. 
Essentially, we use this rule to ensure that variables whose value depends on another are not prematurely updated. 
Consider the following incorrect update of~$n$ before updating $\emph{acc}$:
\begin{figure}[H]
\centering
\begin{minipage}{.4\textwidth}
  \begin{align*}
  &\texttt{n = n - 1}\\
  &\texttt{acc = acc * n}
  \end{align*}
\end{minipage}%
\begin{minipage}{.4\textwidth}
\begin{tabular}{c|c|c}
Iteration \# & \texttt{n} & \texttt{acc}\\
\hline
\hline
0 & 5 & 1\\
\hline
1 & 4 & 4\\
\hline
2 & 3 & 12\\
\hline
3 & 2 & 24\\
\hline
4 & 1 & 24\\
\hline
5 & 0 & 0\\
\end{tabular}
\end{minipage}
\end{figure}

We see that this variable update ordering produces~$0$, which does not match our recursive trace! 
We receive zero thanks in part due to the final multiplication before our loop condition is falsified. 
Let's now try the other possible ordering, in which $\emph{acc}$ is updated before~$n$. 
Hence, we are now in the second attempt of completing $TR_\emph{B}$:

\begin{figure}[H]
\centering
\begin{minipage}{.4\textwidth}
  \begin{align*}
  &\texttt{acc = acc * n}\\
  &\texttt{n = n - 1}
  \end{align*}
\end{minipage}%
\begin{minipage}{.4\textwidth}
\begin{tabular}{c|c|c}
Iteration \# & \texttt{n} & \texttt{acc}\\
\hline
\hline
0 & 5 & 1\\
\hline
1 & 4 & 5\\
\hline
2 & 3 & 20\\
\hline
3 & 2 & 60\\
\hline
4 & 1 & 120\\
\hline
5 & 0 & 120\\
\end{tabular}
\end{minipage}
\end{figure}

This ordering correctly results in~$120$, which matches our recursive trace. 
Therefore, without loss of generality, we can conclude that we should update the accumulator variable before updating~$n$ in this circumstance.

Determining the correct order of update, according to the rules we specify, may take a few tries to get right. The idea is to match the result of previously-verified tail recursive traces.

\paragraph{\emph{$TR_\mathbf{Ret}$}:}
In our final translation stage, we add the necessary return statement(s) that serve to return the accumulated result from our loop. 
We highlighted these return values in \textcolor{darkgreen}{green} during the highlighting/color-coding stage.

\begin{lstlisting}[language=MyJava]
static int fact(int n) {
  // acc stores the current factorial product. 
  int acc = 1;
  while (!(n == 0)) { 
    acc = acc * n;
    n = n - 1;
  }
  return acc;
}
\end{lstlisting}

The translation pipeline is complete, and we now know how to mechanically translate a tail recursive method into one that uses a loop.

The astute reader might question the need for a tail recursion-to-iteration translation schema. 
We mentioned the term tail call optimization in the previous section on recursion, and will now explain the relation to loops.

Recall the benefit of tail recursion over standard recursion: it uses only one (replaceable) activation record. 
Though, because we can translate any tail recursive method into an iterative algorithm, we forgo the stack in its entirety.

From here we might ask a similar question: can we translate any standard recursive method into one that uses tail recursion (and by transitivity, iteration)? 
In general, the answer is yes, through a concept called \emph{continuation-passing style}\index{continuation-passing style}. 
Because of how difficult it is to implement continuations in Java, we will omit any further discussion, but interested readers should delve into functional programming if this equivalence is intriguing~\citep{eopl, tls, schemetlp}.

\myexample{Let's design the \ttt{isDisarium} method, which returns whether a given positive integer is a \textit{Disarium number}~\Citep{disarium}.}
A Disarium number is a positive integer such that the sum of its digits, where each digit is raised to the power of its position, is equal to the number itself.
For example,~$135$ is a Disarium number because $1^1+3^2+5^3 = 1+9+125=135$. 

We will design the standard recursive, tail recursive, and loop variants of the algorithm using the translation pipeline.
As usual, we should write tests for all three variants of the method, which trivially carry over to one another.
Because all three sets of tests are identical, we will only show those of the standard recursive variant.

\enlargethispage{2\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertTrue;
import static Assertions.assertFalse;

class DisariumTester {

  @Test
  void testDisariumSr() {
    assertAll(
      () -> assertTrue(isDisarium(135)),
      () -> assertTrue(isDisarium(89)),
      () -> assertFalse(isDisarium(101)),
      () -> assertFalse(isDisarium(202)),
      () -> assertFalse(isDisarium(0)),
      () -> assertFalse(isDisarium(1)));
  }
}
\end{lstlisting}

The standard recursive helper method has two parameters.
The first parameter,~$n$, is the number we are checking for ``Disarium-ness.''
The third accumulator,~$p$, is the position of the digit we are currently checking.
The helper method is also an example of the fact that the return type may differ from the driver method signature.
That is, \ttt{isDisariumSr} returns a boolean, whereas its helper method returns the sum of the digits raised to their respective positions.

\begin{lstlisting}[language=MyJava]
class Disarium {

  /**
   * Determines if a given integer is a Disarium number.
   * @param n positive integer.
   * @return true if Disarium, false otherwise.
   */
  static boolean isDisariumSr(int n) {
    return isDisariumSrHelper(n, 1) == n;
  }

  /**
   * Recursively computes the sum of the digits of n raised 
   * to their respective positions.
   * @param n positive integer.
   * @param p position of the digit that is currently being checked.
   * @return sum of digits raised to their respective positions.
   */
  private static int isDisariumSrHelper(int n, int p) {
    if (n == 0) { 
      return 0;
    } else { 
      return Math.pow(n % 10, p) 
           + isDisariumSrHelper(n / 10, p + 1); 
    }
  }
}
\end{lstlisting}

The tail recursive variant is similar to the standard recursive variant, but with an additional parameter,~$s$, which accumulates the result as a parameter.

\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
class Disarium {

  /**
   * Determines if a given integer is a Disarium number.
   * @param n positive integer.
   * @return true if Disarium, false otherwise.
   */
  static boolean isDisariumTr(int n) {
    return isDisariumTrHelper(n, 1, 0) == n;
  }

  /**
   * Tail-recursively computes the sum of the digits of n raised to 
   * their respective positions.
   * @param n positive integer.
   * @param p position of the digit that is currently being checked.
   * @param s sum of digits raised to their respective positions.
   * @return sum of digits raised to their respective positions.
   */
  private static int isDisariumTrHelper(int n, int p, int s) {
    if (n == 0) { 
      return s; 
    } else { 
      return isDisariumTrHelper(n / 10, 
                                p + 1, 
                                s + (int) Math.pow(n % 10, p)); 
    }
  }
}
\end{lstlisting}

The iterative variant is the most verbose of the three, but it is also the most efficient due to the lack of overhead from method calls.
The method uses a counter~$c$ to keep track of the position of the digit we are currently checking.

\begin{lstlisting}[language=MyJava]
class Disarium {

  /**
   * Determines if a given integer is a Disarium number.
   * @param n positive integer.
   * @return true if Disarium, false otherwise.
   */
  static boolean isDisarium(int n) {
    int c = 1;
    // s stores the sum of the digits raised to their respective positions.
    int s = 0;
    while (n != 0) {
      s += (int) Math.pow(n % 10, c);
      n /= 10;
      c++;
    }
    return s == n;
  }
}
\end{lstlisting}


\subsection{Iteration Constructs}

Perhaps the related equivalence to tail recursion is too abstract for some to digest. 
Indeed, we believe the relationship is somewhat far-fetched at first glance, but after enough practice, it becomes clearer. 
We will now discuss loops from a non-translation perspective. 
That is, if we assume the translation diagram from before, we are going straight from the problem statement~$P$ to the iterative solution~$I$, or at least, we will not design~$I$ from translating a recursive solution~$R$ or a tail recursive solution.

As we stated before, loops are statements in Java, meaning they do not, themselves, resolve to a value. 
Therefore, any and all lines of code executed inside the body of a loop must be statements rather than expressions.

\myexample{Suppose we want to print the first one hundred prime integers.} 
Recall the definition of primality: a positive integer~$n$ is prime if it is divisible by only one and itself. 
Without loops, we would otherwise solve this task using recursion. 
Although summing prime values is not a too terribly complicated task, it requires a verbose set of methods, should we choose to do it tail recursively. 
Instead, let's try and use loops to solve the problem. 
We want to continue looping until we have summed one hundred prime values. 
Fortunately, there is exactly one correct test case for this method, so writing an elaborate test suite is superfluous.

Declaring an integer counter~$c$ is mandatory. 
Our loop condition, therefore, executes so long as we have not encountered one hundred prime values. 
When designing loop conditions, we ask ourselves the question, ``What should be true after the loop?,'' and design the condition around the answer. 
Our counter~$c$ will be exactly one hundred upon loop completion, so the condition is the negated version of this expression.\footnote{Rather than \ttt{(!(c == 100))}, we can write \ttt{(c != 100)} to achieve the same effect.}

Up next, we need to write a method that determines the primality of an integer. 
We presented the definition of primality before, and it is also known mathematically that we only need to check up to~$\sqrt{n}$ for primality~\citep{riesel}. 
Let's design such a method, writing the appropriate tests. 
The loop condition is to continue so long as a variable,~$i$, is less than or equal to the square root of our input number. 
The variable~$i$ serves as a counter towards our number; if we find that~$n$ is not divisible by any numbers from two up to~$\sqrt{n}$, then it must be prime.\footnote{We cast the result of \ttt{Math.sqrt} to an integer because it returns a \ttt{double} rather than an \ttt{int} datatype.} 
Note the edge cases of zero and one, both of which are non-prime.

\begin{lstlisting}[language=MyJava]
class SumPrimes {

  /**
   * Computes the sum of the first 100 prime integers.
   * @return sum of first 100 primes.
   */
  static int sum100Primes() {
    int c = 0;
    while (c != 100) { 
      /* TODO. */ 
    }
    return 0;
  }
}
\end{lstlisting}

\enlargethispage{-3\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertTrue;
import static Assertions.assertFalse;

class PrimeTester {

  @Test
  void testPrime() {
    assertAll(
      () -> assertTrue(isPrime(101)),
      () -> assertTrue(isPrime(3)),
      () -> assertFalse(isPrime(0)),
      () -> assertFalse(isPrime(1)),
      () -> assertFalse(isPrime(2)),
      () -> assertFalse(isPrime(202)));
  }
}
\end{lstlisting}

\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
class Prime {

  /**
   * Determines if a given integer is prime.
   * @param n positive integer.
   * @return true if prime, false otherwise.
   */
  static boolean isPrime(int n) {
    if (n < 2) { 
      return false;
    } else {
      int bound = (int) Math.sqrt(n);
      int i = 2;
      while (i <= bound) {
        if (n % i == 0) { 
          return false; 
        } else { 
          i++; 
        }
      }
      return true;
    }
  }
}
\end{lstlisting}

The primality tests pass, which means we can put \ttt{isPrime} to work inside of \ttt{sum100Primes}. 
The method logic is straightforward: initialize our counter~$c$ to one. 
We also need a variable to track the last-found prime integer, so we know from where to start the search. 
We will call this variable~$l$ and initialize it to zero. 
Finally, a $\mathit{sum}$ variable accumulates the sum of each prime. 
Inside the loop, we declare another variable~$v$, which serves as the value to check for primality, taking on the value of~$l + 1$ (if it were just~$l$, it would forever check the same value for primality!). 
Run~$v$ through the \ttt{isPrime} method and, if it is prime, assign to~$l$ the value of~$v$, add~$v$ to the sum, and increment~$c$. 
Otherwise, increment~$l$ by one.\footnote{We will note that this code is overly verbose for pedagogical purposes.}
Running the code produces~$24133$: the desired answer.

\enlargethispage{2\baselineskip}
\begin{lstlisting}[language=MyJava]
class SumPrimes {

  /**
   * Computes the sum of the first 100 prime integers.
   * @return sum of first 100 primes.
   */
  static int sum100Primes() {
    int c = 0; // Counter for no. of primes.
    int l = 0; // Current "prime value".
    int sum = 0; // Running sum.
    while (c != 100) {
      int v = l + 1;
      if (isPrime(v)) {
        l = v;
        sum += v;
        c++;
      } else {
        l++;
      }
    }
    return sum;
  }
}
\end{lstlisting}

\myexample{Continuing with the theme of number theory, let's design the \ttt{isDePolignac} method, which returns whether a given positive integer is a \textit{De Polignac number}~\Citep{dePolignac}.}

A de Polignac number is an odd positive integer~$n$ that cannot be expressed as the sum of~$2^k$ and~$p$, where~$k$ is a non-negative integer and~$p$ is a prime number.
We just recently designed a method to check for primality, so we can use it when determining if a number is a de Polignac number.

This algorithm cannot be easily expressed as a standard recursive problem, because while we can decompose the problem, there is no result to accumulate; we are only checking for a condition.
So, the tail recursive method receives the value~$n$ and a value~$i$ that starts at the nearest power of two less than~$n$.
We check whether~$n - i$ is prime, and if so, we return false.
If~$i$ is equal to one, we return true, because we have exhausted all possible powers of two.
Each recursive call divides the power of two in half.
Once again, we write tests for the tail recursive variant, but omit those of the iterative algorithm.
We emphasized the tail recursive method for de Polignac numbers primarily as a means of continued practice with recursion.

\enlargethispage{1\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertTrue;
import static Assertions.assertFalse;

class DePolignacTester {

  @Test
  void testDePolignacTr() {
    assertAll(
      () -> assertTrue(isDePolignacTr(1)),
      () -> assertTrue(isDePolignacTr(959)),
      () -> assertFalse(DePolignac.isDePolignacTr(7)),
      () -> assertFalse(DePolignac.isDePolignacTr(1001)));
  }
}
\end{lstlisting}

\enlargethispage{1\baselineskip}
\begin{lstlisting}[language=MyJava]
class DePolignac {
  
  /**
   * Determines if a given integer is a De Polignac number.
   * @param n positive integer.
   * @return true if De Polignac, false otherwise.
   */
  static boolean isDePolignacTr(int n) {
    int nextPower = (int) Math.pow(2, (int) (Math.log(n) / Math.log(2)));
    return isDePolignacTrHelper(n, 1);
  }
  
  /**
   * Tail recursive helper method for De Polignac number.
   * @param n positive integer.
   * @param i power of two to check, starts at nearest power of 2 < n.
   * @return true if De Polignac, false otherwise.
   */
  private static boolean isDePolignacTrHelper(int n, int i) {
    if (n % 2 == 0) { return false; }
    else if (i <= 1) { return true; }
    else if (isPrime(n - i)) { return false; }
    else { return isDePolignacTrHelper(n, i / 2); }
  }
}
\end{lstlisting}

The loop counterpart localizes the accumulator into a variable~$i$ that starts at the nearest power of two less than~$n$.

\begin{lstlisting}[language=MyJava]
class DePolignac {

  /**
   * Determines if a given integer is a De Polignac number.
   * @param n positive integer.
   * @return true if De Polignac, false otherwise.
   */
  static boolean isDePolignac(int n) {
    if (n % 2 == 0) { 
      return false; 
    } else {
      int i = (int) Math.pow(2, (int) (Math.log(n) / Math.log(2)));
      while (i > 1) {
        if (isPrime(n - i)) { 
          return false; 
        } else { 
          i /= 2; 
        }
      }
      return true;
    }
  }
}
\end{lstlisting}

\myexample{Suppose that we want to compute the sum of the first~$n$ odd reciprocals.} 
That is, $\frac{1}{1} + \frac{1}{3} + \frac{1}{5} + \cdots + \frac{1}{(2n-1)}$. 
Again, we might choose to this recursively, but let's try and design an iterative algorithm from the start.
Its signature is straightforward: the method receives some integer~$n$, and compute the sum of~$n$ odd reciprocals. 
Our tests are trivial to write with the employment of a calculator.

\enlargethispage{-1\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class OddReciprocalSumTester {

  static final double DELTA = 0.001;

  @Test
  void testOddRecipSum() {
    assertAll(
      () -> assertEquals(1.67619, oddRecipSum(4), DELTA),
      () -> assertEquals(0, oddRecipSum(0), DELTA),
      () -> assertEquals(1, oddRecipSum(1), DELTA),
      () -> assertEquals(2.26435, oddRecipSum(13), DELTA));
  }
}
\end{lstlisting}

The implementation is similarly simple: we create a counter~$c$ that increments so long as~$c$ is not equal to~$n$, accumulating the~$\emph{sum}$ of~$1$ divided by~$2c-1$.

%\enlargethispage{\baselineskip}
\newpage %ugh
\begin{lstlisting}[language=MyJava]
class OddReciprocalSum {

  /**
   * Computes the sum of the first n odd reciprocals.
   * @param n number of reciprocals to compute.
   * @return sum of first n odd reciprocals.
   */
  static double oddRecipSum(int n) {
    int c = 0;
    double sum = 0;
    while (c != n) {
      sum += c / (double) (2 * c - 1)
      c++;
    }
    return sum;
  }
}
\end{lstlisting}

Note the cast of the denominator from an \ttt{int} to a \ttt{double}; what happens if we omit the cast? 
Our tests would fail, because dividing two integers produces another integer, which is not desired when all of our numbers are less than or equal to one.\footnote{Equivalently, we might multiply~$c$ by~$2.0$, or subtract~$1.0$; all of these \emph{coerce}\index{type coercion}\index{coerce} the \ttt{int} into a \ttt{double}, thereby allowing correct division.}

While loops are reserved for when we do not know the point of termination. 
Thus far, all methods that we have written use predictable termination cases; we increment a counter until hitting an upper-bound. 
The \ttt{while} loop is unnecessary in these circumstances due to the equivalent \ttt{for} construct.

With a \ttt{for} loop, we supply to it three constructs: an \emph{initializer statement}, a conditional expression, and a \emph{step statement}.
We have previously seen conditional expressions being that they are the basis for our \ttt{while} loop condition. 
An initializer statement, as its name suggests, declares a variable and initializes it to a value. 
Stepping statements determine how to change a value between iterations of the loop. 
In our \ttt{while} loops, notice how we always increment the counter by one at the end of the loop body. 
Stepping statements take care of this action for us, reducing the need for such simple statements in the loop body.

\myexample{Suppose we want to design a method that returns the sum of the integers between two integers~$a$ and~$b$, inclusive.} 
We know a priori how many integers there are between~$a$ and~$b$, assuming~$a \leq b$, so we should use a \ttt{for} loop to solve this problem.
Namely, we want to iterate from~$i = a$ so long as~$i \leq b$. 
We use the variable~$i$ out of convention; one could easily use any other unused identifier.

\enlargethispage{1\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class SumIntervalTester {

  @Test
  void testSumInterval() {
    assertAll(
      () -> assertEquals(0, sum(5, 0)),
      () -> assertEquals(0, sum(0, 0)),
      () -> assertEquals(55, sum(0, 10)),
      () -> assertEquals(55, sum(1, 10)),
      () -> assertEquals(110, sum(5, 15)));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class SumInterval {

  /**
   * Computes the sum of the integers between a and b inclusive.
   * @param a lower-bound inclusive.
   * @param b upper-bound inclusive.
   * @return sum of values.
   */
  static int sum(int a, int b) {
    if (a > b) { 
      return 0; 
    } else {
      int sum = 0;
      for (int i = a; i <= b; i++) { 
        sum += i; 
      }
      return sum;
    }
  }
}
\end{lstlisting}

\myexample{Let's write an example of an unpredictable loop; one that best suits the use of \ttt{while}.} 
Suppose we want to manually compute the square root of some positive value, i.e., without Java's implementation. 
A simple algorithm to use is \emph{Newton's Approximation}:

\[
    g_{x+1} = \dfrac{\left(g_x + \dfrac{n}{g_x}\right)}{2}
\]

Where~$g_x$ is called a ``guess.'' 
The idea is to continuously apply the Newton's Approximation formula until we are ``close enough'' to the square root. 
``Close-enough'' is a heuristic whose value, when very small, increases the running time of our loop. 
Small values of~$g_x$ indicate a closer approximation to the true square root of~$n$. 
For instance, suppose~$n=64$ and~$\Delta=0.1$. 
Applying the formula (initializing~$g_0$ to~$n$) gets us the following trace:

\begin{align*}
g_1 &= \dfrac{\left(64 + \dfrac{64}{64}\right)}{2} &= 32.500\\
g_2 &= \dfrac{\left(32.5 + \dfrac{64}{32.5}\right)}{2} &= 17.234\\
g_3 &= \dfrac{\left(17.234 + \dfrac{64}{17.234}\right)}{2} &= 10.474\\
g_4 &= \dfrac{\left(10.474 + \dfrac{64}{10.474}\right)}{2} &= 8.2921\\
g_5 &= \dfrac{\left(8.2921 + \dfrac{64}{8.2921}\right)}{2} &= 8.0051\\
\end{align*}

At each iteration, we square the current guess and determine if the absolute difference between it and~$n$ is less than the guess. 
When so, that iteration of~$g_x$ is the square root approximation. 
Otherwise, we continue to approach the square root value. 
We cannot reasonably predict when this will occur (that is, how many iterations are necessary), so we use a \ttt{while} loop. 
Because there are multiple potential points of failure in this algorithm, we make sure to write an extensive test suite. 
The method itself is a re-telling of the mathematical definition with bits of Java syntax sprinkled about. 

%\enlargethispage{2\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class NewtonApproximationTester {

  final double DELTA = 0.1;

  @Test
  void testNewtonApproximation() {
    assertAll(
      () -> assertEquals(Math.sqrt(0), sqrtApprox(0, DELTA)),
      () -> assertEquals(Math.sqrt(1), sqrtApprox(1, DELTA)),
      () -> assertEquals(Math.sqrt(3), sqrtApprox(3, DELTA)),
      () -> assertEquals(Math.sqrt(16), sqrtApprox(16, DELTA)),
      () -> assertEquals(Math.sqrt(64), sqrtApprox(64, DELTA)),
      () -> assertEquals(Math.sqrt(256), sqrtApprox(256, DELTA)),
      () -> assertEquals(Math.sqrt(4000), sqrtApprox(4000, DELTA)),
      () -> assertEquals(Math.sqrt(129500), sqrtApprox(1295000, DELTA)));
  }
}
\end{lstlisting}

\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
class NewtonApproximation {

  /**
   * Computes an approximation of the square root of
   * a number using Newton's Approximation algorithm.
   * @param n number to square root.
   * @param delta approximation range.
   * @return approximation of sqrt of n.
   */
  static double sqrtApprox(double n, double delta) {
    double g = n;
    // As long as the guess is too far from the real value...
    while (Math.abs(g * g - n) > delta) {
      g = (g + (n / g)) / 2;
    }
    return g;
  }
}
\end{lstlisting}

To decrease the level of accuracy, we should pass a different value for the~$\mathit{delta}$ argument. 
Conversely, to see a higher level of precision, a~$\mathit{delta}$ that is closer (but not equal to) to zero is necessary. 
Our implementation of the square root algorithm is far from optimal, but it exists to demonstrate the unapparent necessity of \ttt{while} loops. 
Though, it is important to note that, the power of both \ttt{for} and \ttt{while} is largely irrelevant when we concern ourselves only with their semantics; they are equal in their expressibility.
This means that any \ttt{for} loop is representable with a \ttt{while} and vice-versa. 
Depending on the circumstance, however, one might be preferable over the other. 
We reiterate that \ttt{for} loops should be used when we know how many iterations there are for a certain task, whereas \ttt{while} loops are for indeterminate termination conditions. 

\myexample{Let's design the \ttt{generateAcronym} method, which returns the acronym of a given string.}
For our purposes, an acronym is the first letter of each word in a string, where words are strings separated by a single space. 
No other kinds of strings will be present in the input, e.g., strings with multiple spaces between words, nor leading/trailing spaces.

The idea behind the recursive algorithm is to keep track of when we are at the beginning of a word.
We can do this by checking if the current character is a space, and if so, we know that the next character is the beginning of a word, meaning we should add it to the acronym.
The base case is when we reach the end of the string, at which point we return the empty string.
Our standard recursive method needs a helper method to keep track of whether we are at the beginning of a word.
The acronym itself is constructed via a series of concatenating recursive calls.

\enlargethispage{2\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class GenerateAcronymTester {

  @Test
  void testGenerateAcronym() {
    assertAll(
      () -> assertEquals("gafia, generateAcronym("get away from it all")),
      () -> assertEquals("NESW", generateAcronym("Never Eat Soggy Waffles")),
      () -> assertEquals("abc", generateAcronym("a b c")),
      () -> assertEquals("LOL", generateAcronym("laugh out loud")),
      () -> assertEquals("W", generateAcronym("Word")));
  }
}
\end{lstlisting}

% \newpage  %ugh
\begin{lstlisting}[language=MyJava]
class GenerateAcronym {

  /**
   * Generates the acronym of a given string.
   * @param s string to generate acronym from.
   * @return acronym of s.
   */
  static String generateAcronym(String s) { 
    return genAcronymHelper(s, true); 
  }

  /**
   * Recursively generates the acronym of a given string.
   * @param s string to generate acronym from.
   * @param isStart true if at the beginning of a word.
   * @return acronym of s.
   */
  private static String genAcronymHelper(String s, boolean isStart) {
    if (s.isEmpty()) { return "";  } 
    else if (isStart) { return s.charAt(0) + genAcronymHelper(s.substring(1), false); } 
    else if (s.charAt(0) == ' ') { return genAcronymHelper(s.substring(1), true); } 
    else { return genAcronymHelper(s.substring(1), false); }
  }
}
\end{lstlisting}

As is usual with tail recursive methods, we need to keep track of the state of the algorithm via an accumulator.
So, the tail recursive method has an additional parameter,~$\emph{acc}$, which is the acronym we are building.

\begin{lstlisting}[language=MyJava]
class GenerateAcronym {

  /**
   * Generates the acronym of a given string.
   * @param s string to generate acronym from.
   * @return acronym of s.
   */
  static String generateAcronymTr(String s) {
    return genAcronymTrHelper(s, true, "");
  }

  /**
   * Tail-recursively generates the acronym of a given string.
   * @param s string to generate acronym from.
   * @param isStart true if at the beginning of a word.
   * @param acc accumulator for acronym.
   * @return acronym of s.
   */
  private static String genAcronymTrHelper(String s, boolean isStart, String acc) {
    if (s.isEmpty()) { 
      return acc; 
    } else if (isStart) { 
      return genAcronymTrHelper(s.substring(1), false, acc + s.charAt(0)); 
    } else if (s.charAt(0) == ' ') { 
      return genAcronymTrHelper(s.substring(1), true, acc); 
    } else { 
      return genAcronymTrHelper(s.substring(1), false, acc); 
    }
  }
}
\end{lstlisting}

If we follow the translation pipeline, we observe that, yet again, the iterative algorithm is a straightforward conversion of the tail recursive method. 
We can make the iterative method more efficient by using a \ttt{StringBuilder} to accumulate the acronym, rather than concatenating strings.
We could similarly reduce the number of lines in the method by using a \ttt{for} loop and not invoke \ttt{substring} in every branch of the conditional, but we will keep the code as is for relation to the tail recursive method and the translation pipeline.

As a word of caution, however, if we choose to update the string~$s$ \emph{before} updating the accumulator, we run into a problem imposed by the rule of update: we lose the first character of the string, which is the character we want to add to the acronym. 
Thus, we must update the accumulator \emph{before} updating the string.

\newpage %ugh
\begin{lstlisting}[language=MyJava]
class GenerateAcronym {

  /**
   * Generates the acronym of a given string.
   * @param s string to generate acronym from.
   * @return acronym of s.
   */
  static String generateAcronym(String s) {
    String acc = "";
    boolean isStart = true;
    while (!(s.isEmpty())) {
      if (isStart) { 
        acc = acc + s.charAt(0);
        isStart = false; 
        s = s.substring(1);
      } else if (s.charAt(0) == ' ') { 
        isStart = true; 
        s = s.substring(1);
      } else {
        isStart = false;
        s = s.substring(1);
      }
    }
    return acc;
  }
}
\end{lstlisting}

\myexample{We will write one more example of first writing a recursive algorithm, then its tail recursive version, then its iterative counterpart to describe a problem that occurs when translating specific tail recursive algorithms.} 
Suppose we want to write a method to determine the~$n^\text{th}$ Fibonacci number. 
The \emph{Fibonacci sequence} is defined recursively as follows:
\begin{align*}
  \emph{Fib}(0) &= 0\\
  \emph{Fib}(1) &= 1\\
  \emph{Fib}(n) &= \emph{Fib}(n - 1) + \emph{Fib}(n - 2)
\end{align*}
Writing tests for a Fibonacci algorithm is trivial to do and propagates through to the other variants. 
So, writing tests for the standard recursive algorithm, assuming they are correct, allows us to easily propagate tests for the tail recursive and iterative algorithms.

\enlargethispage{\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class FibonacciTester {

  @Test
  void testFib() {
    assertAll(
      () -> assertEquals(0, fib(0)),
      () -> assertEquals(1, fib(1)),
      () -> assertEquals(1, fib(2)),
      () -> assertEquals(8, fib(5)),
      () -> assertEquals(55, fib(10)));
  }
}
\end{lstlisting}

The standard recursive algorithm is trivial to write, but is also horribly inefficient. 
Because we make two recursive calls to $\emph{Fib}$, we end up computing the same data multiple times, resulting in an \emph{exponential time algorithm}\index{exponential time}. 
In other words, small inputs, e.g., $\emph{Fib}(40)$, will take an absurdly long time to finish.

\begin{lstlisting}[language=MyJava]
class Fibonacci {

  static int fib(int n) {
    if (n <= 1) { 
      return n; 
    } else { 
      return fib(n - 1) + fib(n - 2); 
    }
  }
}
\end{lstlisting}

Our method works and all tests pass, which is great, but we can do better by using tail recursion. 
The tail recursive variant, however, is slightly more complicated than prior tail recursive definitions, due to the need to use two accumulators. 
We use two variables to compute the ``next'' Fibonacci number: the previous, and the previous' previous. 
So, storing these values as variables, say,~$a$ and~$b$, is sensible, where~$a$ is the ``previous' previous,'' and~$b$ is the previous. 
Thus, when making a tail recursive call, we assign~$b$ as~$a + b$, and~$a$ as~$b$. 
We cannot forget the driver method!

\enlargethispage{2\baselineskip}
\begin{lstlisting}[language=MyJava]
class Fibonacci {

  static int fibTR(int n) {
    return fibHelp(n, 0, 1);
  }

  /**
   * Computes the nth Fibonacci number using tail recursion.
   * @param n nth Fibonacci number.
   * @accumulator a - "previous' previous" fib.
   * @accumulator b - "previous" fib.
   * @return result.
   */
  static int fibHelp(int n, int a, int b) {
    if (n == 0) {
      return a;
    } else if (n == 1) {
      return b;
    } else {
      return fibHelp(n - 1, b, a + b);
    }
  }
}
\end{lstlisting}

Our tail recursive implementation has two base cases instead of one due to the two base cases of the mathematical recursive definition. 
It may be difficult to visualize the initial accumulator values (i.e., the starting values of~$a$ and~$b$), but just consider the base case(s) of the standard recursive algorithm, and let this/these guide your decision.

Finally we arrive at the iterative algorithm. 
To avoid any confusion in the conversion process, we will use our translation pipeline. 
Skipping a few steps up to $TR_\textbf{C}$:

\begin{clrr}[]{Initial Translation of Fibonacci \emph{$TR$} To $I$}
\begin{lstlisting}[language=MyJavaNF]
static int fibHelp(int n, int a, int b) {
  if ((*;\textcolor{red}{n == 0};*)) {
    return (*;\textcolor{darkgreen}{a};*);
  } else if ((*;\textcolor{red}{n == 1};*)) {
    return (*;\textcolor{darkgreen}{b};*);
  } else {
    return fibHelp((*;\textcolor{darkyellow}{n - 1};*), (*;\textcolor{darkyellow}{b};*), (*;\textcolor{darkyellow}{a + b};*));
  }
}
\end{lstlisting}
\tcblower
\begin{lstlisting}[language=MyJavaNF]
static int fib(int n) {
  // Holds the previous' prev.
  int a = 0;
  // Holds the prev.
  int b = 1;
  while (???) {
    // TODO.
  }
}
\end{lstlisting}
\end{clrr}

The question now is, what do we use as the \ttt{while} loop condition? 
We are obviously decreasing~$n$ by one with each (tail) recursive call, but since we have two base cases, what do we do? 
Realistically, we only need to use the loop for one base case: namely~$n == 1$, since the only other possibility for~$n$ is if it is zero (meaning that we return zero). 
Therefore, our loop conditional is the negated condition of~$n == 1$, namely $(!(n == 1))$. 
At this point, we run into another problem: according to the rule of update, because~$b$'s value depends on~$a$, we need to update~$b$ before~$a$, but because~$a$'s value depends on~$b$, we are at a bit of an impasse. 
Fear not, because we have an amendment to~$TR_\emph{B}$, which introduces the \emph{rule of temporary}.

\textbf{Rule of Temporary}: If two parameters~$p$ and~$q$ depend on each other, introduce a temporary variable~$t_p$, assign~$p$ to~$t_p$, update~$p$, then update~$q$ using~$t_p$ in place of~$p$.

In essence, we generate a local temporary variable to hold onto the old value of one of our accumulators. 
Following this logic, we create the variable~$t_a$, assign to it~$a$, update~$a$, then update~$b$ using~$t_a$ in place of~$a$. 
Since~$n$ does not a dependent variable, its ordering in the mix is irrelevant.

The last stage is simple; we return the result of the other base case, namely~$b$ when~$n$ is one.

%\enlargethispage{-6\baselineskip}
\begin{lstlisting}[language=MyJava]
static int fib(int n) {
  // Holds the previous' prev.
  int a = 0;
  // Holds the prev.
  int b = 1;
  // Initial base case.
  if (n == 0) {
    return a;
  } else {
    while (!(n == 1)) {
      int ta = a;
      a = b;
      b = ta + b;
      n = n - 1;
    }
    return b;
  }
}
\end{lstlisting}

The Fibonacci sequence is predictable, in that we know how many iterations are necessary to compute a result. 
Therefore, a \ttt{for} loop seems like a reasonable substitute to \ttt{while} in this circumstance. 

We still must declare variables~$a$ and~$b$, but instead of decrementing~$n$, we instead localize an accumulator~$i$ (initialized as~$n$) to, counter-intuitively, decrement towards the base case. 

No significant changes to the implementation are made, aside from a new local variable to count down from~$n$ until it hits one.

\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
static int fib(int n) {
  int a = 0;
  int b = 1;
  if (a == 0) {
    return a;
  } else {
    for (int i = n; !(n == 1); i--) {
      int ta = a;
      a = b;
      b = ta + b;
    }
  }
  return b;
}
\end{lstlisting}

\myexample{We can use two keywords to alter the control flow of a loop: \ttt{break} and \ttt{continue}.} 
We saw \ttt{break} when working with the \ttt{switch} keyword and statement, but in the context of loops, its meaning is more significant. 

Suppose that we're designing the \ttt{int findFirstVowel(String s)} method, which returns the first occurrence of a vowel in a string~$s$, and~$-1$ if it has no vowels. 
The \ttt{break} statement allows us to exit the loop body early upon finding a vowel. 
We will traverse over the string characters using a \ttt{for} loop and terminate if we reach the end of the string, hence the inclusion of the \ttt{i < s.length()} condition. 
Our implementation must also include a method to determine whether a character is a vowel. 
We \emph{could} write ten separate clauses for checking if a character is the uppercase or lowercase version of the vowel, but we can eliminate half of those checks by converting the character to either case, and check only those.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class FindFirstVowelTester {

  @Test
  void testFindFirstVowel() {
    assertAll(
      () -> assertEquals(-1, findFirstVowel("")),
      () -> assertEquals(-1, findFirstVowel("BDFG")),
      () -> assertEquals(-1, findFirstVowel("111122223333")),
      () -> assertEquals(0, findFirstVowel("ABCD")),
      () -> assertEquals(0, findFirstVowel("aBCd")),
      () -> assertEquals(1, findFirstVowel("bEdFGhiOnP")),
      () -> assertEquals(7, findFirstVowel("BDFGHJKO")),
    )
  }
}
\end{lstlisting}

% \enlargethispage{-1\baselineskip}
\newpage %ugh
\begin{lstlisting}[language=MyJava]
class FindFirstVowel {

  /**
   * Finds the index of the first vowel in a given string. 
   * If there are no vowels in the string, we return -1.
   * @param s input string.
   * @return index of first vowel occurrence, or -1 if it has no vowels.
   */
  static int findFirstVowel(String s) {
    int idx = -1;
    for (int i = 0; i < s.length(); i++) {
      if (isVowel(s.charAt(i))) {
        idx = i;
        break;
      }
    }
    return idx;
  }

  /**
   * Determines whether or not the character is a vowel. 
   * We convert it to lowercase, then check it against 
   * those five vowels.
   * @param ch character to check.
   * @return true if ch is a vowel, false otherwise.
   */
  static boolean isVowel(char ch) {
    char lch = Character.toLowercase(ch);
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';
  }
}
\end{lstlisting}

\myexample{To better illustrate how \ttt{break} and \ttt{continue} work, let's write a method that has no real purpose, but serves to demonstrate the utility of these keywords.} 
Our method, namely \ttt{countOdds}, counts the number of odd integers generated by a random number generator from~$1$ to~$100$. 

To spice it up, we will not count odd integers less than~$50$, and if we ever generate a number greater than~$95$, we stop looping and return the count. 
The idea is to use \ttt{break} when we generate a integer between~$96$ and~$100$, and to use \ttt{continue} to skip over incrementing the counter if we find a number less than~$50$. 
The \ttt{continue} keyword shifts program control to the top of the loop, skipping over any remaining statements in the body. 

Because the \ttt{countOdds} method relies solely on random chance, writing unit tests is not helpful in determining whether the method in question works as intended.\footnote{Some testing frameworks provide methods that allow the programmer to verify the correctness of functions/methods that utilize randomness~\Citep{htdp}. We \emph{could} prove/assert that the method, without the randomness component, is correct, then later on inject a means of generating random numbers.}

In the following code snippet, an \ttt{else} statement is preferred over the superfluous use of \ttt{continue}, but we demo it to, at a minimum, portray its existence. 
The only way to exit the infinite \ttt{while} loop is to either \ttt{break} out, \ttt{return} from the method, or halt the program via another means (e.g., through a program crash or forced termination).

\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
import java.util.Random;

class RandomNumbers {

  /**
   * Counts the number of odd values generated by a random # generator.
   * @return the number of odd values counted.
   */
  static int countOdds() {
    int cnt = 0;
    Random rng = new Random();
    while (true) {
      int r = 1 + rng.nextInt(100);
      if (r > 95) { break; }
      else if (r < 50 || r % 2 == 0) { continue; }
      cnt++;
    }
    return cnt;
  }
}
\end{lstlisting}

\myexample{Let's write one more example of a loop where we go directly from the problem statement to the code in question.} 
Suppose we're designing a method that receives some string~$s$, a ``search string''~$f$, and a replacement string~$r$, with a goal of replacing all occurrences of~$f$ with~$r$ without helper methods in the \ttt{String} class, e.g., \ttt{indexOf}, \ttt{contains}, and certainly not \ttt{replace}. 
We start by writing the signature, documentation comments, and a handful of tests. 
We emphasize writing more tests than what may be considered normal for this specific problem due to its complexity and number of ``edge cases,'' i.e., cases in which a method might not account for because of their obscurity.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class FindReplaceTester {

  @Test
  void testFindReplace() {
    assertAll(
      () -> assertEquals("hiya there!",
                         replace("hiya there!", "", "replace!")),
      () -> assertEquals("hiya there!",
                         replace("hiya there!" "ya T", "replace!")),
      () -> assertEquals("Spaces_With_Underscores",
                         replace("Spaces With Underscores", " ", "_")),
      () -> assertEquals("heyyyyyay",
                         replace("heyaaaaay", "aa", "yy")),
      () -> assertEquals("hello",
                         replace("hillo", "i", "e")),
      () -> assertEquals("heyheyhey",
                         replace("hiyhiyhiy", "i", "e")),
      () -> assertEquals("We replaced the entire string!",
                         replace("Hello world, how are you?", 
                                 "Hello world, how are you?" 
                                 "We replaced the entire string!")));
  }
}
\end{lstlisting}

Subsequently, we complete the implementation of \ttt{replace}, which reduces into a few cases: while traversing, did we find the start of the search string~$f$, did we find the end of~$f$, and did we encounter a break in~$f$? 
Let's go from the start to the end in our analysis. 

When traversing over the input string~$s$, if we find the character that starts~$f$ in~$s$, we increment a counter~$c$, and continue counting as long as the characters in the particular substring of~$s$ match the characters in~$f$.

As an example, in the string $s=\ttt{"hello"}$, if $f=\ttt{"ell"}$, once our traversal finds \ttt{"e"}, we increment~$c$ by one to designate that we matched one character of~$f$. 
We continue this process until we either reach the end of~$f$, the end of~$s$, or we find a non-matching character. 

In the former instance, we append the replacement string~$r$ onto our newly-constructed string~$s'$, because it indicates that we encountered a full match of~$f$ inside~$s$, meaning it is to be replaced by~$r$.

In the second instance, we reach the end of~$s$, meaning that we are out of characters to match. 
Therefore, we either copy over the last~$c$ characters from~$s$ into~$s'$ if we have not also reached the end of~$f$, or~$r$ otherwise. 
For example, if $s=\ttt{"hello"}$, and $f=\ttt{"low"}$, we reach the end of~$s$ prior to finishing the substring~$f$, meaning that we only copy over those final characters of~$s$ and do not append~$r$. 
Conversely, if $f=\ttt{"lo"}$ in that instance, we instead substitute the suffix \ttt{"lo"} with~$r$. 

Finally, when we encounter a non-matching character, we terminate the current replacement strategy and simply append the last~$c$ characters of~$s$ onto~$s'$ and move the index forward.

A small intricacy that we have not discussed is \ttt{StringBuilder}\index{\ttt{StringBuilder}}.
As previously mentioned, strings are immutable, and concatenating two strings produces another integer.
Combining repeated concatenation operations together with a loop or recursion is highly inefficient.
To remedy the problem, Java provides the \ttt{StringBuilder} class to make repeated string append operations much faster and less of a memory hog.\footnote{Java's library also has the \ttt{StringBuffer}\index{\ttt{StringBuffer}} class to achieve the same effect, but it is suboptimal when writing single-threaded programs (i.e., programs that are concurrent\index{concurrency}).}

To summarize, the \ttt{StringBuilder} class allocates a buffer that stores the characters of a string, and any ``append'' operations manipulate the buffer, rather than having to reallocate an entirely new string of the previous size, plus the number of characters in the string-to-conjoin.

\newpage
\begin{lstlisting}[language=MyJava]
import java.lang.StringBuilder;

class FindReplace {

  /**
   * Searches through a string s for occurrences of "find", 
   * and replaces them with "repl".
   * @param s string to search through.
   * @param find string to find.
   * @param repl string to replace "find" with.
   * @return new replaced string.
   */
  static String replace(String s, String find, String repl) {
    StringBuilder sb = new StringBuilder(s.length());
    for (int i = 0; i < s.length(); i++) {
      int pos = 0;
      int j;
      for (j = i; j < s.length(); j++) {
        // If we find the entire "find" string, append the replacement.
        if (pos >= find.length()) {
          sb.append(repl);
          i = j - 1;
          break;
        }
        // If we are in the middle of searching and we find a non-matching
        // character, append everything up until this point and break.
        else if (s.charAt(j) != find.charAt(pos)) {
          sb.append(s, i, i + pos + 1);
          i = j;
          break;
        }
        // If we are matching, continue to search.
        else if (s.charAt(j) == find.charAt(pos)) {
          pos++;
        }
      }
      // If we reach the end of the string and are in the middle of searching, we append.
      if (pos > 0 && j >= s.length()) {
        sb.append(repl);
        break;
      }
    }
    return sb.toString();
  }
}
\end{lstlisting}

% \subsection{Quick Check Questions}
% \begin{enumerate}
%   \item \mcq{What is the primary purpose of loops in programming?}{To execute a block of code only once,To execute a block of code a fixed number of times based on a condition,To execute a block of code multiple times based on a condition,To check the validity of data before processing}

%   \item \mcq{Which of the following statements about converting tail recursive methods to iterative ones is true?}{Tail recursion is always less efficient than iteration,Iteration is only useful for simple algorithms,Any tail recursive method can be converted into an iterative method using a loop,Iteration cannot utilize accumulator variables}

%   \item \mcq{In the context of loops, what does the 'continue' keyword do?}{It exits the loop immediately,It skips to the next iteration of the loop,It pauses the loop temporarily,It restarts the loop from the beginning}
  
%   \item \mcq{Which of the following best describes a 'for' loop?}{A loop that executes indefinitely without a termination condition,A loop that is best suited for cases where the number of iterations is unknown,A loop that is best suited for cases where the number of iterations is known ahead of time,A loop that can only execute a fixed number of times}
  
%   \item \mcq{When should a 'while' loop be preferred over a 'for' loop?}{When the number of iterations is known ahead of time,When the loop needs to execute at least once regardless of the condition,When the termination condition is based on a state that changes within the loop body,When the loop iterates over a collection of elements}
  
%   \item \mcq{What is the result of applying Newton's Approximation method for finding square roots using loops?}{An approximate value that becomes less accurate with each iteration,An exact square root value after a fixed number of iterations,An approximate value that becomes more accurate with each iteration,The method cannot find square roots for numbers greater than 100}
  
%   \item \mcq{In the 'findFirstVowel' function example, what role does the 'break' keyword serve?}{It continues checking for vowels after finding the first one,It exits the loop once the first vowel is found,It skips non-vowel characters and continues the loop,It restarts the loop from the first character of the string}
  
%   \item \mcq{For the 'sum100Primes' function, which loop construct is utilized?}{A 'for' loop that iterates exactly 100 times,A 'while' loop that continues until 100 primes are found,A 'do-while' loop that ensures at least one prime is found,A 'for-each' loop that iterates over a collection of prime numbers}
% \end{enumerate}
