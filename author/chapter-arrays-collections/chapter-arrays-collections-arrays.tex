\section{Arrays}

Thus far, all data that we work with has been passed as method parameters. 
When we invoke a method, we have access to the arguments at that point in time. 
\emph{Arrays} allow us to store values, similar to how we use variables, but with the added benefit of storing multiple values in one location.

Arrays store \emph{elements} and \emph{indices} of some type. 
An element is just a value in an array. 
The \emph{index} of an element is its location in the array. 
Indices of an array are indexed from zero, much like strings. 
Thus, the first element of an array is at index zero, whereas the last element is located at the index $|A| - 1$, where $|A|$ denotes the number of elements, or \emph{cardinality}, of some array~$A$.

We store elements contiguously in arrays, where all are of the same type. 
This means that, if we declare an array of type \ttt{int}, we cannot store, for example, a \ttt{String} in that array. 
We can declare an array variable with preset values using \emph{initializer lists}\index{initializer lists}:

\begin{verbnobox}[\small]
int[] array = {5, 10, 15, 20, 100, 50};
\end{verbnobox}

To retrieve the size of an array, the number of elements it can store, we access the \emph{.length} field of the array, e.g., \ttt{array.length}. 
For our example array, we see that its size is six. 
Moreover, \ttt{array[0]} stores \ttt{5}, and \ttt{array[5]} stores \ttt{50}. 
Accessing a negative index or an index beyond the bounds of the length results in an \ttt{ArrayIndexOutOfBoundsException}. 
So, accessing \ttt{array[-1]} or \ttt{array[6]}, for instance, crashes the program. 
A common mistake is to access the index at the length of the array to retrieve the last element, which represents a misunderstanding of array indexing.

To declare an array of type~$T$, called~$A$, that stores~$N$ elements, we write the following:

\begin{verbnobox}[\small]
T[] A = new T[N];
\end{verbnobox}

We can store a value~$e$ at an arbitrary index~$i$ of array~$A$, in addition to accessing the value at some index.

\begin{verbnobox}[\small]
// Store "e" at index i of A.
A[i] = e;
// Print out the value at A[i].
System.out.println(A[i]);
\end{verbnobox}

\myexample{Let's declare an integer array~$A$ to store the integers from zero to one hundred in increments of ten.}
\begin{verbnobox}[\small]
int[] A = {0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
\end{verbnobox}

Initializer lists are verbose and require us to explicitly specify each individual constant. 
A better solution is to initialize the array to a size, and populate its elements using a loop.

\begin{verbnobox}[\small]
final int SIZE = 11;
int[] A = new int[SIZE];
for (int i = 0; i < A.length; i++) { A[i] = i * 10; }
\end{verbnobox}

We use~$i$ to iterate over the possible indices of our array. 
Before we explained that~$i$ is used out of standard loop convention, but we now say that~$i$, in general, stands for either ``iteration'' or ``index.'' 
We assign, to~$A$ at index $i$, the value of $i$ multiplied by ten. 
We can convert the array to a \ttt{String} using a utility method from the \ttt{Arrays} class (note the plural!); a ``string-ified'' array separates each element by commas and surrounds them with braces.

\begin{verbnobox}[\small]
String s1 = Arrays.toString(A);
s1 => {0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100}
\end{verbnobox}

\begin{figure}[tp]
%\begin{wrapfigure}[25]{r}[0.75in]{0.55\textwidth}
  \small
  \begin{tcolorbox}[title=Java Arrays]
    An \emph{array}\index{array} stores a fixed-size collection of elements of some type.
    \vspace{2ex}
    % \hrule
    % \vspace{2ex}
  \begin{description}
    \item [\ttt{$T[]\;A =$ new $T[n]$}] creates an array of type $T$, named $A$, that stores $n$ elements.
    \item [\ttt{$A[i]$}] retrieves the element at index $i^{\text{th}}$ of $A$. We refer to this as position $i + 1$.
    \item [\ttt{$A[i] = v$}] assigns $v$ to index $i$ of $A$.
    \item [\ttt{$A$.length}] returns the number of elements that the array can store.
    \item [\ttt{Arrays.equals}($A_1, A_2$)] returns whether or not the elements of $A_1$ are equal to the elements of $A_2$.
    \item [\ttt{Arrays.toString}$(A)$] returns a string representation of the elements in $A$, separated by commas and enclosed by brackets.
    \item [\ttt{Arrays.fill}$(A, v)$] populates $A$ with $v$ in every index.
    \item [\ttt{Arrays.copyOf}$(A, n)$] returns a new array $A'$ of the same type with the new size, padding with the necessary default elements or truncating.
    \item [\ttt{Arrays.sort}$(A)$] performs an in-place sort of $A$, meaning the contents of $A$ are modified.
  \end{description}
\end{tcolorbox}
  \caption{Useful Array Methods.}
  \label{fig:arrays}
\end{figure}

\myexample{Let's design a method that receives an array of \ttt{double} values and returns the sum of those elements.}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class SumOfDoubleArrayTester {

  @Test
  void testSumOfDoubleArray() {
    assertAll(
      () -> assertEquals(0.0, sumOfDoubles(new double[]{})),
      () -> assertEquals(100.0, sumOfDoubles(new double[]
                                             {25.0, 50.0, 25.0})));
  }
}
\end{lstlisting}

Our method uses a local variable to accumulate the ``running sum,'' so to speak, of the values seen so far in the passed array.

\begin{lstlisting}[language=MyJava]
class SumOfDoubleArray {

  /**
   * Computes the sum of the values in a double array.
   * @param arr - double [] array of double values.
   * @return sum of those values.
   */
  static double sumOfDoubles(double[] arr) {
    double sum = 0;
    for (int i = 0; i < arr.length; i++) { sum += arr[i]; }
    return sum;
  }
}
\end{lstlisting}

Even though our code works and the tests that we wrote pass without question, there is a bit of verbosity with our loop:~$i$'s purpose is solely for accessing an index into the array. 
In such circumstances, we may prefer using the enhanced \ttt{for} loop\index{enhanced \ttt{for} loop}, which abstracts away the index and provides an iteration construct for accessing elements sequentially.

%\enlargethispage{\baselineskip}
\begin{lstlisting}[language=MyJava]
class SumOfDoubleArray {

  static double sumOfDoubles(double arr) {
    double sum = 0;
    for (double e : arr) { sum += e; }
    return sum;
  }
}
\end{lstlisting}

Why might someone want to use the enhanced \ttt{for} loop over a standard \ttt{for}? 
When we only want to access the elements themselves and not care about their position, the enhanced counterpart is favored; not having to concern ourselves with indices completely removes the possibility of accessing an out-of-bounds index. 

\myexample{Let's design the \ttt{int countOccurs(int[] A, int n)} method, which receives an integer~$n$ and returns the number of times it appears in an array of integers.}
Fortunately this requires exactly one traversal over~$A$ to count the occurrences of~$n$, with no complex cases to consider.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class CountOccursTester {

  @Test
  void testCountOccurs() {
    assertAll(
      () -> assertEquals(0, countOccurs(new int[]{}, 5)),
      () -> assertEquals(3, countOccurs(new int[]{5, 3, 5, 5}, 5)),
      () -> assertEquals(1, countOccurs(new int[]{1, 2, 3, 4, 5}, 5)),
      () -> assertEquals(0, countOccurs(new int[]{1, 2, 3, 4, 5}, 6)));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class CountOccurs {

  /** 
   * Counts the number of occurrences of a value in an int array.
   * @param A - array of integers.
   * @param n - value to count.
   * @return number of occurrences of n in A.
   */
  static int countOccurs(int[] A, int n) {
    int count = 0;
    for (int e : A) {
      if (e == n) { 
        count++; 
      }
    }
    return count;
  }
}
\end{lstlisting}

\myexample{Consider the \ttt{int[] wordLengths(String[] S)} method.}
Its purpose is, for every index~$i$ of the array~$S$, to store the length of the string at that index in the corresponding index of the returned array.
For example, if~$S$ contains the strings \ttt{"hello"}, \ttt{"world"}, and \ttt{"!"}, the returned array should contain the values~$5$,~$5$, and~$1$, respectively.
Solving the problem with either recursion or iteration is possible, but

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class WordLengthsTester {

  @Test
  void testWordLengths() {
    assertAll(
      () -> assertEquals(new int[]{5, 5, 1}, wordLengths(new String[]
                      {"hello", "world", "!"})),
      () -> assertEquals(new int[]{0, 0, 0}, wordLengths(new String[]
                      {"", "", ""})),
      () -> assertEquals(new int[]{1, 2, 3}, wordLengths(new String[]
                      {"a", "ab", "abc"})));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class WordLengths {

  /**
   * Computes the lengths of the strings in an array.
   * @param S - array of strings.
   * @return array of lengths of the strings in S.
   */
  static int[] wordLengths(String[] S) {
    int[] lengths = new int[S.length];
    for (int i = 0; i < S.length; i++) {
      lengths[i] = S[i].length();
    }
    return lengths;
  }
}
\end{lstlisting}

\myexample{Let's design a method that returns the largest integer in an array of integers}. Its algorithm appears straightforward, but can be a little tricky to correctly design because of how we determine the ``largest integer.'' 
Some programmers may choose to declare a value \ttt{largest} and assign it, say,~$-1$, and then if we encounter a larger value, overwrite the existing value. 
Such an algorithm works well when the provided array contains only positive integers, but what if our array contains only negative numbers less than~$-1$? 
In that scenario, our algorithm would return~$-1$, which is not the largest integer in the array. 
To avoid this issue, we can initialize \ttt{largest} to the first element of the array, and then iterate over the remaining elements, updating \ttt{largest} if we encounter a larger value.
To simplify the implementation, we assume a precondition that the given array is non-empty.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class LargestIntTester {

  @Test
  void largestIntTester() {
    assertAll(
      assertEquals(4, largestInt(new int[]{4})), 
      assertEquals(13, largestInt(new int[]{12, 13, 10, 9})), 
      assertEquals(-5, largestInt(new int[]{-5, -7, -1932, -6, -6})), 
      assertEquals(9, largestInt(new int[]{9, 9, 9, 9, 9, 9, 9, 9})), 
      assertEquals(0, largestInt(new int[]{-321, -43, 0, -43, -321})), 
      assertEquals(0, largestInt(new int[]{-9, 0, -8, -7, -1234})));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class LargestInt {

  static int largestInt(int[] arr) {
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
      if (arr[i] > max) { max = arr[i]; }
    }
    return max;
  }
}
\end{lstlisting}

A slightly more compact solution is to wrap the conditional inside a call to \ttt{Math.max}, since the logic is effectively identical: \ttt{max = Math.max(arr[i], max)}.

Java arrays are rather primitive compared to other more-complex data structures.\footnote{Do not conflate this use of the ``primitive'' term with its use in describing ``primitive datatypes.''} 
The \ttt{Arrays} class provides a few convenient methods for working with arrays, but for the most part, arrays serve as the backbone of other data structures. 
Arrays guarantee \emph{constant access}\index{constant access} times for elements. 
That is, if we know the index of an element~$e$, we retrieve or modify it using the aforementioned array bracket syntax. 

\myexample{Suppose we want to design a method that returns the index of an element~$e$ of an array of \ttt{String} values.} 
Doing so is not a challenge: check each element, one-by-one, until we find the desired element, or return~$-1$. 
Note the parallelism to the \ttt{String} class' \ttt{indexOf} method.
To get practice using both recursion and iteration, we will design two versions of this method: one that uses tail recursion and the other that uses a loop.\footnote{When recursing over an array, it is common to always have a parameter to represent the~$i^\text{th}$ index, which corresponds to the current element. Note that this can be accomplished through both standard and tail recursion.} 
The tail recursive method recurses over the accumulator, which serves as the current index to check.\footnote{We do \emph{not} use standard recursion for this particular problem because returning~$-1$ would result in an incorrect final value when unwinding the recursive calls.} 
If this value exceeds the bounds of the array, we return~$-1$. 
If~$S[i]$ is equal to~$k$, we return~$i$. 
Otherwise, we recurse and increment~$i$ by one. 
The tests for these two are both trivial to design.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class ArrayFinderTailRecursiveTester {

  @Test
  void testArrayFinderTailRecursive() {
    String[] arrS = new String[]{"Hello", "hi", "hiya", "howdy", "hello"};
    assertAll(
      () -> assertEquals(2, indexOfTR(arrS, "hiya")),
      () -> assertEquals(0, indexOfTR(arrS, "Hello")),
      () -> assertEquals(4, indexOfTR(arrS, "hello")),
      () -> assertEquals(-1, indexOfTR(arrS, "ahoy")));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class ArrayFinder {

  static int indexOfTR(String[] arrS, String k) {
    return indexOf(arrS, k, 0);
  }

  private static int indexOfTRHelper(String[] arrS, String k, int i) {
    if (i >= arrS.length) { return -1; } 
    else if (arrS[i].equals(k)) { return i; } 
    else { return indexOfHelper(arrS, k, i + 1); }
  } 
}
\end{lstlisting}

In converting the tail recursive solution to use iteration, we will use the translation pipeline. 
Our base case is when~$i$ equals or exceeds the length of the array, so the negated expression is our loop condition. 
Moreover, we place a conditional statement inside the loop, which returns whether~$S[i]$ equals~$k$ for that value of~$i$ and, if so, we return~$i$. 
We might also form a conjunction between the two conditions whose exit condition is when one of those conditions is falsified. 
Because we have two different atomic return values, though, we will use the former approach. 
The test cases for this method are identical to the tail recursive version.

\begin{lstlisting}[language=MyJava]
class ArrayFinder {

  static int indexOfLoop(String[] arrS, String k) {
    int i = 0;
    while (!(i >= arrS.length)) {
      if (arrS[i].equals(k)) { 
        return i; 
      }
    }
    return -1;
  }
}
\end{lstlisting}

The conventional solution to this problem, especially since we know the upper bound on the number of iterations, involves a \ttt{for} loop. 
A \ttt{for} loop, as we now know, localizes the accumulator variable. 
Moreover, we \emph{could} use the translation pipeline conditional expression, but it is idiomatic to loop while the index is less than the length of the array, and use an expression that describes this relationship.

\begin{lstlisting}[language=MyJava]
class ArrayFinder {
  
  static int indexOfLoop(String[] arrS, String k) {
    for (int i = 0; i < arrS.length; i++) {
      if (arrS[i].equals(k)) { 
        return i; 
      }
    }
    return -1;
  }
}
\end{lstlisting}

\myexample{Imagine that we are writing a multiple choice question exam score calculator.} Correct answers award three points, incorrect answers remove one point, and a \ttt{"?"} represents a guess, which neither awards nor removes points. 
Let's design a method that receives two \ttt{String} arrays representing the expected answers~$E$ and the actual answers~$A$, and returns the score as a percentage. 
We will assume that~$|E|=|A|$. 
Again, to gain practice with recursion and iteration, we'll design three versions of the \ttt{score} method.

First, we need to once again recognize that, because the method receives an array to recurse over, the method must receive a parameter representing the index-to-check. 
Though, we do not wish to expose to the caller how \ttt{score} works, so we can design a private helper method. 
Our base case occurs when~$i \geq |E|$, in which we return zero. 
Otherwise, we have a case analysis on the~$i^\text{th}$ actual answer: if it equals the~$i^\text{th}$ expected answer, we award three points. 
If it is equal to a question mark string, i.e., \ttt{"?"} then we award no points. 
Otherwise, the answer is incorrect, meaning we deduct one point. 
Because a negative score is non-sensical, our driver method returns the maximum of zero and the score to filter out negative values.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class McqScoreCalculatorTester {

  @Test
  void testScore() {    
    String[] E = new String[]{"A","C","D","A","B","B","D","C","C"};
    String[] A1 = new String[]{"A","C","D","C","B","B","C","C","C"};
    String[] A2 = new String[]{"A","C","D","A","B","B","D","C","C"};
    String[] A3 = new String[]{"A","C","?","C","?","B","?","C","C"};
    assertAll(
      () -> assertEquals(70.3, score(E, A1)),
      () -> assertEquals(100.0, score(E, A2)),
      () -> assertEquals(51.8, score(E, A3)));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class McqScoreCalculator {

  /**
   * Computes the score of a test.
   * @param E - expected test answers.
   * @param A - answers provided.
   * @return score of test, >= 0.
   */
  static double score(String[] E, String[] A) {
    int maxScore = E.length * 3;
    return Math.max(0, scoreHelper(E, A, 0)) / maxScore * 100;
  }

  /**
   * Recursively computes the score of an exam.
   * @param E - expected answers.
   * @param A - answers provided.
   * @param i - index-to-check.
   * @return score of test.
   */
  private static double scoreHelper(String[] E, String[] A, int i) {
    if (i >= A.length) { return 0; }
    else if (A[i].equals(E[i])) { return 3 + scoreHelper(E, A, i + 1); }
    else if (A[i].equals("?")) { return scoreHelper(E, A, i + 1); }
    else { return -1 + scoreHelper(E, A, i + 1); }
  }
}
\end{lstlisting}

The tail recursive solution is almost identical to the standard recursive variant. The essential difference is that we accumulate the score as a parameter in between recursive calls instead of summing the points when unwinding the calls. Aside from that, everything else remains the same. Our tests from \ttt{score} are likewise suitable for both the tail recursive and loop methods.

\begin{lstlisting}[language=MyJava]
class McqScoreCalculator {

 /**
  * Computes the score of a test.
  * @param E - expected test answers.
  * @param A - answers provided.
  * @return score of test, >= 0.
  */
  static double scoreTR(String[] E, String[] A) {
    return Math.max(0, scoreTRHelper(E, A, 0, 0)) / (E.length * 3) * 100;
  }
 
  /**
   * Recursively computes the score of an exam.
   * @param E - expected answers.
   * @param A - answers provided.
   * @param i - index-to-check.
   * @param s - currently-accumulated score.
   * @return score of test.
   */
  private static double scoreTRHelper(String[] E, String[] A, 
                                      int i, int s) {
    if (i >= E.length) { return s; }
    else if (A[i].equals(E[i])) { return scoreTRHelper(E, A, i+1, s+3); }
    else if (A[i].equals("?")) { return scoreTRHelper(E, A, i+1, s); }
    else { return scoreTRHelper(E, A, i + 1, s + -1); }
  }
}
\end{lstlisting}

Lastly, the loop variant is just a translation pipeline away. 
When traversing over arrays, though, it is much more colloquial to use a \ttt{for} loop, since the bounds are known a priori.

\begin{lstlisting}[language=MyJava]
class McqScoreCalculator {

 /**
  * Computes the score of a test.
  * @param E - expected test answers.
  * @param A - answers provided.
  * @return score of test, >= 0.
  */
  static double scoreLoop(String[] E, String[] A) {
    int score = 0;
    int i = 0;
    while (!(i >= A.length)) {
      if (A[i].equals(E[i])) { score += 3; } 
      else if (A[i].equals("?")) { score += 0; } 
      else { score += -1; }
      i++;
    }
    int maxScore = E.length * 3;
    return Math.max(0, score) / maxScore * 100;
  }
}
\end{lstlisting}

The key ideas with this example are twofold: first, a helper method does not always have to be tail recursive. 
Second, a standard recursive method can leverage a helper method when necessary.

We are on our way to understanding the full signature of the \ttt{main} method. 
Now that we have covered arrays, we know what the \ttt{String[] args} parameter represents, but \emph{why} it receives that array of strings remains a mystery. 
We can compile Java files using the terminal and the \ttt{javac} command. 
Moreover, when executing a Java file, we may pass to it \emph{terminal arguments}\index{terminal arguments}, which are values that the program might use to configure settings or process at runtime.

\myexample{Suppose we want to write a program, using the \ttt{main} method and terminal arguments, that evaluates an arithmatic operation on a collection of integers values, e.g., $5 + 3 + 17$.}
Additionally, we might want to let the user pass \emph{flags} to denote these different operations, such as \ttt{--add} for addition, \ttt{--sub} for subtraction, and so on. 
So the user is not confused, we might also provide a ``help'' option that is displayed either upon request or when incorrect arguments are supplied.

First, we must explain how terminal arguments work. 
Terminal arguments are specified after the executable (name) and are separated by spaces. 
For instance, if our program name is \ttt{calculator}, we might use \ttt{./calculator --add 5 4 17}. 
Thus, \ttt{args[0]} is \ttt{--add}, \ttt{args[1]} is \ttt{"5"}, \ttt{args[2]} is \ttt{"4"}, and \ttt{args[3]} is \ttt{"17"}. 
For simplification purposes, we will assume that the first argument is always the operation/help flag, and the remaining values are operands. 
This means that the program should output \ttt{26}. 
Let's design a method that parses the operation/help flag. 
Upon success, it returns \ttt{true} and upon failure, it returns \ttt{false}. 
This prevents the program from further interpreting bad terminal arguments, e.g., \ttt{./calculator --wrong 5 12}. 
We will also use \ttt{false} as an indication that the \ttt{help} menu was requested or prompted. 
Thus, to not duplicate code, we should design another method that displays the relevant program usage information.

%\enlargethispage{4\baselineskip}
\begin{lstlisting}[language=MyJava]
class Calculator {

  public static void main(String[] args) {
    if (parseCommand(argv[0])) {
      // Continue.
    }
    // Otherwise, stop.
  }

  static boolean parseCommand(String cmd) {
    if (cmd.equals("--add") || cmd.equals("--sub")) {
      return true;
    } else {
      displayHelp();
      return false;
    }
  }

  static void displayHelp() {
    System.out.println("usage: ./calculator --(help | add | sub) <n1> 
                        [n...]");
  }
}
\end{lstlisting}

Up next is the process of interpreting each valid operation, i.e., \ttt{--add} and \ttt{--sub}. 
The former will add each successive argument one-by-one while the latter subtracts them from left-to-right. 
Because we receive the terminal arguments as strings, we will need to convert their values from strings to double values using \ttt{Double.parseDouble}. 
For the time being, we will assume that these \emph{are}, in fact, double values, rather than working through the painstaking process of parsing a string for the existence of a proper \ttt{double} datatype value. 
We encourage the readers to implement this method themselves, along with the appropriate tests.

Note that in the code below, we utilize an \ttt{if/else if} combination without an accompanying \ttt{else}, which we would normally discourage. 
Because we exhaust the possibilities with \ttt{parseCommand}, however, we will allow its usage. 
The \ttt{parseAdd} and \ttt{parseSub} methods are trivial and we have shown an example of their implementation previously, so we will also omit these to preserve space and avoid unnecessary repetition.

\begin{lstlisting}[language=MyJava]
class Calculator {

  public static void main(String[] args) {
    if (parseCommand(args[0])) {
      String cmd = args[0];
      double[] operands = convertToDoubleArray(args);
      if (cmd.equals("--add")) {
        System.out.println(parseAdd(operands));
      } else if (cmd.equals("--sub")) {
        System.out.println(parseSub(operands));
      }
    }
  }
}
\end{lstlisting}

\myexample{Let's write a program that receives a list of integers through the terminal, as an ``argument array'' of sorts, and allow the user to pass flags to denote the operation to perform on the list.} 
Our program will support the following operations: \ttt{--sum}, \ttt{--product}, \ttt{--min}, and \ttt{--max} command. 
We will also provide a \ttt{--help} flag that displays the program usage information. 
This is a substantial project, but doing so allows us to practice using arrays and integrating more complex terminal arguments. 
As a measure of simplification, we will assume that the first~$n$ arguments are the numeric values, and the remaining arguments are the operation flags. 
Let's further assume that the user will not pass an invalid command. 
Lastly, we shall not consider any non-sensical in a given context, e.g., the minimum/maximum of no input values. 
The first terminal argument denotes the number of values to expect, so we will use it to initialize our array.

To start, let's see a few example runs of our program, containing a mixture of flags.

%\enlargethispage{4\baselineskip}
\begin{verbnobox}[\small]
./ArrayArguments 5 1 2 3 4 5 --sum --max
sum: 15.000000
max: 5.000000

./ArrayArguments 3 100 200 -100 --product --sum --min
sum: 200.000000
product: -2000000.000000
min: -100.000000

./ArrayArguments --help
usage: ./ArrayArguments <n> <n1> [n...] [--(sum | product | min | max)]
\end{verbnobox}

The ordering of the output is irrelevant, and depends on how we parse the input flags in the main method. 
To scan for a given flag, let's design a static method to return whether or not the flag exists in the arguments array.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class ArrayArgumentsTester {

  @Test
  void testScanForFlag() {
    String[] args = new String[]{"--sum", "--max", "--min"};
    assertAll(
      () -> assertEquals(true, isFlagPresent(args, "--sum")),
      () -> assertEquals(true, isFlagPresent(args, "--max")),
      () -> assertEquals(true, isFlagPresent(args, "--min")),
      () -> assertEquals(false, isFlagPresent(args, "--product")));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class ArrayArguments {

  /**
   * Returns whether or not a given flag exists in the arguments array.
   * @param args - array of arguments.
   * @param flag - flag to search for.
   * @return whether or not the flag exists.
   */
  static boolean isFlagPresent(String[] args, String flag) {
    for (String arg : args) {
      if (arg.equals(flag)) { return true; }
    }
    return false;
  }
}
\end{lstlisting}

The other ``operations'' methods, as well as their tests, are simple to create, and we will omit their implementation. 

Our main method first checks to see if the user entered the ``help'' command and, if so, presents the necessary information for running the program. 
Otherwise, we perform a case analysis on the terminal arguments, looking for the presence of the operation flags. 
For arbitrary reasons, we output the sum, then the product, then the minimum, and finally the maximum, in that order, despite the ordering of the flags. 
As an exercise, we encourage the readers to modify the program to instead output the values in the order of the presented flags. 
An important detail that some may miss is that we use a sequence of \ttt{if} statements rather than \ttt{if/else if} statements. 
This is because we want to allow the user to pass multiple flags, and we would unintentionally restrict them to exactly one flag with \ttt{if/else if} statements. 
Thus, we must check for the presence of each flag individually.

%\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
class ArrayArguments {

  public static void main(String[] args) {
    if (isFlagPresent(args, "--help")) {
      displayHelp();
    } else {
      int n = Integer.parseInt(args[0]);
      double[] values = new double[n];
      for (int i = 0; i < n; i++) { 
        values[i] = Double.parseDouble(args[i + 1]); 
      }
      if (isFlagPresent(args, "--sum")) { 
        System.out.printf("sum: %f\n", sum(values)); 
      }
      if (isFlagPresent(args, "--product")) { 
        System.out.printf("product: %f\n", product(values)); 
      }
      if (isFlagPresent(args, "--min")) { 
        System.out.printf("min: %f\n", min(values)); 
      }
      if (isFlagPresent(args, "--max")) { 
        System.out.printf("max: %f\n", max(values)); 
      }
    }
  }
}
\end{lstlisting}

\myexample{Arrays are not restricted to being only one dimensional.} 
In this problem, we will make use of a two-dimensional array, which might be thought of as a matrix or a grid. 
Namely, we'll design a method that returns the sum of the elements of a two-dimensional array of integers. 
Traversing over an~$n$-dimensional array generally involves nested loops. 
The order in which we traverse over the array can be significant. 
For example, the following code uses \emph{row-major}\index{row-major} ordering, since we iterate over the rows first, and then the columns, meaning that we visit the elements (of a $3\times{3}$ array) in the order
\[
  A_{0,0}, A_{0,1}, A_{0,2}, A_{1,0}, A_{1,1}, A_{1,2}, A_{2,0}, A_{2,1}, A_{2,2}
\] 
Conversely, \emph{column-major}\index{column-major} ordering would visit the elements in the order
\[
  A_{0,0}, A_{1,0}, A_{2,0}, A_{0,1}, A_{1,1}, A_{2,1}, A_{0,2}, A_{1,2}, A_{2,2}
\]
Multi-dimensional arrays are nothing more than arrays of arrays. 
As an example, we can declare a $3 \times 4$ two-dimensional array of integers (with three rows and four columns) as follows:

\begin{verbnobox}[\small]
int[][] A = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
\end{verbnobox}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class SumOf2DArrayTester {

  @Test
  void testSumOf2DArray() {
    int[][] A = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
    assertAll(
      () -> assertEquals(78, sumOf2DArray(A)),
      () -> assertEquals(0, sumOf2DArray(new int[][]{})),
      () -> assertEquals(1, sumOf2DArray(new int[][]{{1}})));
  }
}
\end{lstlisting}

We need to know both the number of rows and the number of columns to traverse over a two-dimensional array. 
To retrieve the number of rows, we refer to the array's length via \texttt{$A$.length}. 
To get the number of columns, again, because we know that~$A$ is an array of one-dimensional arrays, we use \ttt{$A[0]$.length}, or in general, \ttt{$A[i]$.length} for any~$i$ such that $0 \leq i< $ \ttt{$A$.length}.\footnote{This generalization applies because arrays in Java cannot be \emph{ragged}: where different rows/columns have differing sizes.} To access the element at row~$i$ and column~$j$, we use \ttt{$A[i][j]$}. 

\begin{lstlisting}[language=MyJava]
class SumOf2DArray {

  /**
   * Computes the sum of the values in a two-dimensional array.
   * @param arr - two-dimensional array of integers.
   * @return sum of those values.
   */
  static int sumOf2DArray(int[][] arr) {
    int sum = 0;
    for (int i = 0; i < arr.length; i++) {
      for (int j = 0; j < arr[i].length; j++) {
        sum += arr[i][j];
      }
    }
    return sum;
  }
}
\end{lstlisting}

\myexample{Let's solve a slightly harder problem using two-dimensional arrays.} 
Suppose that we want to design a method that returns the number of possible moves that a rook can take to go from the top-left of a (not-necessarily rectangular) board to the bottom-right, assuming that it cannot move left or up. 
The naive solution to this problem is to use a recursive method that changes its position by one in either direction, stopping once we hit the bottom-right of the board. 
Assuming the rook starts at~$(x, y)$ and the board is~$n \times m$, we can write the following method.

%\enlargethispage{5\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RookPathTester {

  @Test
  void testRookPath() {
    assertAll(
      () -> assertEquals(2, rook(0, 0, 1, 1)),
      () -> assertEquals(6, rook(0, 0, 2, 2)),
      () -> assertEquals(10, rook(0, 0, 2, 3)),
      () -> assertEquals(70, rook(0, 0, 4, 4)));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class RookPath {

  /**
   * Computes the number of possible paths that a rook 
   * can take to go from the top-left of a board to the 
   * bottom-right, assuming that it cannot move left or up.
   * @param x - x-coordinate of the rook's starting position.
   * @param y - y-coordinate of the rook's starting position.
   * @param n - number of rows of the board.
   * @param m - number of columns of the board.
   * @return number of possible paths.
   */
  static int rook(int x, int y, int n, int m) {
    if (x == n || y == m) { 
      return 1; 
    } else { 
      return rook(x + 1, y, n, m) + rook(x, y + 1, n, m); 
    }
  }
}
\end{lstlisting}

Much like how the recursive definition of Fibonacci is horrendously slow, so is this implementation of the rook path problem. 
We need a faster algorithm, and indeed, we can take advantage of a two-dimensional array because of an emerging pattern. 
Notice that, in the bottom-right corner, there is only one possible solution. 
We can generalize this to say that there is only one solution for any position in the bottom row or the far-right column. 
From here, we can work our way up and to the left, filling in the number of possible solutions for each position. 

For example, the position $(n - 1, m - 1)$ has a value of two, since it can move either right or down. 
The position $(n - 2, m - 1)$ has a value of three, since it can move right, down, or down and then right. 
We continue this process until we reach the top-left corner, which contains the value of the number of possible paths from $(0, 0)$ to $(n, m)$.\footnote{Should we want to choose an arbitrary starting point, we can retrieve that index rather than $(0, 0)$ in the resulting two-dimensional array.} 
We can design a method that computes this value using a two-dimensional array. 
Composing the solution using this style is called \emph{dynamic programming}\index{dynamic programming}, which comes up often when attempting to optimize problems that have naive and outrageously recursive solutions.

To prevent our code from going out of bounds, we need to add one to the bounds of our input array. 
That is, if we want to compute the number of possible paths from $(0, 0)$ to $(n, m)$, we need to create an array of size $(n + 1) \times (m + 1)$, because the current value of the array at $(n, m)$ depends on the values of the array at $(n + 1, m)$ and $(n, m + 1)$.\footnote{When writing dynamic programming algorithms, it is commonplace to call the array \ttt{dp} out of convention.} 

Dynamic programming problems are often solved using two-dimensional arrays using the following three-step process: 

\begin{enumerate}
  \item For a problem size of~$n$ and~$m$, we first initialize a two-dimensional array of size~$(n + 1) \times (m + 1)$.
  \item Populate the array with the necessary base cases.
  \item Iterate over the array, filling in the values using a recurrence relation.
\end{enumerate}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RookPathTester {

  @Test
  void testRookPathDp() {
    assertAll(
      () -> assertEquals(2, rookDp(0, 0, 1, 1)),
      () -> assertEquals(6, rookDp(0, 0, 2, 2)),
      () -> assertEquals(10, rookDp(0, 0, 2, 3)),
      () -> assertEquals(70, rookDp(0, 0, 4, 4)));
  }
}
\end{lstlisting}

%\enlargethispage{6\baselineskip}
\begin{lstlisting}[language=MyJava]
class RookPath {

  /**
   * Computes the number of possible paths that a rook 
   * can take to go from the (x, y) position of a board 
   * to the bottom-right, assuming that it cannot move left or up. 
   * This approach uses dynamic programming.
   * @param x - x-coordinate of the rook's starting position.
   * @param y - y-coordinate of the rook's starting position.
   * @param n - number of rows of the board.
   * @param m - number of columns of the board.
   * @return number of possible paths.
   */
  static int rookDp(int x, int y, int n, int m) {
    int[][] dp = new int[n + 1][m + 1];

    // Compose the initial bottom-row solutions.
    for (int i = 0; i < n + 1; i++) { dp[i][m] = 1; }

    // Compose the initial far-right solutions.
    for (int i = 0; i < m + 1; i++) { dp[n][i] = 1; }

    // Now do the dynamic programming algorithm.
    for (int i = n - 1; i >= 0; i--) {
      for (int j = m - 1; j >= 0; j--) {
        dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
      }
    }
    return dp[x][y];
  }
}
\end{lstlisting}

\myexample{Let's solve another foundational dynamic programming problem, only this time we utilize only a one-dimensional array.}
Imagine that we're working at a lumber store that saws wood logs for manufacturing purposes. 
We sell and saw wood logs by the meter.
Different lengths of a log cost different amounts, and we want to maximize the profits made when sawing the logs. 
For example, consider the following table:

\begin{center}
\begin{tabular}{|c||c|c|c|c|c|c|c|c|c|}
  Length (meters) & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8\\
  \hline
  Cost (USD) & 0 & 1 & 4 & 6 & 7 & 12 & 18 & 25 & 30\\
\end{tabular}
\end{center}

Suppose our wood log is~$4$ meters long. 
There are, therefore, $2^(4-1)=2^3=8$ ways to saw the log:
$1|1|1|1$, $1|1|2$, $1|2|1$, $1|3$, $2|1|1$, $2|2$, $3|1$, and $4|0$. 
If we compute the prices of these sawings, we get $1+1+1+1=4$, $1+4+1=6$, $1+1+4=6$, $1+6=7$, $4+1+1=6$, $4+4=8$, $6+1=7$, and $7=7$. 
So, to maximize our profit, we want to saw the log into two pieces, each of which are~$2$ meters long.

The question is, how do we determine the maximum profit algorithmically? 
Decomposing the problem shows us that we first saw the log into size~$i$ meters, then try to maximize the profit made from sawing the rest of the log, which has size~$n - i$ meters. 
The relationship is recursive, and we can design a method to simulate it.
Namely, we try all possible sawings of size~$i$ using a loop, then recursively decompose the problem.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class LogSawTester {

  @Test
  void testLogSaw() {
    assertAll(
      () -> assertEquals(0, logSaw(new int[]{0}));
      () -> assertEquals(8, logSaw(new int[]{0,1,4,6,7,12,18,25,30})));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class LogSaw {
  
  /**
   * Performs a traditional recursive sawing of the given log.
   * Warning: this algorithm is outrageously slow!
   * @param P - array of saw prices from 0 to n.
   * @param n - length of log to saw in meters.
   * @return maximum profit of sawing log of length n.
   */
  static int logSaw(int[] P, int n) {
    if (n == 0) {
      return 0;
    } else {
      int r = 0;
      for (int i = 1; i <= n; i++) {
        r = Math.max(r, P[i] + logSaw(P, n - i));
      }
      return r;
    }
  }
}
\end{lstlisting}

While the recursive algorithm works, it is horribly inefficient; we saw the log at \emph{all} possible intervals, meaning there are several repeated computations. 
Similar to Fibonacci, \ttt{logSaw} is an exponential-time algorithm! 
We can certainly do better.

Like we said, we're repeatedly sawing at places whose maximal price has already been determined.
So, let's design another recursive method that passes along an array~$L$ of stored (maximal) sawings.
After trying all sawings from~$1$ to~$n$, we store the maximum saw price for length~$n$ in $L$ at index~$n$.
When recursing, if there is a non-zero element at index~$n$, we know that its value was computed earlier and can return it accordingly.

This variant is leaps and bounds better than the original algorithm, taking its runtime from exponential down to quadratic in the length of the given log. 
We consider the algorithm to be ``top-down memoized,'' because the solution recurses from~$n$ down to~$1$, and it stores partial solutions in an array (i.e., memoizing). 

\begin{lstlisting}[language=MyJava]
class LogSaw {
  // ... previous method not shown.

  /**
   * Performs a top-down sawing of the given log.
   * @param P - array of saw prices from 0 to n.
   * @param n - length of log to saw in meters.
   * @return maximum profit of sawing log of length n.
   */
  static int logSawTopDown(int[] P, int n) {
    int[] R = new int[P.length];
    return logSawTopDownHelper(P, R, n);
  }

  /**
   * Helper method for top-down log saw algorithm.
   * @param P - array of saw prices from 0 to n.
   * @param R - intermittient saw prices; memoized.
   * @param n - length of log in meters.
   * @return maximum profit for log of size n.
   */
   private static int logSawHelper(int[] P, int[] R, int n) {
    if (R[n] > 0) {
      return R[n];
    } else if (n == 0) {
      return n;
    } else {
      int pr = 0;
      for (int i = 1; i <= n; i++) {
        pr = Math.max(pr, P[i] + logSawHelper(P, R, n - i));
      }
      R[n] = pr;
      return pr;
    }
  }
}
\end{lstlisting}

Though, we still have to worry about recursive depth for sufficiently large values of~$n$. 
Let's take the algorithm one step further and convert it into a ``bottom-up'' iterative algorithm.
In essence, rather than making recursive calls, we use two loops and compose the solution to larger problems (i.e., larger values of~$n$) by saving (intermittient) solutions to smaller problems (i.e., smaller values of~$n$).
The tests for the top-down and bottom-up methods are the same as the standard recursive version.

\begin{lstlisting}[language=MyJava]
class LogSaw {
  // ... previous method not shown.

  /**
   * Performs a bottom-up sawing of the given log.
   * @param P - array of saw prices from 0 to n.
   * @param n - length of log to saw in meters.
   * @return maximum profit of sawing log of length n.
   */
  static int logSawBottomUp(int[] P, int n) {
    int[] r = new int[p.length];
    for (int i = 1; i <= n; i++) {
      int pr = 0;
      for (int j = 1; j <= i; j++) {
        pr = Math.max(pr, P[j] + R[i - j]);
      }
      R[i] = pr;
    }
    return R[n];
  }
}
\end{lstlisting}

