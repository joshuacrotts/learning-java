\section{Arrays}

Thus far, all data that we work with has been passed as method parameters. 
When we invoke a method, we have access to the arguments at that point in time. 
\emph{Arrays} allow us to store values, similar to how we use variables, but with the added benefit of storing multiple values in one location.

Arrays store \emph{elements} and \emph{indices} of some type. 
An element is just a value in an array. 
The \emph{index} of an element is its location in the array. 
Indices of an array are indexed from zero, much like strings. 
Thus, the first element of an array is at index zero, whereas the last element is located at the index $|A| - 1$, where $|A|$ denotes the number of elements, or \emph{cardinality}, of some array~$A$.

We store elements contiguously in arrays, where all are of the same type. 
This means that, if we declare an array of type \ttt{int}, we cannot store, for example, a \ttt{String} in that array. 
We can declare an array variable with preset values using \emph{initializer lists}\index{initializer lists}:

\begin{verbnobox}[\small]
int[] array = {5, 10, 15, 20, 100, 50};
\end{verbnobox}

To retrieve the size of an array, the number of elements it can store, we access the \emph{.length} field of the array, e.g., \ttt{array.length}. 
For our example array, we see that its size is six. 
Moreover, \ttt{array[0]} stores \ttt{5} and \ttt{array[5]} stores \ttt{50}. 
Accessing a negative index or an index beyond the bounds of the length results in an \ttt{ArrayIndexOutOfBoundsException}. 
So, accessing \ttt{array[-1]} or \ttt{array[6]}, for instance, crashes the program. 
A common mistake is to access the index at the length of the array to retrieve the last element, which represents a misunderstanding of array indexing.

\enlargethispage{-1\baselineskip}
To declare an array of type~$T$, called~$A$, that stores~$N$ elements, we write the following:

\begin{verbnobox}[\small]
T[] A = new T[N];
\end{verbnobox}

We can store a value~$e$ at an arbitrary index~$i$ of array~$A$, in addition to accessing the value at some index.

\begin{verbnobox}[\small]
// Store "e" at index i of A.
A[i] = e;
// Print out the value at A[i].
System.out.println(A[i]);
\end{verbnobox}

\myexample{Let's declare an integer array~$A$ to store the integers from zero to one hundred in increments of ten.}
\begin{verbnobox}[\small]
int[] A = {0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
\end{verbnobox}

Initializer lists are verbose and require us to explicitly specify each constant. 
A better solution is to initialize the array to a size, and populate its elements using a loop.

\begin{verbnobox}[\small]
final int SIZE = 11;
int[] A = new int[SIZE];
for (int i = 0; i < A.length; i++) { A[i] = i * 10; }
\end{verbnobox}

We use~$i$ to iterate over the possible indices of our array. 
Before we explained that~$i$ is used out of standard loop convention, but we now say that~$i$, in general, stands for either ``iteration'' or ``index.'' 
We assign, to~$A$ at index $i$, the value of $i$ multiplied by ten. 
We can convert the array to a \ttt{String} using a utility method from the \ttt{Arrays} class (note the plural!); a ``string-ified'' array separates each element by commas and surrounds them with braces.

\begin{verbnobox}[\small]
String s1 = Arrays.toString(A);
s1 => {0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100}
\end{verbnobox}

\begin{figure}[tp]
%\begin{wrapfigure}[25]{r}[0.75in]{0.55\textwidth}
  \small
  \begin{tcolorbox}[title=Java Arrays]
    An \emph{array}\index{array} stores a fixed-size collection of elements of some type.
    \vspace{2ex}
    % \hrule
    % \vspace{2ex}
  \begin{description}
    \item [\ttt{$T[]\;A =$ new $T[n]$}] creates an array of type $T$, named $A$, that stores $n$ elements.
    \item [\ttt{$A[i]$}] retrieves the element at index $i^{\text{th}}$ of $A$. We refer to this as position $i + 1$.
    \item [\ttt{$A[i] = v$}] assigns $v$ to index $i$ of $A$.
    \item [\ttt{$A$.length}] returns the number of elements that the array can store.
    \item [\ttt{Arrays.equals}($A_1, A_2$)] returns whether or not the elements of $A_1$ are equal to the elements of $A_2$.
    \item [\ttt{Arrays.toString}$(A)$] returns a string representation of the elements in $A$, separated by commas and enclosed by brackets.
    \item [\ttt{Arrays.fill}$(A, v)$] populates $A$ with $v$ in every index.
    \item [\ttt{Arrays.copyOf}$(A, n)$] returns a new array $A'$ of the same type with the new size, padding with the necessary default elements or truncating.
    \item [\ttt{Arrays.sort}$(A)$] performs an in-place sort of $A$, meaning the contents of $A$ are modified.
  \end{description}
\end{tcolorbox}
  \caption{Useful Array Methods.}
  \label{fig:arrays}
\end{figure}

\enlargethispage{-4\baselineskip}
\myexample{Let's design a method that receives an array of \ttt{double} values and returns the sum of those elements.}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class SumOfDoubleArrayTester {

  @Test
  void testSumOfDoubleArray() {
    assertAll(
      () -> assertEquals(0.0, sumOfDoubles(new double[]{})),
      () -> assertEquals(100.0, sumOfDoubles(new double[]{25.0, 50.0, 25.0})));
  }
}
\end{lstlisting}

Our method uses a local variable to accumulate the ``running sum,'' so to speak, of the values seen so far in the passed array.

\begin{lstlisting}[language=MyJava]
class SumOfDoubleArray {

  /**
   * Computes the sum of the values in a double array.
   * @param arr double [] array of double values.
   * @return sum of those values.
   */
  static double sumOfDoubles(double[] arr) {
    double sum = 0;
    for (int i = 0; i < arr.length; i++) { 
      sum += arr[i]; 
    }
    return sum;
  }
}
\end{lstlisting}

Even though our code works and the tests that we wrote pass without question, there is a bit of verbosity with our loop:~$i$'s purpose is solely for accessing an index into the array. 
In such circumstances, we may prefer using the enhanced \ttt{for} loop\index{enhanced \ttt{for} loop}, which abstracts away the index and provides an iteration construct for accessing elements sequentially.
Why might someone want to use the enhanced \ttt{for} loop over a standard \ttt{for}? 
When we only want to access the elements themselves and not care about their position, the enhanced counterpart is favored; not having to concern ourselves with indices completely removes the possibility of accessing an out-of-bounds index. 

\enlargethispage{2\baselineskip}
\begin{lstlisting}[language=MyJava]
class SumOfDoubleArray {

  static double sumOfDoubles(double arr) {
    double sum = 0;
    for (double e : arr) { 
      sum += e; 
    }
    return sum;
  }
}
\end{lstlisting}

\myexample{Let's design the \ttt{int countOccurs(int[] A, int n)} method, which receives an integer~$n$ and returns the number of times it appears in an array of integers.}
Fortunately this requires exactly one traversal over~$A$ to count the occurrences of~$n$, with no complex cases to consider.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class CountOccursTester {

  @Test
  void testCountOccurs() {
    assertAll(
      () -> assertEquals(0, countOccurs(new int[]{}, 5)),
      () -> assertEquals(3, countOccurs(new int[]{5, 3, 5, 5}, 5)),
      () -> assertEquals(1, countOccurs(new int[]{1, 2, 3, 4, 5}, 5)),
      () -> assertEquals(0, countOccurs(new int[]{1, 2, 3, 4, 5}, 6)));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class CountOccurs {

  /** 
   * Counts the number of occurrences of a value in an int array.
   * @param A array of integers.
   * @param n value to count.
   * @return number of occurrences of n in A.
   */
  static int countOccurs(int[] A, int n) {
    int count = 0;
    for (int e : A) {
      if (e == n) { count++; }
    }
    return count;
  }
}
\end{lstlisting}

\myexample{Consider the \ttt{int[] wordLengths(String[] S)} method.}
Its purpose is, for every index~$i$ of the array~$S$, to store the length of the string at that index in the corresponding index of the returned array.
For example, if~$S$ contains the strings \ttt{"hello"}, \ttt{"world"}, and \ttt{"!"}, the returned array should contain the values~$5$,~$5$, and~$1$, respectively.

\enlargethispage{2\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class WordLengthsTester {

  @Test
  void testWordLengths() {
    assertAll(
      () -> assertEquals(new int[]{5, 5, 1}, 
                         wordLengths(new String[]{"hello", "world", "!"})),
      () -> assertEquals(new int[]{0, 0, 0}, 
                         wordLengths(new String[]{"", "", ""})),
      () -> assertEquals(new int[]{1, 2, 3}, 
                         wordLengths(new String[]{"a", "ab", "abc"})));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class WordLengths {

  /**
   * Computes the lengths of the strings in an array.
   * @param S array of strings.
   * @return array of lengths of the strings in S.
   */
  static int[] wordLengths(String[] S) {
    int[] lengths = new int[S.length];
    for (int i = 0; i < S.length; i++) {
      lengths[i] = S[i].length();
    }
    return lengths;
  }
}
\end{lstlisting}

\myexample{Let's design a method that returns the largest integer in an array of integers.} 
Its algorithm appears straightforward, but can be a little tricky to correctly design because of how we determine the ``largest integer.'' 
Some programmers may choose to declare a value \ttt{largest} and assign it, say,~$-1$, and then if we find a larger value, overwrite the existing value. 
Such an algorithm works well when the provided array contains only positive integers, but what if our array contains only negative numbers less than~$-1$? 
In that scenario, our algorithm would return~$-1$, which is not the largest integer in the array. 
To avoid this issue, we can initialize \ttt{largest} to the first element of the array, and then iterate over the remaining elements, updating \ttt{largest} when we find a larger value.
To simplify the implementation, we assume a precondition that the given array is non-empty.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class LargestIntTester {

  @Test
  void largestIntTester() {
    assertAll(
      assertEquals(4, largestInt(new int[]{4})), 
      assertEquals(13, largestInt(new int[]{12, 13, 10, 9})), 
      assertEquals(-5, largestInt(new int[]{-5, -7, -1932, -6, -6})), 
      assertEquals(9, largestInt(new int[]{9, 9, 9, 9, 9, 9, 9, 9})), 
      assertEquals(0, largestInt(new int[]{-321, -43, 0, -43, -321})), 
      assertEquals(0, largestInt(new int[]{-9, 0, -8, -7, -1234})));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class LargestInt {

  static int largestInt(int[] arr) {
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
      if (arr[i] > max) { max = arr[i]; }
    }
    return max;
  }
}
\end{lstlisting}

A slightly more compact solution is to wrap the conditional inside a call to \ttt{Math.max}, since the logic is effectively identical: \ttt{max = Math.max(arr[i], max)}.

Java arrays are rather primitive compared to other more-complex data structures.\footnote{Do not conflate this use of the ``primitive'' term with its use in describing ``primitive datatypes.''} 
The \ttt{Arrays} class provides a few convenient methods for working with arrays, but for the most part, arrays serve as the backbone of other data structures. 
Arrays guarantee \emph{constant access}\index{constant access} times for elements. 
That is, if we know the index of an element~$e$, we retrieve or modify it using the aforementioned array bracket syntax. 

\myexample{Suppose we want to design a method that returns the index of an element~$e$ of an array of \ttt{String} values.} 
Doing so is not a challenge: check each element, one-by-one, until we find the desired element, or return~$-1$. 
Note the parallelism to the \ttt{String} class' \ttt{indexOf} method.
To get practice using both recursion and iteration, we will design two versions of this method: one that uses tail recursion and the other that uses a loop.\footnote{When recursing over an array, it is common to always have a parameter to represent the~$i^\text{th}$ index, which corresponds to the current element. Note that this can be accomplished through both standard and tail recursion.} 
The tail recursive method recurses over the accumulator, which serves as the current index to check.\footnote{We do \emph{not} use standard recursion for this particular problem because returning~$-1$ would result in an incorrect final value when unwinding the recursive calls.} 
If this value exceeds the bounds of the array, we return~$-1$. 
If~$S[i]$ is equal to~$k$, we return~$i$. 
Otherwise, we recurse and increment~$i$ by one. 
The tests for these two are both trivial to design.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class ArrayFinderTailRecursiveTester {

  @Test
  void testArrayFinderTailRecursive() {
    String[] arrS = new String[]{"Hello", "hi", "hiya", "howdy", "hello"};
    assertAll(
      () -> assertEquals(2, indexOfTR(arrS, "hiya")),
      () -> assertEquals(0, indexOfTR(arrS, "Hello")),
      () -> assertEquals(4, indexOfTR(arrS, "hello")),
      () -> assertEquals(-1, indexOfTR(arrS, "ahoy")));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class ArrayFinder {

  static int indexOfTR(String[] arrS, String k) {
    return indexOf(arrS, k, 0);
  }

  private static int indexOfTRHelper(String[] arrS, String k, int i) {
    if (i >= arrS.length) { return -1; } 
    else if (arrS[i].equals(k)) { return i; } 
    else { return indexOfHelper(arrS, k, i + 1); }
  } 
}
\end{lstlisting}

In converting the tail recursive solution to use iteration, we will use the translation pipeline. 
Our base case is when~$i$ equals or exceeds the length of the array, so the negated expression is our loop condition. 
Moreover, we place a conditional statement inside the loop, which returns whether~$S[i]$ equals~$k$ for that value of~$i$ and, if so, we return~$i$. 
We might also form a conjunction between the two conditions whose exit condition is when one of those conditions is falsified. 
Because we have two different atomic return values, though, we will use the former approach. 
The test cases for this method are identical to the tail recursive version.

\begin{lstlisting}[language=MyJava]
class ArrayFinder {

  static int indexOfLoop(String[] arrS, String k) {
    int i = 0;
    while (!(i >= arrS.length)) {
      if (arrS[i].equals(k)) { 
        return i; 
      }
    }
    return -1;
  }
}
\end{lstlisting}

The conventional solution to this problem, especially since we know the upper bound on the number of iterations, involves a \ttt{for} loop. 
A \ttt{for} loop, as we now know, localizes the accumulator variable. 
Moreover, we \emph{could} use the translation pipeline conditional expression, but it is idiomatic to loop while the index is less than the length of the array, and use an expression that describes this relationship.

\begin{lstlisting}[language=MyJava]
class ArrayFinder {
  
  static int indexOfLoop(String[] arrS, String k) {
    for (int i = 0; i < arrS.length; i++) {
      if (arrS[i].equals(k)) { 
        return i; 
      }
    }
    return -1;
  }
}
\end{lstlisting}

\myexample{Imagine that we are writing a multiple choice question exam score calculator.} Correct answers award three points, incorrect answers remove one point, and a \ttt{"?"} represents a guess, which neither awards nor removes points. 
Let's design a method that receives two \ttt{String} arrays representing the expected answers~$E$ and the actual answers~$A$, and returns the score as a percentage. 
We will assume that~$|E|=|A|$. 
Again, to gain practice with recursion and iteration, we'll design three versions of the \ttt{score} method.

First, we need to once again recognize that, because the method receives an array to recurse over, the method must receive a parameter representing the index-to-check. 
Though, we do not wish to expose to the caller how \ttt{score} works, so we can design a private helper method. 
Our base case occurs when~$i \geq |E|$, in which we return zero. 
Otherwise, we have a case analysis on the~$i^\text{th}$ actual answer: if it equals the~$i^\text{th}$ expected answer, we award three points. 
If it is equal to a question mark string, i.e., \ttt{"?"} then we award no points. 
Otherwise, the answer is incorrect, meaning we deduct one point. 
Because a negative score is nonsensical, our driver method returns the maximum of zero and the score to filter out negative values.

\enlargethispage{-3\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class McqScoreCalculatorTester {

  @Test
  void testScore() {    
    String[] E = new String[]{"A","C","D","A","B","B","D","C","C"};
    String[] A1 = new String[]{"A","C","D","C","B","B","C","C","C"};
    String[] A2 = new String[]{"A","C","D","A","B","B","D","C","C"};
    String[] A3 = new String[]{"A","C","?","C","?","B","?","C","C"};
    assertAll(
      () -> assertEquals(70.3, score(E, A1)),
      () -> assertEquals(100.0, score(E, A2)),
      () -> assertEquals(51.8, score(E, A3)));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class McqScoreCalculator {

  /**
   * Computes the score of a test.
   * @param E expected test answers.
   * @param A answers provided.
   * @return score of test, >= 0.
   */
  static double score(String[] E, String[] A) {
    int maxScore = E.length * 3;
    return Math.max(0, scoreHelper(E, A, 0)) / maxScore * 100;
  }

  /**
   * Recursively computes the score of an exam.
   * @param E expected answers.
   * @param A answers provided.
   * @param i index-to-check.
   * @return score of test.
   */
  private static double scoreHelper(String[] E, String[] A, int i) {
    if (i >= A.length) { return 0; }
    else if (A[i].equals(E[i])) { return 3 + scoreHelper(E, A, i + 1); }
    else if (A[i].equals("?")) { return scoreHelper(E, A, i + 1); }
    else { return -1 + scoreHelper(E, A, i + 1); }
  }
}
\end{lstlisting}

The tail recursive solution is almost identical to the standard recursive variant. The essential difference is that we accumulate the score as a parameter in between recursive calls instead of summing the points when unwinding the calls. Aside from that, everything else remains the same. Our tests from \ttt{score} are likewise suitable for both the tail recursive and loop methods.

\enlargethispage{-5\baselineskip}
\begin{lstlisting}[language=MyJava]
class McqScoreCalculator {

 /**
  * Computes the score of a test.
  * @param E expected test answers.
  * @param A answers provided.
  * @return score of test, >= 0.
  */
  static double scoreTR(String[] E, String[] A) {
    return Math.max(0, scoreTRHelper(E, A, 0, 0)) / (E.length * 3) * 100;
  }
 
  /**
   * Recursively computes the score of an exam.
   * @param E expected answers.
   * @param A answers provided.
   * @param i index-to-check.
   * @param s currently-accumulated score.
   * @return score of test.
   */
  private static double scoreTRHelper(String[] E, String[] A, 
                                      int i, int s) {
    if (i >= E.length) { return s; }
    else if (A[i].equals(E[i])) { return scoreTRHelper(E, A, i+1, s+3); }
    else if (A[i].equals("?")) { return scoreTRHelper(E, A, i+1, s); }
    else { return scoreTRHelper(E, A, i + 1, s + -1); }
  }
}
\end{lstlisting}

Lastly, the loop variant is just a translation pipeline away. 
When traversing over arrays, though, it is much more colloquial to use a \ttt{for} loop, since the bounds are known a priori.

\begin{lstlisting}[language=MyJava]
class McqScoreCalculator {

 /**
  * Computes the score of a test.
  * @param E expected test answers.
  * @param A answers provided.
  * @return score of test, >= 0.
  */
  static double scoreLoop(String[] E, String[] A) {
    int score = 0;
    int i = 0;
    while (!(i >= A.length)) {
      if (A[i].equals(E[i])) { score += 3; } 
      else if (A[i].equals("?")) { score += 0; } 
      else { score += -1; }
      i++;
    }
    int maxScore = E.length * 3;
    return Math.max(0, score) / maxScore * 100;
  }
}
\end{lstlisting}

The key ideas with this example are twofold: first, a helper method does not always have to be tail recursive. 
Second, a standard recursive method can leverage a helper method when necessary.

We are on our way to understanding the full signature of the \ttt{main} method. 
Now that we have covered arrays, we know what the \ttt{String[] args} parameter represents, but \emph{why} it receives that array of strings remains a mystery. 
We can compile Java files using the terminal and the \ttt{javac} command. 
Moreover, when executing a Java file, we may pass to it \emph{terminal arguments}\index{terminal arguments}, which are values that the program might use to configure settings or process at runtime.

\myexample{Suppose we want to write a program, using the \ttt{main} method and terminal arguments, that evaluates an arithmetic operation on a collection of integers values, e.g., $5 + 3 + 17$.}
Additionally, we might want to let the user pass \emph{flags} to denote these different operations, such as \ttt{--add} for addition, \ttt{--sub} for subtraction, and so on. 
So the user is not confused, we might also provide a ``help'' option that is displayed either upon request or when incorrect arguments are supplied.

First, we must explain how terminal arguments work. 
Terminal arguments are specified after the executable (name) and are separated by spaces. 
For instance, if our program name is \ttt{calculator}, we might use \ttt{./calculator --add 5 4 17}. 
Thus, \ttt{args[0]} is \ttt{--add}, \ttt{args[1]} is \ttt{"5"}, \ttt{args[2]} is \ttt{"4"}, and \ttt{args[3]} is \ttt{"17"}. 
For simplification purposes, we will assume that the first argument is always the operation/help flag, and the remaining values are operands. 
This means that the program should output \ttt{26}. 
Let's design a method that parses the operation/help flag. 
Upon success, it returns \ttt{true} and upon failure, it returns \ttt{false}. 
This prevents the program from further interpreting bad terminal arguments, e.g., \ttt{./calculator --wrong 5 12}. 
We will also use \ttt{false} as an indication that the \ttt{help} menu was requested or prompted. 
Thus, to not duplicate code, we should design another method that displays the relevant program usage information.

%\enlargethispage{4\baselineskip}
\begin{lstlisting}[language=MyJava]
class Calculator {

  public static void main(String[] args) {
    if (parseCommand(argv[0])) {
      // Continue.
    }
    // Otherwise, stop.
  }

  static boolean parseCommand(String cmd) {
    if (cmd.equals("--add") || cmd.equals("--sub")) {
      return true;
    } else {
      displayHelp();
      return false;
    }
  }

  static void displayHelp() {
    System.out.println("usage: ./calculator --(help | add | sub) <n1> 
                        [n...]");
  }
}
\end{lstlisting}

Up next is the process of interpreting each valid operation, i.e., \ttt{--add} and \ttt{--sub}. 
The former will add each successive argument one-by-one while the latter subtracts them from left-to-right. 
Because we receive the terminal arguments as strings, we will need to convert their values from strings to double values using \ttt{Double.parseDouble}. 
For the time being, we will assume that these \emph{are}, in fact, double values, rather than working through the painstaking process of parsing a string for the existence of a proper \ttt{double} datatype value. 
We encourage the readers to implement this method themselves, along with the appropriate tests.

Note that in the code below, we utilize an \ttt{if/else if} combination without an accompanying \ttt{else}, which we would normally discourage. 
Because we exhaust the possibilities with \ttt{parseCommand}, however, we will allow its usage. 
The \ttt{parseAdd} and \ttt{parseSub} methods are trivial and we have shown an example of their implementation previously, so we will also omit these to preserve space and avoid unnecessary repetition.

\begin{lstlisting}[language=MyJava]
class Calculator {

  public static void main(String[] args) {
    if (parseCommand(args[0])) {
      String cmd = args[0];
      double[] operands = convertToDoubleArray(args);
      if (cmd.equals("--add")) {
        System.out.println(parseAdd(operands));
      } else if (cmd.equals("--sub")) {
        System.out.println(parseSub(operands));
      }
    }
  }
}
\end{lstlisting}

\myexample{Let's write a program that receives a list of integers through the terminal, as an ``argument array'' of sorts, and allow the user to pass flags to denote the operation to perform on the list.} 
Our program will support the following operations: \ttt{--sum}, \ttt{--product}, \ttt{--min}, and \ttt{--max} command. 
We will also provide a \ttt{--help} flag that displays the program usage information. 
This is a substantial project, but doing so allows us to practice using arrays and integrating more complex terminal arguments. 
As a measure of simplification, we will assume that the first~$n$ arguments are the numeric values, and the remaining arguments are the operation flags. 
Let's further assume that the user will not pass an invalid command. 
Lastly, we shall not consider invalid inputs for a given context, e.g., the minimum/maximum when no input values are provided. 
The first terminal argument denotes the number of values to expect, so we will use it to initialize our array.

To start, let's see a few example runs of our program, containing a mixture of flags.

%\enlargethispage{4\baselineskip}
% \begin{verbnobox}[\small]
% ./ArrayArguments 5 1 2 3 4 5 --sum --max
% sum: 15.000000
% max: 5.000000

% ./ArrayArguments 3 100 200 -100 --product --sum --min
% sum: 200.000000
% product: -2000000.000000
% min: -100.000000

% ./ArrayArguments --help
% usage: ./ArrayArguments <n> <n1> [n...] [--(sum | product | min | max)]
% \end{verbnobox}
\begin{small}
\begin{verbatim}
./ArrayArguments 5 1 2 3 4 5 --sum --max
sum: 15.000000
max: 5.000000

./ArrayArguments 3 100 200 -100 --product --sum --min
sum: 200.000000
product: -2000000.000000
min: -100.000000

./ArrayArguments --help
usage: ./ArrayArguments <n> <n1> [n...] [--(sum | product | min | max)]
\end{verbatim}
\end{small}

The ordering of the output is irrelevant, and depends on how we parse the input flags in the main method. 
To scan for a given flag, let's design a static method to return whether or not the flag exists in the arguments array.

\enlargethispage{-3\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class ArrayArgumentsTester {

  @Test
  void testScanForFlag() {
    String[] args = new String[]{"--sum", "--max", "--min"};
    assertAll(
      () -> assertEquals(true, isFlagPresent(args, "--sum")),
      () -> assertEquals(true, isFlagPresent(args, "--max")),
      () -> assertEquals(true, isFlagPresent(args, "--min")),
      () -> assertEquals(false, isFlagPresent(args, "--product")));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class ArrayArguments {

  /**
   * Returns whether or not a given flag exists in the arguments array.
   * @param args array of arguments.
   * @param flag flag to search for.
   * @return whether or not the flag exists.
   */
  static boolean isFlagPresent(String[] args, String flag) {
    for (String arg : args) {
      if (arg.equals(flag)) { 
        return true; 
      }
    }
    return false;
  }
}
\end{lstlisting}

The other ``operations'' methods, as well as their tests, are simple to create, and we will omit their implementation. 

Our main method first checks to see if the user entered the ``help'' command and, if so, presents the necessary information for running the program. 
Otherwise, we perform a case analysis on the terminal arguments, looking for the presence of the operation flags. 
For arbitrary reasons, we output the sum, then the product, then the minimum, and finally the maximum, in that order, despite the ordering of the flags. 
As an exercise, we encourage the readers to modify the program to instead output the values in the order of the presented flags. 

An important detail that some may miss is that we use a sequence of \ttt{if} statements, instead than \ttt{if/else if} statements. 
This is because we want to allow the user to pass multiple flags; we would unintentionally restrict them to exactly one flag with \ttt{if/else if} statements. 
Each flag is checked independently from one another, and whether a flag is entered does not affect the state of another.

\enlargethispage{-6\baselineskip}
\begin{lstlisting}[language=MyJava]
class ArrayArguments {

  public static void main(String[] args) {
    if (isFlagPresent(args, "--help")) {
      displayHelp();
    } else {
      int n = Integer.parseInt(args[0]);
      double[] values = new double[n];
      for (int i = 0; i < n; i++) { 
        values[i] = Double.parseDouble(args[i + 1]); 
      }
      if (isFlagPresent(args, "--sum")) { 
        System.out.printf("sum: %f\n", sum(values)); 
      }
      if (isFlagPresent(args, "--product")) { 
        System.out.printf("product: %f\n", product(values)); 
      }
      if (isFlagPresent(args, "--min")) { 
        System.out.printf("min: %f\n", min(values)); 
      }
      if (isFlagPresent(args, "--max")) { 
        System.out.printf("max: %f\n", max(values)); 
      }
    }
  }
}
\end{lstlisting}

\myexample{Arrays are not restricted to being only one dimensional.} 
In this problem, we will make use of a two-dimensional array, which might be thought of as a matrix or a grid. 
Namely, we'll design a method that returns the sum of the elements of a two-dimensional array of integers. 
Traversing over an~$n$-dimensional array generally involves nested loops. 
The order in which we traverse over the array can be significant. 
For example, the following code uses \emph{row-major}\index{row-major} ordering, since we iterate over the rows first, and then the columns, meaning that we visit the elements (of a $3\times{3}$ array) in the order
\[
  A_{0,0}, A_{0,1}, A_{0,2}, A_{1,0}, A_{1,1}, A_{1,2}, A_{2,0}, A_{2,1}, A_{2,2}
\] 
Conversely, \emph{column-major}\index{column-major} ordering would visit the elements in the order
\[
  A_{0,0}, A_{1,0}, A_{2,0}, A_{0,1}, A_{1,1}, A_{2,1}, A_{0,2}, A_{1,2}, A_{2,2}
\]
Multi-dimensional arrays are nothing more than arrays of arrays. 
As an example, we can declare a $3 \times 4$ two-dimensional array of integers (with three rows and four columns) as follows:\footnote{The spacing/positioning of the rows/elements is irrelevant; we could type the rows side-by-side and we would have the same resulting array.}

\begin{verbnobox}[\small]
int[][] A = {{1, 2, 3, 4}, 
             {5, 6, 7, 8}, 
             {9, 10, 11, 12}};
\end{verbnobox}

\enlargethispage{-3\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class SumOf2DArrayTester {

  @Test
  void testSumOf2DArray() {
    int[][] A = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
    assertAll(
      () -> assertEquals(78, sumOf2DArray(A)),
      () -> assertEquals(0, sumOf2DArray(new int[][]{})),
      () -> assertEquals(1, sumOf2DArray(new int[][]{{1}})));
  }
}
\end{lstlisting}

We need to know both the number of rows and the number of columns to traverse over a two-dimensional array. 
To retrieve the number of rows, we refer to the array's length via \texttt{$A$.length}. 
To get the number of columns, again, because we know that~$A$ is an array of one-dimensional arrays, we use \ttt{$A[0]$.length}, or in general, \ttt{$A[i]$.length} for any~$i$ such that $0 \leq i< $ \ttt{$A$.length}.\footnote{This generalization applies because arrays in Java cannot be \emph{ragged}: where different rows/columns have differing sizes.} To access the element at row~$i$ and column~$j$, we use \ttt{$A[i][j]$}. 

\begin{lstlisting}[language=MyJava]
class SumOf2DArray {

  /**
   * Computes the sum of the values in a two-dimensional array.
   * @param arr two-dimensional array of integers.
   * @return sum of those values.
   */
  static int sumOf2DArray(int[][] arr) {
    int sum = 0;
    for (int i = 0; i < arr.length; i++) {
      for (int j = 0; j < arr[i].length; j++) {
        sum += arr[i][j];
      }
    }
    return sum;
  }
}
\end{lstlisting}

\myexample{Let's design the \ttt{int[][] removeAllZeroRows(int[][] A)} method that removes all rows from a two-dimensional array of integers that contain a~$0$.}
Remember that arrays are immutable, so we instead return a new array with the appropriate alterations.
For example, suppose our array~$A$ contains the following values:

\[
\begin{bmatrix}
  3&4&5&6\\
  7&0&8&9\\
  10&11&21&13\\
  2&2&2&0\\
  0&2&2&2
\end{bmatrix}
\]

\enlargethispage{-4\baselineskip}
\noindent{}Invoking \ttt{removeAllZeroRows} returns a new array~$A'$:

\[
\begin{bmatrix}
  3&4&5&6\\
  10&11&21&13\\
\end{bmatrix}
\]

A problem that we immediately stumble upon is not knowing the resulting array size.
Before a traversal over the input array~$A$, we cannot predict how many rows will need to be removed.
Thus, to design the \ttt{removeAllZeroRows} method, we need two helper methods, namely \ttt{boolean containsZero(int[] A)} and \ttt{int countZeroRows(int[][] A)}, which returns whether a row contains a zero and the number of rows that contain at least one~$0$ respectively.
Both implementations are nothing more than a single traversal over all elements in the array, so we will not design a test suite.
Moreover, because they are private, a global test suite for either is not appropriate.
After its implementation is complete, we can work on \ttt{removeAllZeroRows}. 
The number of columns in the resulting array is fixed.
The number of rows, however, is not, so we invoke \ttt{countZeroRows} and instantiate the resulting array to the correct size.
Thereafter we traverse over the array twice: one to determine if it contains a zero and, if not, add every element to the new array.
We must be careful to correctly access the resulting array; recall that its number of rows is at most equal to~$A$'s row count, so we need a separate variable to index into its rows.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertArrayEquals;

class RemoveAllZeroRowsTester {

  @Test
  void testRemoveAllZeroRowsTester() {
    int[][] A1 = {{3, 4, 5, 6}, 
                  {7, 0, 8, 9}, 
                  {10, 11, 21, 13}, 
                  {2, 2, 2, 0}, 
                  {0, 2, 2, 2}};
    int[][] R1 = {{3, 4, 5, 6}, 
                  {10, 11, 21, 13}};
    int[][] A2 = {{2, 4}, 
                  {5, 6}};
    int[][] R2 = {{2, 4}, 
                  {5, 6}};
    int[][] A3 = {{0, 10, 30},
                  {90, 100, 0}};
    int[][] R3 = {{}};
    assertAll(
      () -> assertArrayEquals(R1, removeAllZeroRows(A1)),
      () -> assertArrayEquals(R2, removeAllZeroRows(A2)),
      () -> assertArrayEquals(R3, removeAllZeroRows(A3)));
  }
}
\end{lstlisting}

\enlargethispage{-4\baselineskip}
\begin{lstlisting}[language=MyJava]
class RemoveAllZeroRows {

  /**
   * Removes all rows from a 2D array that contain at least one zero.
   * @param A a 2D array of integers.
   * @return a new 2D array with all zero rows removed.
   */
  static int[][] removeAllZeroRows(int[][] A) {
    int numRows = A.length - countZeroRows(A);
    int numCols = A[0].length;
    int[][] res = new int[numRows][numCols];
    for (int i = 0, rIdx = 0; i < A.length; i++) {
      if (!containsZero(A[i])) {
        for (int j = 0; j < A[i].length; j++) {
          res[rIdx][j] = A[i][j];
        }
        rIdx++;
      }
    }
    return res;
  }

  /**
   * Checks if an array contains a zero.
   * @param A an array of integers.
   * @return true if the array contains a zero, false otherwise.
   */
  private static boolean containsZero(int[] A) {
    for (int x : A) {
      if (x == 0) { 
        return true; 
      }
    }
    return false;
  }

  /**
   * Counts the number of rows in a 2D array that contain at least one zero.
   * @param A a 2D array of integers.
   * @return number of rows that have at least one zero.
   */
  private static int countZeroRows(int[][] A) {
    int count = 0;
    for (int[] r : A) {
      if (containsZero(r)) {
        count++;
      }
    }
    return count;
  }
}
\end{lstlisting}

\enlargethispage{2\baselineskip}
\myexample{Let's solve a slightly harder problem using two-dimensional arrays.} 
Suppose that we want to design a method that returns the number of possible moves that a rook can take to go from the top-left of a (not-necessarily rectangular) board to the bottom-right, assuming that it cannot move left or up. 
The naive solution to this problem is to use a recursive method that changes its position by one in either direction, stopping once we hit the bottom-right of the board. 
Assuming the rook starts at~$(x, y)$ and the board is~$n \times m$, we can design the following method:

%\enlargethispage{5\baselineskip}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RookPathTester {

  @Test
  void testRookPath() {
    assertAll(
      () -> assertEquals(2, rook(0, 0, 1, 1)),
      () -> assertEquals(6, rook(0, 0, 2, 2)),
      () -> assertEquals(10, rook(0, 0, 2, 3)),
      () -> assertEquals(70, rook(0, 0, 4, 4)));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class RookPath {

  /**
   * Computes the number of possible paths that a rook 
   * can take to go from the top-left of a board to the 
   * bottom-right, assuming that it cannot move left or up.
   * @param x x-coordinate of the rook's starting position.
   * @param y y-coordinate of the rook's starting position.
   * @param n number of rows of the board.
   * @param m number of columns of the board.
   * @return number of possible paths.
   */
  static int rook(int x, int y, int n, int m) {
    if (x == n || y == m) { 
      return 1; 
    } else { 
      return rook(x + 1, y, n, m) + rook(x, y + 1, n, m); 
    }
  }
}
\end{lstlisting}

Much like how the recursive definition of Fibonacci is horrendously slow, so is this implementation of the rook path problem. 
We need a faster algorithm, and indeed, we can take advantage of a two-dimensional array because of an emerging pattern. 
Notice that, in the bottom-right corner, there is only one possible solution. 
We can generalize this to say that there is only one solution for any position in the bottom row or the far-right column. 
From here, we can work our way up and to the left, filling in the number of possible solutions for each position. 

For example, the position $(n - 1, m - 1)$ has a value of two, since it can move either right or down. 
The position $(n - 2, m - 1)$ has a value of three, since it can move right, down, or down and then right. 
We continue this process until we reach the top-left corner, which contains the value of the number of possible paths from $(0, 0)$ to $(n, m)$.\footnote{Should we want to choose an arbitrary starting point, we can retrieve that index rather than $(0, 0)$ in the resulting two-dimensional array.} 
We can design a method that computes this value using a two-dimensional array. 
Composing the solution using this style is called \emph{dynamic programming}\index{dynamic programming}, which comes up often when attempting to optimize problems that have naive and outrageously recursive solutions.

To prevent our code from going out of bounds, we need to add one to the bounds of our input array. 
That is, if we want to compute the number of possible paths from $(0, 0)$ to $(n, m)$, we need to create an array of size $(n + 1) \times (m + 1)$, because the current value of the array at $(n, m)$ depends on the values of the array at $(n + 1, m)$ and $(n, m + 1)$.\footnote{When writing dynamic programming algorithms, it is commonplace to call the auxiliary data structure \ttt{dp} out of convention.} 

Dynamic programming\index{dynamic programming} problems are often solved using two-dimensional arrays using the following three-step process: 

\begin{enumerate}
  \item For a problem size of~$n$ and~$m$, we first initialize a two-dimensional array of size~$(n + 1) \times (m + 1)$.
  \item Populate the array with the necessary base cases.
  \item Iterate over the array, filling in the values using a recurrence relation.
\end{enumerate}

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RookPathTester {

  @Test
  void testRookPathDp() {
    assertAll(
      () -> assertEquals(2, rookDp(0, 0, 1, 1)),
      () -> assertEquals(6, rookDp(0, 0, 2, 2)),
      () -> assertEquals(10, rookDp(0, 0, 2, 3)),
      () -> assertEquals(70, rookDp(0, 0, 4, 4)));
  }
}
\end{lstlisting}

\enlargethispage{2\baselineskip}
\begin{lstlisting}[language=MyJava]
class RookPath {

  /**
   * Computes the number of possible paths that a rook 
   * can take to go from the (x, y) position of a board 
   * to the bottom-right, assuming that it cannot move left or up. 
   * This approach uses dynamic programming.
   * @param x x-coordinate of the rook's starting position.
   * @param y y-coordinate of the rook's starting position.
   * @param n number of rows of the board.
   * @param m number of columns of the board.
   * @return number of possible paths.
   */
  static int rookDp(int x, int y, int n, int m) {
    int[][] dp = new int[n + 1][m + 1];

    // Compose the initial bottom-row solutions.
    for (int i = 0; i < n + 1; i++) { dp[i][m] = 1; }

    // Compose the initial far-right solutions.
    for (int i = 0; i < m + 1; i++) { dp[n][i] = 1; }

    // Now do the dynamic programming algorithm.
    for (int i = n - 1; i >= 0; i--) {
      for (int j = m - 1; j >= 0; j--) {
        dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
      }
    }
    return dp[x][y];
  }
}
\end{lstlisting}

\myexample{Let's solve another foundational dynamic programming problem, only this time we utilize only a one-dimensional array.}
Imagine that we're working at a lumber store that saws wood logs for manufacturing purposes. 
We sell and saw wood logs by the meter.
Different lengths of a log cost different amounts, and we want to maximize the profits made when sawing the logs. 
For example, consider the following table:

\begin{center}
  \begin{tabular}{|c||*{9}{>{\centering\arraybackslash}p{1cm}|}}
    \hline
    Length (meters) & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
    \hline
    Cost (USD) & 0 & 1 & 4 & 6 & 7 & 12 & 18 & 25 & 30 \\
    \hline
  \end{tabular}
\end{center}
  
Suppose our wood log is~$4$ meters long. 
There are, therefore, $2^{(4-1)}=2^3=8$ ways to saw the log:
`$1\,|\,1\,|\,1\,|\,1$', `$1\,|\,1\,|\,2$', `$1\,|\,2\,|\,1$', `$1\,|\,3$', `$2\,|\,1\,|\,1$', `$2\,|\,2$', `$3\,|\,1$', and `$4\,|\,0$.' 
If we compute the prices of these sawings, we get $1+1+1+1=4$, $1+4+1=6$, $1+1+4=6$, $1+6=7$, $4+1+1=6$, $4+4=8$, $6+1=7$, and $7=7$. 
So, to maximize our profit, we want to saw the log into two pieces, each of which are~$2$ meters long.

The question is, how do we determine the maximum profit algorithmically? 
Decomposing the problem shows us that we first saw the log into size~$i$ meters, then try to maximize the profit made from sawing the rest of the log, which has size~$n - i$ meters. 
The relationship is recursive, and we can design a method to simulate it.
Namely, we try all possible sawings of size~$i$ using a loop, then recursively decompose the problem.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class LogSawTester {

  @Test
  void testLogSaw() {
    assertAll(
      () -> assertEquals(0, logSaw(new int[]{0}));
      () -> assertEquals(8, logSaw(new int[]{0,1,4,6,7,12,18,25,30})));
  }
}
\end{lstlisting}

\begin{lstlisting}[language=MyJava]
class LogSaw {
  
  /**
   * Performs a traditional recursive sawing of the given log.
   * Warning: this algorithm is outrageously slow!
   * @param P array of saw prices from 0 to n.
   * @param n length of log to saw in meters.
   * @return maximum profit of sawing log of length n.
   */
  static int logSaw(int[] P, int n) {
    if (n == 0) {
      return 0;
    } else {
      int r = 0;
      for (int i = 1; i <= n; i++) {
        r = Math.max(r, P[i] + logSaw(P, n - i));
      }
      return r;
    }
  }
}
\end{lstlisting}

While the recursive algorithm works, it is horribly inefficient; we saw the log at \emph{all} possible intervals, meaning there are several repeated computations. 
Similar to Fibonacci, \ttt{logSaw} is an exponential-time algorithm! 
We can do better.

Like we said, we're repeatedly sawing at places whose maximal price has already been determined.
So, let's design another recursive method that passes along an array~$L$ of stored (maximal) sawings.
After trying all sawings from~$1$ to~$n$, we store the maximum saw price for length~$n$ in $L$ at index~$n$.
When recursing, if there is a non-zero element at index~$n$, we know that its value was computed earlier and can return it accordingly.

This variant is leaps and bounds better than the original algorithm, taking its runtime from exponential down to quadratic in the length of the given log. 
We consider the algorithm to be ``top-down memoized,'' because the solution recurses from~$n$ down to~$1$, and it stores partial solutions in an array (i.e., memoizing). 

\begin{lstlisting}[language=MyJava]
class LogSaw {

  /**
   * Performs a top-down sawing of the given log.
   * @param P array of saw prices from 0 to n.
   * @param n length of log to saw in meters.
   * @return maximum profit of sawing log of length n.
   */
  static int logSawTopDown(int[] P, int n) {
    int[] R = new int[P.length];
    return logSawTopDownHelper(P, R, n);
  }

  /**
   * Helper method for top-down log saw algorithm.
   * @param P array of saw prices from 0 to n.
   * @param R intermittient saw prices; memoized.
   * @param n length of log in meters.
   * @return maximum profit for log of size n.
   */
   private static int logSawHelper(int[] P, int[] R, int n) {
    if (R[n] > 0) {
      return R[n];
    } else if (n == 0) {
      return n;
    } else {
      int pr = 0;
      for (int i = 1; i <= n; i++) {
        pr = Math.max(pr, P[i] + logSawHelper(P, R, n - i));
      }
      R[n] = pr;
      return pr;
    }
  }
}
\end{lstlisting}

Though, we still have to worry about recursive depth for sufficiently large values of~$n$. 
Let's take the algorithm one step further and convert it into a ``bottom-up'' iterative algorithm.
In essence, rather than making recursive calls, we use two loops and compose the solution to larger problems (i.e., larger values of~$n$) by saving (intermittent) solutions to smaller problems (i.e., smaller values of~$n$).
The tests for the top-down and bottom-up methods are the same as the standard recursive version.

\enlargethispage{-1\baselineskip}
\begin{lstlisting}[language=MyJava]
class LogSaw {

  /**
   * Performs a bottom-up sawing of the given log.
   * @param P array of saw prices from 0 to n.
   * @param n length of log to saw in meters.
   * @return maximum profit of sawing log of length n.
   */
  static int logSawBottomUp(int[] P, int n) {
    int[] r = new int[p.length];
    for (int i = 1; i <= n; i++) {
      int pr = 0;
      for (int j = 1; j <= i; j++) {
        pr = Math.max(pr, P[j] + R[i - j]);
      }
      R[i] = pr;
    }
    return R[n];
  }
}
\end{lstlisting}

\myexample{A bank robber is heisting a local jewelry store, and a priori knows the weight and value of each item in the showcases.\footnote{We, the authors, do not condone robbing your local jewelry store.}} 
The robber can only carry up to a maximum of~$m$ ounces of jewelry and wants to develop an algorithm that calculates the highest attainable profit.

Given an array of jewelry values~$V$ and weights in ounces~$W$, we can find the maximum possible profit by brute forcing every combination of items. 
That is, at each choice of jewelry, the robber either does or does not steal the item in the showcase. 
Making two recursive calls that represent these decisions is easily conceivable; 
the base case is whether or not we are out of items to check, in which case we return zero as the profit. 
If the item-in-question exceeds the weight of the items currently in the robber's bag, then we must skip over it. 
For example, if a piece of jewelry~$j$ weighs~$3$ ounces and the robber has a $16\text{oz}$ bag that contains $14\text{oz}$ of jewelry, the robber cannot add~$j$ to their bag.

\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class MaxJewelProfitTester {

  @Test
  void testMaxJewelProfit() {
    int[] V1 = new int[]{1, 2, 4, 2, 5};
    int[] W1 = new int[]{5, 3, 5, 3, 2};
    int[] V2 = new int[]{7, 5, 5};
    int[] W2 = new int[]{4, 2, 2};
    assertAll(
      () -> assertEquals(9, maxJewelProfit(V1, W1, 8)),
      () -> assertEquals(10, maxJewelProfit(V2, W2, 4)));
  }
}
\end{lstlisting}

\enlargethispage{-2\baselineskip}
\begin{lstlisting}[language=MyJava]
class MaxJewelProfit {

  /**
   * Given a list of jewels with values V and weights W, and a 
   * bag with a maximum weight m, returns the maximum value of 
   * jewels that can be picked.
   * @param V values of the jewels.
   * @param W weights of the jewels.
   * @param m maximum weight that the bag can hold.
   * @return the maximum value of jewels that can be picked.
   */
  static int maxJewelProfit(int[] V, int[] W, int m) {
    return maxJewelProfitHelper(V, W, m, 0);
  }

  /**
   * Helper method for maxJewelProfit. Uses the brute-force approach 
   * of trying all possible combinations of picking and not picking each jewel.
   * @param V values of the jewels.
   * @param W weights of the jewels.
   * @param m current weight remaining in the bag.
   * @param i current index of the jewel we are considering.
   * @return the maximum value of jewels that can be picked.
   */
  private static int maxJewelProfitHelper(int[] V, int[] W, int m, int i) {
    if (i >= V.length || m == 0) {
      return 0;
    } else {
      int noPick = maxJewelProfitHelper(V, W, m, i + 1);
      // If we can fit it, then do so.
      if (m - W[i] >= 0) {
        int pick = V[i] + maxJewelProfitHelper(V, W, m - W[i], i + 1);
        return Math.max(pick, noPick);
      } else {
        // If we can't, then just use the result from "no pick."
        return noPick;
      }
    }
  }
}
\end{lstlisting}

Like many algorithm that makes two subsequent recursive calls, this is horribly inefficient, being yet again an exponential time algorithm. 
Dynamic programming\index{dynamic programming}g rescues us once more by caching the results to intermediate ``robberies.''
By intermediate ``robberies,'' we mean that, for every item in the store, the robber either chooses to or not to steal it. 
When making this decision, the robber determines whether adding the item is advantageous to maximizing the profit by looking at past calculations.
We will store these intermediate robberies in a two-dimensional array whose rows correspond to items in the store and whose columns correspond to weights of the bag. 
The idea is to iteratively build a table of maximum profits, and at intermediate steps, figure out if including the item maximizes the profit.

Let's consider an example. Suppose that we have a bag that weighs~$7\text{oz}$, and we know that a bag of~$4\text{oz}$ has a maximum profit of~$\$80$. 
If we are currently eyeing an item that weighs~$3\text{oz}$ at a value of~$\$10$, then we conclude that~$\$90$ is the maximum possible profit by stealing the~$3\text{oz}$ item. 
This is because, if we steal the item, our bag now has~$4\text{oz}$ of remaining capacity. 
We know the maximum possible profit of a~$4\text{oz}$ bag, which is~$\$80$. 
So, the sum of these two values is~$\$90$. 
On the other hand, choosing not to take the item means that we copy over whatever value is stored for a $6\text{oz}$ bag. 
The decision to include or not include is made, similar to the model in the recursive approach, by taking the maximum of the two profits.

Let's initialize the dynamic programming\index{dynamic programming} array~$\emph{dp}$ to be of sizes~$|V|+1$,~$m+1$. 
The base cases are trivial: if the total bag weight is~$0$, then no profits can be made. 
Similarly, on the $0^\text{th}$ item, no profits are possible.
In all other cases, for every item and for every bag weight from~$0$ to~$m$ (corresponding to an entry in the~$\emph{dp}$ table), if an item~$i$ \emph{can} fit in the bag, then we take the maximum of either the profit \emph{without}~$i$ and the profit obtained after adding~$i$.
The latter amount is calculated by adding the value of~$i$ to the maximum profit achievable with the remaining capacity of the bag, which is determined after subtracting the weight of~$i$ from the bag's current capacity.
We will note that our code is a bit more verbose than it could be as a consequence of wanting to label and clarify each variable.
This is already a complex problem, and shoving multiple expressions into one does not make it easier for beginning (or even more advanced readers) readers to understand.

\begin{lstlisting}[language=MyJava]
class MaxJewelProfit {
  
  /**
   * Computes the maximum jewel profit using dynamic programming.
   * @param V values of the jewels.
   * @param W weights of the jewels.
   * @param m maximum weight that the bag can hold.
   * @return the maximum value of jewels that can be picked.
   */
  static int maxJewelProfitDp(int[] V, int[] W, int m) {
    int[][] dp = new int[V.length + 1][m + 1];
    // A jewel with 0 value should not be picked.
    for (int i = 0; i <= V.length; i++) { 
      dp[i][0] = 0; 
    }

    // A bag with 0 weight can't hold any jewels.
    for (int i = 0; i <= m; i++) { 
      dp[0][i] = 0; 
    }

    for (int i = 1; i < dp.length; i++) {
      for (int j = 1; j < dp[i].length; j++) {
        // If we can fit it, then do so. Remember that j 
        // represents the remaining weight in the bag.
        if (j - W[i - 1] >= 0) {
          int currValue = V[i - 1];
          int prevMaxProfit = dp[i - 1][j];
          int remainingWeight = j - W[i - 1];
          int remainingWeightMaxProfit = dp[i - 1][remainingWeight];
          dp[i][j] = Math.max(prevMaxProfit, currValue + remainingWeightMaxProfit);
        } else {
          dp[i][j] = dp[i - 1][j];
        }
      }
    }
    return dp[V.length][m];
  }
}
\end{lstlisting}
