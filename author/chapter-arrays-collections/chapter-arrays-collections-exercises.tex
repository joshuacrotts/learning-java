\section*{Exercises}
\addcontentsline{toc}{section}{Exercises}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{int[] operate(int[] A)} method that, when given an array of integers, returns a new array where the elements are the result of applying the following operation to each element: if the $i^{\text{th}}$ element is odd, multiply it by its index $i$ plus one. Otherwise, divide it by its index $i$ plus one.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{int[] multiplesOf8(int[] A)} that, when given an array of integers, returns a new array where, upon finding a multiple of eight, each successive element becomes that multiple of eight. If another multiple of eight is found, it is not replaced, but all elements to its right change. Consider the following example. \ttt{multiplesOf8([3, 4, 8, 2, 19, 24, 20])} returns \ttt{[3, 4, 8, 8, 8, 24, 24]}.}

\myexercise{1}{chapter-arrays-collections}{This exercise has two parts.} Rectangular coordinates are traditional~$x$ and~$y$ coordinates of a two-dimensional space. Polar coordinates, on the other hand, also operate in two dimensions, but instead have a radius and an angle.

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{double[] toPolar(double x, double y)} method that, when given $x$ and $y$ coordinates, returns a two-element array containing the polar coordinates $r$ in index 0 and $\theta$ in index 1, where the latter is in radians. We can convert from rectangular to polar coordinates using the following formula:

    \begin{align*}
        r &= \sqrt{x^2 + y^2}\\
        \theta &= \arctan(y / x)
    \end{align*}

    \item Design the \ttt{double[] toRectangular(double r, double theta)} method that, when given a radius $r$ and an angle $\theta$ in radians, returns a two-element array containing the rectangular coordinates $x$ in index 0 and $\theta$ in index 1. We can convert from polar to rectangular coordinates using the following formula:

    \begin{align*}
    x &= r\cos{\theta}\\
    y &= r\sin{\theta}
    \end{align*}
\end{enumerate}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{boolean containsOnlyPrime(int[] arr)} method that returns whether or not a given array of integers contains only prime integers. Hint: use the method you wrote in Chapter~\ref{chapter-crl}.}

\myexercise{1}{chapter-arrays-collections}{This question has two parts.}

\begin{enumerate}[label=(\alph*)]
    \item Design the recursive \ttt{linearSearch} method that, when given a \ttt{String[]} $S$ and a \ttt{String} to search for $k$, returns the index of $k$ in $S$, and \ttt{-1} if $k$ is not in the array. This method is definitionally tail recursive, you should write a \ttt{private} helper method that actually performs the recursion.\footnote{By ``definitionally tail recursive,'' we mean that, even though a standard recursive variant exists, it is strongly recommended to only use a tail recursive algorithm, given the recursive definition requirement.}
    \item Design the \ttt{linearSearchLoop} method that solves the problem using a loop. 
\end{enumerate}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{int[] accSum(int[] A)} method, which receives an array of integers and returns a new array of integers that corresponds to the accumulated sum between each integer. We present some examples below.}
\begin{verbnobox}[\small]
accSum({1, 7, 2, 9})                => {1, 8, 10, 19}
accSum({1, 3, 3, 4, 5, 5, 6, 6, 2}) => {1, 4, 7, 11, 16, 21, 27, 33, 35}
accSum({5, 5, 5, 5, 5, 5, 5, 1, 5}) => {5, 10, 15, 20, 25, 30, 35, 36, 41}
\end{verbnobox}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{String[] fizzBuzz(int min, int max)} method that iterates over the interval $[\emph{min}, \emph{max}]$ (you may assume $\emph{max} \geq \emph{min}$) and returns an array containing strings that meet the following criteria:}

    \begin{itemize}
        \item If $i$ is divisible by $3$, insert \ttt{"Fizz"}.
        \item If $i$ is divisible by $5$, insert \ttt{"Buzz"}.
        \item If $i$ is divisible by both $3$ and $5$, insert \ttt{"FizzBuzz"}.
        \item Otherwise, insert \ttt{"i"}, where \ttt{i} is the current number.
    \end{itemize}

    \begin{verbnobox}[\small]
fizzBuzz(1, 12)  => {"1", "2", "Fizz", "4", "Buzz",
                     "Fizz", "7", "8", "Fizz", "Buzz",
                     "11", "Fizz"}
fizzBuzz(15, 18) => {"FizzBuzz", "16", "17", "Fizz"}
    \end{verbnobox}

\myexercise{2}{chapter-arrays-collections}{Using only arrays, design the \ttt{int[] findIntersection(int[] A, int[] B)} method that returns an array containing the \emph{intersection} of two arrays. The intersection of two arrays is the set of elements that are common to both arrays. For example, the intersection of $\{7, 4, 8, 0, 2, 1\}$ and $\{8, 6, 4, 9, 26, 4, 0\}$ is $\{7, 8, 0\}$. Do not assume that the arrays are sorted, and you cannot sort them yourself.}

\myexercise{2}{chapter-arrays-collections}{Desing the \ttt{int median(int[] A, int[] B)} that, when given two sorted (in increasing order) arrays of integers $A$ and $B$, returns the median value of those two lists. You can use auxiliary data structures to help in solving the problem, but they are not necessary.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{double sumNasty(ArrayList<Integer> vals)} method that returns the average of the numbers in the list with the following caveat: The number $9$ should not be counted towards the average, nor should the following number, should one exist.}
\begin{verbnobox}[\small]
sumNasty({8, 7, 11, 9, 12, 10}) => 9.0
sumNasty({120, 99, 9})          => 109.5
sumNasty({9})                   => 0.0
sumNasty({})                    => 0.0
\end{verbnobox}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{int[] countEvenOdds(int[] vals)} method that returns a tuple (an array of two values) where index zero stores the amount of even values and index one stores the amount of odd values.}

\begin{verbnobox}[\small]
countEvenOdds({11, 9, 2, 3, 7, 10, 12, 114}) => {4, 4}
countEvenOdds({11, 13, 15, 17})              => {0, 4}
\end{verbnobox}

\myexercise{2}{chapter-arrays-collections}{This question has two parts.}
\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{isAlmostStrictlyIncreasing} tail recursive method that, when given an array of integers, determines if it is strictly increasing. There is a catch to this: we also return true if the array can be made strictly increasing by removing exactly one element from the array. For instance, \ttt{isAlmostStrictlyIncreasing($\{1, 3, 2, 4\}$)} returns true because, by removing \ttt{3}, we get a list that is strictly increasing. Compare this with \ttt{2, 3, 2, 4}, which cannot be made strictly increasing.
    \item Design the \ttt{isAlmostStrictlyIncreasingLoop} method that solves the problem using a loop.
\end{enumerate}
If you write tests for one of these methods, you should be able to propagate it through the rest, so write plenty!

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{boolean isSubArray(int[] A, int[] B)} method, which receives two arrays of integers $A$ and $B$, and determines if $B$ is a ``sub-array'' of $A$. This means that all elements of $B$ are elements of $A$.}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{int[] twoDimToOneDim(int[][] A)} method, which will flatten a given two-dimensional array of integers into a one-dimensional array. Hint: figure out how many elements the resulting one-dimensional array should have, and only then figure out how to position elements.}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{boolean canBalanceArray(int[] A)} method, which determines whether or not an array of integers $A$ can be split into a partition that balances each side. Use the following examples as motivation.}

\begin{verbnobox}[\small]
canBalanceArray(new int[]{1, 1, 1, 1, 5})    => false
canBalanceArray(new int[]{2, 3, 5})          => true
canBalanceArray(new int[]{-10, 2, -58, 50})  => true
canBalanceArray(new int[]{3, -1, -1, -1, 0}) => true
canBalanceArray(new int[]{3, 2, 1, 0})       => true
canBalanceArray(new int[]{10})               => false
\end{verbnobox}

\myexercise{2}{chapter-arrays-collections}{A \emph{span} is the distance between a value and another, distinct occurrence of the same value. Design the \ttt{int largestSpan(int[] A)} method that, when given a non-empty array of integers $A$, returns the largest span. It may be beneficial to write the \ttt{firstIndexOf} and \ttt{lastIndexOf} methods to help in your design process. Use the following examples as motivation.}

\begin{verbnobox}[\small]
largestSpan(new int[]{4, 2, 3, 2, 5})             => 3
largestSpan(new int[]{1, 2, 3, 4, 5})             => 1
largestSpan(new int[]{5, 4, 4, 4, 3, 4, 1, 4, 1}) => 7
\end{verbnobox} 

\myexercise{1}{chapter-arrays-collections}{A \emph{fixed window} is a ``window,'' or sub-array, of an array. Design the \ttt{List<List<Integer>> computeFixedWindows(int[] A, int k)} method that, when given an array of integers~$A$ and an integer~$k$, returns a list of lists $L$ where each list in~$L$ is a fixed window of size~$\leq{k}$ that moves through~$A$.}

For example, if $A = [1, 2, 3, 4, 5, 6, 7]$ and $k=2$, then \ttt{computeFixedWindows} returns $\{\{1, 2\}\{3, 4\}, \{5, 6\}, \{7\}\}$. 

\myexercise{1}{chapter-arrays-collections}{A \emph{sliding window} is a ``window,'' or subarray, of an array that slides ``through the elements'' of an array. Design the \ttt{List<List<Integer>> computeSlidingWindows(int[] A, int k)} method that, when given an array of integers~$A$ and an integer~$k$, returns a list of lists $L$ where each list in~$L$ is a sliding window of exactly size~$k$ that moves through~$A$.}

For example, if $A = [1, 2, 3, 4, 5, 6, 7]$ and $k=2$, then \ttt{computeSlidingWindows} returns $\{\{1, 2\}, \{2, 3\}, \{3, 4\}, \{4, 5\}, \{5, 6\}, \{6, 7\}\}$. Note the difference between the sliding window and the fixed window.

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{String[][] computeBowlingScores(String[] S, int[][][] scores)} method that computes the bowling score for each player name in $S$. The scores are separated by rows, where the $i^\text{th}$ row corresponds to the $i^\text{th}$ name in $S$. Each row contains ten arrays of 3-element arrays. These triples, as we will call them, correspond to a bowling frame. The first nine frames only use the first two slots of the triple, whereas the last may use all three.}

To compute the score of a player, there are a few rules. Note that, in bowling, the objective is to knock down all ten pins.

For frames 1 to 9:
\begin{itemize}
    \item If the player scores a strike, meaning they hit all ten pins with one throw, it is worth ten points plus the sum of the next two frames, if they exist.
    \item If the player scores a spare, meaning they hit all ten points with exactly two throws, it is worth ten points, plus the sum of the next frame, if it exists.
    \item If the player does not score a strike nor a spare, they earn as many points as pins knocked down.
\end{itemize}

For frame 10:
\begin{itemize}
    \item If the player scores a strike on the first throw, they get two more attempts.
    \item If the player scores a spare resulting from the first two throws, they get one more attempt.
    \item If the player does not score a strike nor a spare from the first two shots, they earn as many points as pins knocked down.
\end{itemize}

The resulting array contains $n$ rows to represent $n$ players, where the first element of a row is the player name alphabetized, and the second is their score.

\myexercise{2}{chapter-arrays-collections}{We can represent matrices as two-dimensional arrays. For example, the matrix}

\[
\begin{bmatrix}
    1 & 2 & 3\\
    4 & 5 & 6\\
    7 & 8 & 9
\end{bmatrix}
\]

\noindent can be represented as the two-dimensional array

\begin{verbnobox}[\small]
int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
\end{verbnobox}

\noindent Design the \ttt{int[][] transpose(int[][] matrix)} method that returns the transpose of a given matrix. The transpose of a matrix is the matrix where the rows and columns are swapped. For example, the transpose of the above matrix is

\[
\begin{bmatrix}
    1 & 4 & 7\\
    2 & 5 & 8\\
    3 & 6 & 9
\end{bmatrix}
\]

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{int[][] rotate(int[][] matrix)} method that returns the matrix rotated $90$ degrees clockwise. For example, the matrix}

\[
\begin{bmatrix}
    1 & 4 & 7\\
    2 & 5 & 8\\
    3 & 6 & 9
\end{bmatrix}
\]

\noindent is rotated to

\[
\begin{bmatrix}
    3 & 2 & 1\\
    6 & 5 & 4\\
    9 & 8 & 7
\end{bmatrix}
\]

To rotate a matrix, take its transposition, then reverse each row. You may assume that the input matrix is $N \times N$, i.e., a square matrix.

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{int[][] multiply(int[][] A, int[][] B)} method that returns the product of two matrices, where $A$ is $M \times N$ and $B$ is $P \times Q$. Not all matrices can be multiplied, so you should return \ttt{null} if the matrices cannot be multiplied. Two matrices can be multiplied if and only if $N = P$. The product of two matrices $A$ and $B$ is the matrix $C$ where $C_{i, j} = \sum_{k=1}^{N} A_{i, k}\cdot B_{k, j}$} for the indices $i$, $k$, and $j$.

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{boolean canSum(int[] A, int t)} method that, when given an array of integers $A$ and a target $t$, determines whether or not there exists a group of numbers in $A$ that sum to $t$. For example, if $A=\{2, 4, 10, 8\}$ and $t=9$, then \ttt{canSum} returns false because there is no possible selection of integers from $A$ that sum to $9$. On the other hand, if $A=\{3, 7, 4, 5, 9\}$ and $t=8$, then we return true because $3+5=8$. If $A=\{2, 4, 2, 11, 5, 4\}$ and $t=9$, then we return true because $1+4+4=9$, but also $4+5=9$ and $5+4=9$.}

There is a simple recursive algorithm to solve this problem: if you have searched through the entire array, return whether or not the target is zero. Otherwise, make two recursive calls: one for where you choose the current number and a second for where you do not. By ``choose,'' we mean to say that the current number is subtracted from the target value. By ``current number,'' we mean to suggest a method that resembles the tail recursive linear search algorithm. You'll need to design a helper method to solve this problem using this approach.

\myexercise{2}{chapter-arrays-collections}{\emph{Linear regression} is used to compute a ``line of best-fit'' for a collection of $(x, y)$ points. In particular, we find the equation for a line $y = \hat{\alpha} + \hat{\beta}x$, where $\hat{\alpha}$ is the y-intercept and $\hat{\beta}$ is the slope. The formulas for $\hat{\alpha}$ and $\hat{\beta}$ are as follows~\citep{linear-regression}:}

\[
    \hat\alpha = \frac{\sum_{i=1}^{n}y_i \sum_{i=1}^{n}x_i^2 - \sum_{i=1}^{n}x_i \sum_{i=1}^{n}x_i{}y_i}{n  \sum_{i=1}^{n}x_i^2 - \left(\sum_{i=1}^{n}x_i\right)^2}
\]

\[
    \hat{\beta} = \frac{n \sum_{i=1}^{n}x_i{}y_i - \sum_{i=1}^{n}x_i \sum_{i=1}^{n}y_i}{n \sum_{i=1}^{n}x_i^2 - \left(\sum_{i=1}^{n}x_i\right)^2}
\]

Design the \ttt{double[] linearRegression(double[] xs, double[] ys)} method that, when given two arrays of doubles $\emph{xs}$ and $\emph{ys}$, returns a two-element array containing the y-intercept and the slope, respectively. If the two arrays are not of the same length, return \ttt{null}.

\myexercise{2}{chapter-arrays-collections}{The correlation coefficient~$r$ is a measure of the strength and direction of a linear relationship between two variables~$x$ and~$y$. The value of~$r$ is always between~$-1$ and~$1$. When $r>0$, there is a positive linear relationship between $x$ and $y$. When $r<0$, there is a negative linear relationship between $x$ and $y$. When $r=0$ or is approximately zero, there is no (or little) linear relationship between~$x$ and~$y$. The formula for the correlation coefficient is as follows~\citep{stats}:}

\[
    r = \frac{1}{n-1}\cdot\frac{1}{S_x\cdot{}S_y}\cdot\sum_{i=1}^{n}(x_i - \bar{x})(y_i - \bar{y})  
\]

Where~$n$ is the number of data points,~$x_i$ and~$y_i$ are the~$i^\text{th}$ data points,~$\bar{x}$ and~$\bar{y}$ are the means of~$x$ and~$y$ respectively, and~$S_x$ and~$S_y$ are the sample standard deviations of~$x$ and~$y$ respectively. To compute the sample standard deviation of a set of values~$S$, we use the formula~\citep{stats}:

\[
    S_x = \sqrt{\frac{\sum_{i=1}^{|S|}(x_i - \bar{x})^2}{|S|-1}}
\]

Design the \ttt{double correlationCoefficient(double[] xs, double[] ys)} method that, when given two arrays of doubles~$\emph{xs}$ and~$\emph{ys}$, returns the correlation coefficient between the two arrays. If the two arrays are not of the same length, return \ttt{null}.

\myexercise{1}{chapter-arrays-collections}{In the chapter, we presented an example of ``exploding'' a string into its constituent characters.} 
Design the \ttt{List<Integer> explode(int n)} method that, when given an integer~$n$, returns a list of integers that represent the digits of~$n$. For example, \ttt{explode(123)} returns \ttt{[1, 2, 3]}. You \textbf{cannot} convert the integer to a string to solve this problem or use any auxiliary data structures.

\myexercise{1}{chapter-arrays-collections}{This exercise has three parts.}
\begin{enumerate}[label=(\alph*)]
    \item Design the \emph{standard recursive} \ttt{cycleOperations} method, which receives a \ttt{List<Integer>} and returns the result of circularly applying \ttt{+}, \ttt{-}, then \ttt{*} to the elements of the list.

    \begin{verbatim}
cycleOperations({}) 
    => 0
cycleOperations({1, -4, 9, -16, 25, -36}) 
    => ((((((0 + 1) - -4) * 9) + -16) - 25) * -36) 
    => -144
cycleOperations({10, 5, -2, 1, -2}) 
    => (((((0 + 10) - 5) * -2) + 1) * -2) 
    => 18
    \end{verbatim}  

    \item Design the \texttt{cycleOperationsTR} and \texttt{cycleOperationsTRHelper} methods. The former acts as the driver to the latter; the latter solves the same problem that \texttt{cycleOperations} does, but it instead uses tail recursion. Remember to include the relevant access modifiers!
    
    \item Design the \texttt{cycleOperationsLoop} method, which solves the problem using either a \texttt{while} or \texttt{for} loop.
\end{enumerate}
If you write tests for one of these methods, you should be able to propagate it through the rest, so write plenty!

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{List<Integer> sumEvenMultOdd(int[] A)} method that, when given an array of integers $A$, returns a \ttt{List<Integer>} whose first element is the sum of all elements at even indices of $A$, and whose second element is the product of all elements at odd indices of $A$. If you encounter a zero at an odd index, do not continue to multiply values (i.e., don't keep multiplying subsequent values and return the multiplied value before you encountered the zero, since the product will forever be zero from that point onward).}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{Set<List<Integer{>}{>} twoSum(int[] A, int t)} method that, when given an array of integers $A$ and a target $t$, returns all possible pairs of numbers in $A$ that sum to $t$. For example, if $A=\{2, 2, 4, 10, 6, -2\}$ and $t=4$, we return a set containing two two-element lists: $\{2, 2\}$ and $\{6, -2\}$. Do not add a pair that already exists in the set or a pair that, by reversing the pair, we get a pair in the existing set. E.g., $\{-2, 6\}$ should not be added to the set. 

There is a simple brute-force algorithm to solve this problem via two loops, but by incorporating a second set for lookups, we can do much better: for every number $n$ in $A$, add $n$ to a set $S$, and if $t-n=m$ for some $m\in{S}$, then we know that $m+n$ must equal $t$, therefore we add $\{n, m\}$ to the resulting set of integer arrays.}
Walking through this with the example from before, we get the following sequence of actions:

\begin{itemize}
    \item Initialize $S=\{\}$ and $L=\{\}$. We know that $t=4$.
    \item We add $2$ to $S$. $S=\{2\}$.
    \item Because $4-2\in{S}$, the two-element array $\{2, 2\}$ is added to $L$. $2$ is not re-added to $S$.
    \item Because $4-4\not\in{S}$, we only add $4$ to $S$. $S=\{2, 4\}$.
    \item Because $4-10\not\in{S}$, we only add $10$ to $S$. $S=\{2, 4, 10\}$.
    \item Because $4-6\not\in{S}$, we only add $6$ to $S$. $S=\{2, 4, 10, 6\}$.
    \item Because $4-(-2)\in{S}$, the two-element array $\{6, -2\}$ is added to $L$. We add $-2$ to $S$. $S=\{2, 4, 10, 6, -2\}$.
\end{itemize}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{ArrayList<String> shift(ArrayList<String> ls, int i)} method that, when given a list of strings $s$ and an index $i$, returns a new list where each element is shifted  by $i$ spots. Negative values correspond to left shifts, and positive values correspond to right shifts. If a shift is nonsensical, do not shift at all. A nonsensical shift is one of the following:}
\begin{itemize}
    \item If there are no elements in the list.
    \item If there is only one element in the list.
    \item If there are only two elements in the list, you only need to shift once. Do the math!
\end{itemize}
    
This method is harder than it may appear at first glance, so write plenty of tests! You \textbf{cannot} use any auxiliary data structures or methods (from, say, \ttt{Collections}) to solve this problem.

\begin{verbnobox}[\small]
shift({11, 12, 13, 14}, -1)          => {12, 13, 14, 11}
shift({120, 120, 140, 140}, 2)       => {140, 140, 120, 120}
shift({99999999}, 1000)              => {99999999}
shift({}, -9999999)                  => {}
shift({120, 80, 70, 50, 40, 20}, -3) => {50, 40, 20, 120, 80, 70}
\end{verbnobox}

\myexercise{1}{chapter-arrays-collections}{The \textit{centroid} of a two-dimensional shape $S$ is the arithmetic mean position of its points. That is, it is the point that represents the ``middle'' of a shape.}

Design the \ttt{double[] centroid(double[] P)} method that, given an array of coordinates, returns the centroid of the shape described by~$P$. The input array has values such that every two elements $P[i], P[i+1]$ form one coordinate pair. For instance, $P[0] = x_1$ and $P[1] = y_1$, meaning there are $|P|/2$ coordinate pairs. The \ttt{centroid} method should return a two-element array whose first is the $x$ coordinate and whose second is the $y$ coordinate. The formula for the centroid (described as a set of points) $C(x, y)$ is as follows:

\[
    C(x, y) = \left(\dfrac{1}{|P|}\sum_{i=0}^{|P|-1}{P[2i]}, \dfrac{1}{|P|}\sum_{i=0}^{|P|-1}{P[2i+1]}\right)
\]

\myexercise{2}{chapter-arrays-collections}{For this problem you are not allowed to use an \ttt{ArrayList} or any helper methods, e.g., \ttt{.contains}, or methods from the \ttt{Arrays} class. You \emph{may} (and should) use a \ttt{Set<Integer>} to keep track of previously-seen peaks.}

Joe the mountain climber has come across a large mountain range. He wants to climb only the tallest mountains in the range. Design the \ttt{int[] peakFinder(int[] H)} method that returns an array $H'$ of all the peaks in an \ttt{int[]} of mountain heights $H$. A peak $p$ is defined as an element of $h$ at index $i$ such that $p[i - 1] < p[i]$ and $p[i] > p[i + 1]$. If $i = 0$ or $i = |H| - 1$, Joe will not climb $p[i]$. Joe doesn't want to climb a mountain of the same height more than once, so you should not add any peaks that have already been added to $H'$. We present some test cases below.

\begin{verbnobox}[\small]
peakFinder({9, 13, 7, 2, 8})                        => {13}
peakFinder({8, 7, 8, 7, 8, 7, 8, 7})                => {8}
peakFinder({111, 27, 84, 31, 5, 9, 4, 3, 2, 1, 64}) => {84, 9}
peakFinder({})                                      => {}
peakFinder({1})                                     => {}
peakFinder({1, 2})                                  => {}
peakFinder({1, 2, 1})                               => {2}
peakFinder({1, 2, 3, 2, 1})                         => {3}
\end{verbnobox}

\myexercise{1}{chapter-arrays-collections}{A professor gives their students extra credit on an exam if they can guess the average within five percent of the actual average. 

Design the \ttt{boolean earnsExtraCredit(List<Double> D, double g)} method that, when given a list of scores $D$ and a guess $g$, returns whether a student is given extra credit.}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{List<String> roundTimes(List<String> T)} method that, when given a list of ``times''~$T$, returns a new list where each time is rounded to its nearest quarter hour.}
A ``time'' is a string in the~$24$-hour format \ttt{"HHMM"}, where $0 \leq \ttt{HH} \leq 23$, and $0 \leq \ttt{MM} \leq 59$.
Rounding to the nearest quarter hour means to either a minute of \ttt{00}, \ttt{15}, \ttt{30}, or \ttt{45}.
For example, \ttt{"1247"} rounds to \ttt{"1245"}, and \ttt{"1330"} stays the same at \ttt{"1330"}. If a time rounds up to the next hour, update the hour.
For instance, \ttt{"2359"} rounds up to \ttt{"0000"}, whereas \ttt{"1955"} rounds up to \ttt{"2000"}.

\myexercise{1}{chapter-arrays-collections}{A village has members where each has a partner. These members are grouped in pairs inside an \ttt{ArrayList<Integer>} where each pair of indices represents a relationship of the village. I.e., \ttt{A.get($2i$)} and \ttt{A.get($2i + 1$)} are in a relationship. A couple is considered the wisest if they have the highest combined age. Design the \ttt{ArrayList<Integer> wisest(ArrayList<Integer> A)} method that, when given a list of (integer) ages $A$, return a new \ttt{ArrayList<Integer>} containing the ages of the wisest pair. If there is a tie, return the pair that has the highest age overall. The order is not significant. We present a few test cases below. You can assume that there will always be an even number of village members.}

\begin{verbnobox}[\small]
wisest({31, 42, 43, 35, 21, 27, 24, 44}) => {43, 35} or {35, 43}
wisest({47, 51, 52, 48, 33, 67, 45, 35}) => {33, 67} or {67, 33}
\end{verbnobox}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{char missingChar(Set<Character> s)} method that, when given a set of characters whose values range from $a..z$ with one missing, return the character that is missing. }

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{Map<String, Integer> updateTransactions(Map<String, Integer> inv, L\-ist<String> transactions)} method that, when given a map of product names to product quantities, as well as a list of transactions, returns a new inventory map of item counts. The given list of transactions contains product names, and when a product goes out of stock, it should be removed from the returned map.}

\myexercise{3}{chapter-arrays-collections}{File permissions are denoted in octal notation. That is, consider a file that has three sets of permissions: owner $o$, group $g$, and users $u$ (representing other users). There are three ways to work with a file: reading from it $R$, writing to it $W$, or execution $X$. We might represent this as a bit string of $R_oW_oX_oR_gW_gX_gR_uW_uX_u$. We use a $1$ or $0$ to denote the permissions of a file. For example, $111001000$ denotes that the file owner can read, write, and execute the file, those who are in the same group as the owner can execute the file, and anyone else cannot interact at all with the file. Design the \ttt{Set<String> availableFiles(Map<int[], Integer> F, String u, int g, boolean r, boolean w, boolean x)} method that, when given a map of files to permissions $F$, a username $u$ and the group identifier $g$ for the given user, returns a list of files that satisfy the flags passed to the method. The key for the map of files to permissions is itself a 3-element array, where the first element is the file name, the second element is the username of the file owner, and the third element is the group identifier of the owner, as a string.}

\myexercise{2}{chapter-arrays-collections}{You're given a \ttt{HashMap} $M$ of \ttt{String} keys to \ttt{Integer} values corresponding to their length. Design the \ttt{ArrayList<TreeSet<String>{>} categorize(HashMap<String, Integer> M)} that receives $M$ and converts it to an \ttt{ArrayList} of \ttt{TreeSet} values. Each element of the \ttt{ArrayList}, therefore, is itself a \ttt{TreeSet}. These \ttt{TreeSet} elements should store the strings whose mapped value matches the index of the \ttt{TreeSet}. The order of the resulting sets, therefore, \textbf{does} matter! Below is an example test case.}
\begin{verbnobox}[\small]
[<"x" : 1>, <"hello" : 5>, <"world" : 5>, <"hi" : 2>]
  => [{}, {"x"}, {"hi"}, {}, {}, {"hello", "world"}]
\end{verbnobox}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{List<String> tokenize(String s, char d)} method that, when given a string~$s$ and a \ttt{char} delimiter $d$, returns an \ttt{ArrayList} of tokens split at the delimiter. You must do this by hand; you \textbf{cannot} call any \ttt{String} methods (except \ttt{.length} and \ttt{.charAt}).}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{Map<String, Integer> wordCount(String s)} method that, when given a string $s$, counts the number of words in the list, then stores the resulting frequencies in a \ttt{HashMap<String, Integer>}. Assume that $s$ is not cleaned. That is, you should first remove all punctuation (periods, commas, exclamation points, question marks, semi-colons, dashes, hashes, ampersands, asterisks, and parentheses) from $s$, producing a new string $s'$. Then, split the string based on spaces (remember \ttt{tokenize}?), and produce a map of the words to their respective counts. Do not factor case into your total; i.e., \ttt{"fAcToR"} and \ttt{"factor"} count as the same word. The ordering of the returned map is not significant.}

\begin{verbnobox}[\small]
String s = "Hello world, the world is healthy, is 
            it not? I certainly agree that the world 
            is #1 and healthy."
wordCount(s) => [<"hello" : 1>, <"world" : 3>, <"the" : 2>
                 <"is" : 3>, <"healthy" : 2>, <"it" : 1>,
                 <"i" : 1>, <"certainly" : 1> <"agree" : 1>
                 <"that" : 1>, <"1" : 1>, <"and" : 1>, <"not" : 1>]
\end{verbnobox}

\myexercise{3}{chapter-arrays-collections}{Design the \ttt{LinkedHashSet<String>largeToSmall(HashMap<String, Integer> M)} method that, when given a \ttt{HashMap<String, Integer>} $M$, returns a \ttt{LinkedHashSet} of \ttt{String} values where the words are inserted into the set in order of decreasing count. Words that have the same count do not need to be inserted in any particular order. E.g., \ttt{"is"} may come before \ttt{"world"}. You cannot sort $M$. Hint: create an array of size $c$ (where $c$ is the highest word count) where each element is a \ttt{LinkedHashSet<String>}. For every element $e$ in $M$, add $e$ to the set at index $M[i]$, where $i$ is the count of $e$ in $M$. Then, append these sets in reverse order according to their index. We provide some pseudocode below.}

\begin{verbnobox}[\small]
largeToSmall(M):
  // |M| is M.size().
  c = Get Highest Count Word in M
  array = [0 .. c-1]
  for i in [0 .. c-1]:
    array[i] = new LinkedHashSet<String>();

  for every key k in M:
    i = M.get(k)
    array[i-1].add(k)

  // Append all linked hash sets in reverse order.
  return array[c-1] appended to array[c-2] ... appended to array[0]
\end{verbnobox}
    
\begin{verbnobox}[\small]
largeToSmall(wordCount(s)) => {"world", "is", "the", "healthy", 
                               "hello", "it", "i", "certainly", 
                               "agree", "that", "1", "and", "not"}
\end{verbnobox}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{Set<Integer> symmetricDiff(Set<Integer> s1, Set<Integer> s2)} method that, when given two sets of integers $s_1$ and $s_2$, returns a new set $s_3$ such that all elements of $s_3$ are in either of the sets, but not in their intersection. That is, it is the set of elements that are in either $s_1$ or $s_2$, but not both.}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{Map<String, Set<String>> identifyTrendingTopics(Map<String, Set<Str\-ing>> regionTopics, Set<String> gTrending)} method that, when given a map of regions to topics that are trending in that region, returns a map of topics to regions such that the keys are topics and the values are regions where that topic is trending. A topic is trending in a region if it is not a globally-trending topic and it is trending in at least two regions simultaneously. We provide an example below.}

\begin{verbnobox}[\small]
identifyTrendingTopics([<"North America" : {"Tech", "Comedy", "Sports"}>, 
                        <"Europe" : {"Comedy", "Music", "Sports"}>, 
                        <"Asia" : {"Fashion, "Music"}>], {"Tech"})
  => [<"Comedy" : {"North America", "Europe"}>, <"Music" : {"Europe, "Asia"}>]
\end{verbnobox} 

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{LinkedList<Integer> pushLast(LinkedList<Integer> lon, int v)} method that, when given a \ttt{LinkedList<Integer>}~$l$ and an \ttt{int}~$v$, returns a newly-instantiated \ttt{LinkedList<Integer>} with the same elements plus~$v$ added to the end of~$l$.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{LinkedList<Integer> set(LinkedList<Integer> l, int v, int i)} method that, when given a \ttt{LinkedList<Integer>}~$l$, an \ttt{int}~$v$, and an index~$i$, returns a \emph{new} \ttt{LinkedList<Integer>} with the same elements, except that the element at index~$i$ is, instead, the value~$v$. If $i$ is less than zero or exceeds the length of~$l$, return \ttt{null}.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{int[] toArray(LinkedList<Integer> l)} method, which receives a linked list of integers~$l$, returns an array containing the values from~$l$.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{LinkedList<Integer> reverse(LinkedList<Integer> l)} method that, when given a linked list of integers $l$, returns a \emph{new} linked list containing the elements of~$l$, but reversed.}

\myexercise{2}{chapter-arrays-collections}{Design the \texttt{HashSet<Integer> moreThanThree(int[] A)} method, which receives an \texttt{int[]}~$A$ and returns a new \texttt{HashSet\-<Integer>} of values containing those values from~$A$ that occur strictly more than three times.}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{List<String> collectComments(String s)} method that, when given a string representing a (valid) Java program, returns an list containing all comments from the input program string. You cannot use any \ttt{String} helper methods (e.g., \ttt{strip}, \ttt{split}) to solve this problem nor can you use regular expressions.}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{List<String> removeSideBySideDups(List<String> ls)} that receives a list of strings, returns a new list where all side-by-side duplicates are removed.}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{boolean isPalindromeList(LinkedList<Integer> ls)} method, which receives a linked list of integers, determines if it is a palindrome list. You cannot use \ttt{.get} to solve the problem, nor can you use a \ttt{for} loop. Think about how you can use a \ttt{while} loop, an \ttt{Iterator}, and a \ttt{Stack} to do this.}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{double postfixEvaluator(List<String> l)} method that, when given a list of binary operators and numeric operands represents as strings, returns the result of evaluating the postfix-notation expression. You will need to write a few helper methods to solve this problem, and it is best to break it down into steps. First, write a method that determines if a given string is one of the four binary operators: \ttt{"+"}, \ttt{"-"}, \ttt{"*"}, or \ttt{"/"}. You may assume that any inputs that are not binary operators are operands, i.e., numbers. Then, write a method that applies a given binary operator to a list of operands, i.e., an \ttt{ArrayList<Double>}.}

\begin{verbnobox}[\small]
postfixEvaluator({"5", "2", "*", "5", "+", "2", "+"}) => 17
postfixEvaluator({"1", "2", "3", "4", "+", "+", "+"}) => 10
\end{verbnobox}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{double prefixEvaluator(List<String>) l} method that, when given a list of binary operators and numeric operands represented as strings, returns the result of evaluating the prefix-notation expression. This is slightly more difficult than the postfix evaluator, but not by much. As with the previous exercise, write helper methods for determining whether or not a string is an operator or an operand, and use a stack. Hint: traverse the input list from right-to-left, but be careful about non-commutative operations!}

\begin{verbnobox}[\small]
prefixEvaluator({"+", "3", "4"}) => 7
prefixEvaluator({"+", "+", "2", "10", "*", "-5", "/", "16", "4"}) => -8
prefixEvaluator({"*", "-", "100", "20", "5"}) => 400
\end{verbnobox}

\myexercise{3}{chapter-arrays-collections}{Design the \ttt{List<List<String>> displayOrders(List<List<String>> orderInfo)} method that, when given an array of orders, returns a series of order specifications by customer table.}

To be more specific, an order is a \ttt{List<String>} whose first element is the customer name, whose second element is the table number, and whose third element is the food that the customer is ordering. 

Return the data as a list of rows of information. The first row displays the table headers. The first table header should be \ttt{"Table"}, followed by the food in alphabetical order. Each successive row represents a table in increasing numerical order. Below is an input and output example.

\begin{verbnobox}[\small]
{{"John", "2", "Chicken"}, {"Samantha", "3", "Pasta"}, 
 {"Tim", "2", "BBQ Chicken"}, {"Christina", "8", "Grilled Cheese"}, 
 {"Tymberlyn", "2", "Chicken"}, {"TJ", "3", "Water"}}
=> 
{{"Table", "BBQ Chicken", "Chicken", "Grilled Cheese", "Pasta", "Water"},
 {"2", "1", "2", "0", "0", "0"},
 {"3", "0", "0", "0", "1", "1"},
 {"8", "0", "0", "1", "0", "0"}}
\end{verbnobox}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{substitute} method that, when given an~$\mathit{exp}$ as a~\ttt{String} and an environment~$\mathit{env}$ as a~\ttt{HashMap<String, Integer>}, substitutes each occurrence of an ``identifier'' for its value counterpart from the map.}

\begin{verbnobox}[\small]
substitute("f(x) = 3 * a + b", {<"a" : 10>, <"b" : 13>})
           => "f(x) = 3 * 10 + 13"
substitute("g(h, f(x)) = y + x", {<"q" : 200>})          
           => "g(h, f(x)) = y + x" 
\end{verbnobox}

\myexercise{3}{chapter-arrays-collections}{Design the \ttt{unifiesAll} method, which receives a \ttt{HashMap<String, Integer>} $M$ of unification assignments and a list of goals \ttt{ArrayList<LinkedList<String>>}} $\mathcal{G}$. Each goal $G \in \mathcal{G}$ is a tuple represented as a \ttt{LinkedList}; goals consist of two values $x, y$, and if it is possible for these to be the same value, then we say we can unify $x$ with $y$. Any successful unifications that occur with variables not present in $M$ should be added to $M$. We present some examples below (assume all values are strings; we omit the quotes out of conciseness). Hint: you might want to write an \ttt{isVar} predicate, which determines if a value is a variable or not, i.e., a value that does not start with a number.

\begin{verbnobox}[\small]
M1 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G1  = {{x, x}, {10, 10}, {z, 15}, {x, w}}
unifiesAll(M1, G1) => true

M2 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G2 = {{x, y}}
unifiesAll(M2, G2) => false

M3 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G3 = {{q, x}, {w, 5}, {q, 5}, {q, w}}
unifiesAll(M3, G3) => true

M4 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G4 = {{q, x}, {q, 10}}
unifiesAll(M4, G4) => false
\end{verbnobox}

\myexercise{3}{chapter-arrays-collections}{Two strings $s_1$ and $s_2$ are isomorphic if we can create a mapping from $s_1$ from $s_2$. For example, the strings \ttt{"DCBA"} and \ttt{"ZYXW"} are isomorphic because we can map $D$~to~$Z$, $C$~to~$Y$, and so forth. Another example is \ttt{"ABACAB"} and \ttt{"XYXZXY"} for similar reasons. A~non-example is \ttt{"PROXY"} and \ttt{"ALPHA"}, because once we map \ttt{"A"} to \ttt{"P"}, we cannot create a map between \ttt{"A"} and \ttt{"Y"}. Design the \ttt{boolean isIsomorphic(String s1, String s2)} method, which determines whether or not two strings are isomorphic. }

\myexercise{2}{chapter-arrays-collections}{Anagrams are strings that are formed by rearranging the letters of another string. For example, \ttt{"plea"} is an anagram for \ttt{"leap"}, but we consider an alphabetized anagram to be the alphabetized arrangement of letters for an anagram. As an example, \ttt{"aelrst"} is the alphabetized anagram for \ttt{"alerts"}, \ttt{"alters"}, \ttt{"slater"}, and \ttt{"staler"}. Design the \ttt{static Map<String, List<String>> alphaAnagramGroups(List<String> los)} method, which maps all alphabetized anagrams to the strings in $\emph{ls}$ using the above criteria.}
    
\begin{verbnobox}[\small]
los = ["presorting", "plea", "introduces", "anger", "leap", "petals",
       "donate", "plates", "range", "reductions", "rediscount", 
       "tapers", "pale", "atoned", "staple", "repast", "reportings"]
      
alphaAnagramGroups(los) 
  => {{"aegnr", ["anger", "range"]}, 
      {"aelp", ["plea", "leap", "pale"]}, 
      {"aelpst", ["petals", "plates", "staple"]}, 
      {"aeprst", ["tapers", "repast"]}
      {"cdeinorstu", ["introduces", "reductions", "rediscount"]}, 
      {"adenot", ["donate", "atoned"]}, 
      {"eginoprrst", ["presorting", "reportings"]}}
    
\end{verbnobox}

\myexercise{2}{chapter-arrays-collections}{A SLC (simplified lambda calculus) expression takes one of the two forms: $\mathit{varList}$ or $\lambda{\mathit{var}}.\mathit{E}$, where $\mathit{var}$ is a lower-case letter from `$u$' to `$z$', $\mathit{varList}$ is a sequence of variables, and $\mathit{E}$ is either a $\mathit{var}$ or another SLC expression. We provide some examples below.}

\begin{align*}
  & \lambda{}x.\lambda{y}.xyz\\
  & \lambda{x}.x\\
  & \lambda{y}.yzxw\\
  & \lambda{w}.\lambda{x}.\lambda{y}.\lambda{z}.z
\end{align*}

Your job is to determine which variables are bound, which are free, and which are neither.

A \emph{bound variable} is a variable that is bound by a $\lambda$ and occurs in its expression. For example, in the expression $\lambda{x}.x$, `$x$' is bound.

A \emph{free variable} is a variable that is \emph{not} bound by a $\lambda$ but does occur in an expression. For example, in the expression $\lambda{y}.\lambda{x}.zwv$, `$z$', `$w$', and `$v$' are free variables.

A variable that is neither free nor bound is a variable that is bound by a $\lambda$ but does not occur in its expression. For example, in the expression $\lambda{}x.\lambda{}y.yz$, `$x$' is neither free nor bound.

Design the \ttt{static HashMap<String, String> classifyVars(String E)} method, which returns a map of variables to their classification. We provide some examples below. You may assume that the input is a valid SLC expression and that no variables shadow one another. Use the values \ttt{V}, \ttt{B}, and \ttt{N} to represent free, bound, and neither, respectively.
\begin{alltt}
classifyVars("xyz")       => {<"x" : "F">, <"y" : "F">, <"z" : "F">}
classifyVars("\(\lambda\)x.\(\lambda\)y.xyz") => {<"x" : "B">, <"y" : "B">, <"z" : "F">}
classifyVars("\(\lambda\)x.\(\lambda\)y.x")   => {<"x" : "B">, <"y" : "N">}
\end{alltt}

\myexercise{2}{chapter-arrays-collections}{The \emph{substitution cipher} is a text cipher that encodes an alphabet string $A$ (also called the \emph{plain-text alphabet}) with a key string $K$ (also called the \emph{cipher-text alphabet}). The $A$ string is defined as \ttt{"ABCDEFGHIJKLMNOPQRSTUVWXYZ"}, and $K$ is any permutation of~$A$. We can encode a string $s$ using $K$ as a mapping from~$A$. For example, if $K$ is the string \ttt{"ZEBRASCDFGHIJKLMNOPQTUVWXY"} and $s$ is \ttt{"WE MIGHT AS WELL SURRENDER!"}, the result of encoding $s$ produces \ttt{"VN IDBCY JZ VNHH ZXRRNFMNR!"}

Design the \ttt{subtitutionCipher} method, which receives a plain-text alphabet string $A$, a cipher-text string $K$, and a string $s$ to encode, \ttt{substitutionCipher} should return a string~$s'$ using the aforementioned substitution cipher algorithm.}

\myexercise{3}{chapter-arrays-collections}{You are designing a system with querying functionality similar to a database language such as SQL. In particular, we have a 2D array of strings whose first row contains the following column headers: \ttt{"ID"}, \ttt{"Name"}, \ttt{"BirthYear"}, \ttt{"Occupation"}, and \ttt{"Salary"}. The remaining rows should contain several contributors to not only computer science but other sciences, engineering, and mathematics as well.}

Design the \ttt{List<String> query(String[][] db, String cmd)} method that, when given a ``database'' and a ``Command'', returns the names of all people that satisfy the criteria enforced by the command.

\begin{verbatim}
A Command is "SELECT <count> WHERE <predicate>"
\end{verbatim}

The \ttt{SELECT} command receives a \ttt{$<$count$>$}, which is a number between~$1$ and~$n$, or the asterisk to indicate everyone in the database. The \ttt{WHERE} clause receives a ``Predicate''.

\begin{verbatim}
A Predicate is "<header> <comparator> <value>"
\end{verbatim}

Headers are one of the column headers of the database, and comparators are either \ttt{=}, \ttt{!=}, \ttt{<}, \ttt{<=}, \ttt{>}, or \ttt{>=}, or \ttt{LIKE}. Values are either numbers, floats, or strings. 

Parsing a \ttt{LIKE} command is more complicated. There are four possible types of values: 

\begin{verbatim}
'S'
'%S'
'S%'
'%S%
\end{verbatim}

The first matches an exact string, namely \ttt{S}. The second matches any string that ends with \ttt{S}. The third matches any string that begins with \ttt{S}. The fourth matches any string that contains \ttt{S}. 

\myexercise{3}{chapter-arrays-collections}{Minesweeper is a simple strategy game where the objective is to uncover all spaces on a board without running into mines.}
If you are not familiar with the mechanics, we encourage you to find a version online and play it for a bit to understand its gameplay.
In this exercise you will implement the minesweeper game as a series of methods.

\begin{enumerate}[label=(\alph*)]
    \item First, design the static \ttt{boolean isValidMove(char[][] board, int mx, int my)} met\-hod that receives a board and a move position, and determines whether the move is valid. A move is valid if it is located within the bounds of the board.
    \item Design the static \ttt{List<int[]> getValidNeighbors(char[][] board, int mx, int my)} method that receives a board and a move position, and returns a list of all the immediate neighbors to the cell $(\emph{mx}, \emph{my})$. 
    Each element of the list is a two-element integer array containing the$~x$ and~$y$ coordinates of the neighbor.
    Consider the diagram below, where $(0, 0)$ is the move position, and the surrounding cells are its neighbors, represents as offsets.
    Note that \ttt{getValidNeighbors} should only return neighbors that are \emph{in bounds}. 
    Hint: use \ttt{isValidMove}.

\begin{center}
    \begin{tikzpicture}
        \matrix[matrix of nodes, nodes={draw, minimum size=1.5cm, anchor=center}, column sep=-\pgflinewidth, row sep=-\pgflinewidth] (m) {
            \text{(-1, 1)} & \text{(0, 1)} & \text{(1, 1)} \\
            \text{(-1, 0)} & \text{(0, 0)} & \text{(1, 0)} \\
            \text{(-1, -1)} & \text{(0, -1)} & \text{(1, -1)} \\
        };
    \end{tikzpicture}
\end{center}

    \item Design the static \ttt{List<int[]> getNonMineNeighbors(char[][] board, int mx, int my)} method that receives a board and a move position, and returns a list of all the neighbors that are not mines. You \emph{must} use \ttt{getValidNeighbors} in your definition.

    \item Design the static \ttt{List<int[]> getMineNeighbors(char[][] board, int mx, int my)} method that receives a board and a move position, and returns a list of all the neighbors that are mines. You \emph{must} use \ttt{getValidNeighbors} in your definition.

    \item Design the static \ttt{int countAdjacentMines(char[][] board, int mx, int my)} method that receives a board and a move position, and returns the number of mines that are adjacent to the given position. This method should be one line long and contain a call to \ttt{getMineNeigbors}.

    \item With the helper methods complete, we now need a method that searches through a position and reveals all non-mine adjacent positions. In general, this is a \emph{traversal} algorithm called \emph{depth-first search}. The idea is to recursively extend out the path until we hit a mine, at which point we unwind the recursive calls to extend another path.

    Design the static \ttt{void extPath(char[][] board, int mx, int my)} method that receives a board and a move position, and extends the path from the given position using the following rules:

    \begin{enumerate}[label=(\roman*)]
        \item If the given move position is invalid, then return.
        \item If the character at \ttt{board[mx][my]} is not a dash, \ttt{\q{}-\q{}}, then return.
        \item Otherwise, determine the number of adjacent mines to the move position. If the number of adjacent mines is non-zero, assign to \ttt{board[mx][my]} the number of mines at that move position.
        \item If the number of adjacent mines \emph{is} zero, then we can extend out the path to all non-mine neighbors. First, assign to \ttt{board[mx][my]} the character literal \ttt{\q{}X\q{}}, then loop over all non-mine neighbors to the move position. In the loop body, call \ttt{extendPath} on each neighbor.
    \end{enumerate}

    \item Minesweeper board generation is an algorithmic problem in and of itself, and as such our implementation will be simple.
    Design the static \ttt{char[][] makeBoard(int N, int M, int B)} method that receives a board size of~$N$ rows,~$M$ columns, and~$B$ mines to place.
    To randomly place mines, create a \ttt{List<int[]>} of all the possible cells on the board, shuffle the list, retrieve the first~$B$ cells, and assign the character literal \ttt{\q{}B\q{}} to them. Assign the character literal \ttt{\q{}-\q{}} to all other cells.

    \item Finally, design the static \ttt{char[][] play(char[][] board, int mx, int my)} method that receives a board and a move position, and attempts to play the given move position on the board. If, at that position on the board, there is a mine, return \ttt{null}. Otherwise, call \ttt{extPath} on the board and position, then return \ttt{board}. In essence, \ttt{play} receives one game state and transitions it to the next state.
\end{enumerate}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{int sumOdd(List<Integer> l)} that, when given a  list of integers, filters out even numbers and then calculates the sum of the remaining odd numbers. You must use the Stream API.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{String conjoin(List<String> los)} method that, when given a list of strings, concatenates all the strings together into a single string, separated by a comma. You must use the Stream API.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{Map<Integer, Integer> groupLength(List<String> los)} that, when given a list of strings, groups the words by their length and counts how many words are there for each length. This means that the return value should be a \ttt{Map<Integer, Integer>}. There are a couple of ways to do this, and any way that correctly utilizes the Stream API is fine.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{List<String> addYRemoveYY(List<String> los)} that, when given a list of strings, returns a list where each string has \ttt{"y"} added at its end, omitting any resulting strings that contain \ttt{"yy"} as a substring anywhere. You must use the Stream API.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{List<String> dollarAll(List<Integer> lon)} method that, when given a list of numbers, returns a list of those numbers converted to strings, prefixed by a dollar sign. You must use the Stream API.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{List<int[]> containsHigh(List<int[]>)} method that, when given a list of two-element arrays representing $x, y$ coordinate pairs, returns whether or not any of the $y$-coordinates are greater than~$450$. Hint: use the \ttt{anyMatch} stream method.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{List<int[]> removeCollisions(List<int[]> lop, int[] p)} method that, when given a list of two-element arrays representing $x, y$ coordinate pairs, returns a list of those arrays that are not equal to~$p$. You must use the Stream API.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{List<Integer> sqAddFiveOmit(List<Integer> lon)} that receives a list of numbers, returns a list of those numbers squared and adds five to the result, omitting any of the resulting numbers that end in $5$ or~$6$. You must use the Stream API.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{List<Integer> remvDups(List<Integer> lon)} method, which receives a list of integers, removes all duplicate integers. Return this result as a new list. You must use the Stream API.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{List<String> removeLonger(List<String> los, int n)} method that receives a list of strings, and removes all strings that contain more characters than a given integer~$n$. Return this result as a new list. You must use the Stream API.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{List<Double> filterThenSquare(List<Double> lon)} method, which receives a list of doubles, removes all odd values, and squares the remaining values. Return this result as a new list. You must use the Stream API.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{double filterDoubleAvg(List<Integer> lon)} method that, when given a list of integers, removes all non-prime numbers, doubles each remaining value, and computes the average of said values. Return this result as a \ttt{double} value. You must use the Stream API.}

\myexercise{1}{chapter-arrays-collections}{Design the \ttt{Optional<Integer> min(List<Integer> lon)} method that, when given a list of integers, returns the minimum value in the list as an \ttt{Optional<Integer>}. If there are no values in the given list, return \ttt{Optional.empty()}. You must use the Stream API.}

\myexercise{1}{chapter-arrays-collections}{Design the generic \ttt{<K, V> V lookup(Map<K, V> m)} method that, when given an \ttt{Map<K, V>} $M$ and a value $k$ of type \ttt{K}, returns the corresponding value (of type \ttt{V}) associated with the key $k$ in~$M$. If the key does not exist, return \ttt{null}. You will need to use the \ttt{equals} method.}

\myexercise{1}{chapter-arrays-collections}{Design the generic \ttt{<T> String stringifyList(List<T> l)} method that, when given an list of values $l$, returns a \ttt{String} of comma-separated values where each value is an element of $l$, but converted into a \ttt{String}. You'll need to use the \ttt{toString} method implementation of the generic type \ttt{T}.}

\myexercise{2}{chapter-arrays-collections}{Design the generic \ttt{<T extends Comparable<T>> Optional<T> min(List<T> ls)} method, which receives a list of comparable elements and returns the minimum element in the list. It should return an \ttt{Optional} value of type \ttt{T}, where \ttt{T} is the type of the list. If the list is empty, return an empty \ttt{Optional}. Remember that \ttt{T} must be a type that implements the \ttt{Comparable} interface.}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{<T extends List<Integer>> boolean areParallelLists(T t, T u)} method that, when given two types of lists $t$ and $u$ that store integer values, determines whether or not they are ``parallel.'' In this context, Two integer lists are parallel if they differ by a single constant factor. For example, where $t=\{5, 10, 15, 20\}$ and $u=\{20, 40, 60, 80\}$, $t$ and $u$ are parallel because every element in $t$ multiplied by four gets us a parallel element in $u$. This factorization is bidirectional, meaning that $t$ could be $\{100, 200, 300, 200\}$ and $u$ could be $\{10, 20, 30, 20\}$. Note that a list of all zeroes is parallel to every other list.}

\myexercise{2}{chapter-arrays-collections}{Design the \ttt{<T extends Set<U>, U extends Comparable<U>> boolean areEqualSets(T t, T u)} m\-ethod that, when given two types of sets $t$ and $u$ that store comparable elements, returns whether they are equal to one another. Two sets are equivalent if they are subsets of each other. You must traverse over the sets; you \textbf{cannot} use the built-in \ttt{equals} method provided by the \ttt{Set} implementations.}
