\section{Searching}

\subsection*{Linear Search}
The \textit{linear search} algorithm is a sequential searching algorithm. That is, we check element-by-element to determine if the element we are looking for is in the list. If the element is in the list, we return the index of the element. If the element is not in the list, we (generally) return $-1$. Linear search is nonsensical for non-constant-time access data structures, such as linked lists, because the whole point of linear search is to retrieve an element at its index quickly, then determine if it is the element we are searching.

\subsubsection*{Standard Recursive Linear Search}
We might think that a standard recursive linear search works, and indeed it is possible to write such an algorithm, but in Java it is almost nonsensical to do so. Consider the possible base cases: if the list is empty, what do we return? As described earlier, we might return $-1$, but think about what happens when the recursive calls unwind. If we add one to the result of the recursive calls when searching, then if the element is not in the list, the returned value will always be the length of the list minus one. Should we find the desired element, we might return zero, which works as expected. It's only in the cases when we do not find the element that we run into trouble. There are two possible solutions: throw an exception if the element is not present, or simply do not use a standard recursive linear search.\footnote{Some languages, e.g., Scheme, use \textit{continuations} to represent ``jump-out'' states; allowing the program to forgo unwinding the call stack when returning $-1$. Since Java does not support continuations by defauilt, we cannot use this methodology.} We might also think to use \ttt{Optional}, but this is not a good idea either, since we would need to check the result of the recursive calls, which detracts from the simplicity of the algorithm.

Another reason why the standard-recursive version is suboptimal is because we have no way of passing the index-to-check; we instead must create sublists of the original list, which is horribly inefficient (at least in Java).

First, let's create an interface for designing linear search algorithms. Recall when we stated that the data structure should guarantee constant-access times. The \ttt{List} interface does not provide this promise, so we will instead opt for a generic \ttt{AbstractList<V>}, where \ttt{V} is any comparable type. The method provided by the interface should receive the list and the element to search.

\begin{cl}[ILinearSearch.java]{Linear Search Interface}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

interface ILinearSearch<V extends Comparable<V>> {
  
  int linearSearch(AbstractList<V> ls, V v);
}
\end{lstlisting}
\end{cl}

\begin{cl}[StandardRecursiveLinearSearch.java]{Standard-Recursive Linear Search with Exceptions}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.NoSuchElementException;
  
class StandardRecursiveLinearSearch<V extends Comparable<V>> implements ILinearSearch<V> {
  
  @Override
  public int linearSearch(AbstractList<V> ls, V v) {
    if (ls.isEmpty()) { throw new NoSuchElementException(); }
    else if (ls.get(0).equals(v)) { return 0; }
    else { return 1 + linearSearch((AbstractList<V>) ls.subList(1, ls.size()), v); }
  }
}
\end{lstlisting}
\end{cl}

\subsubsection*{Tail Recursive Linear Search}


\begin{cl}[TailRecursiveLinearSearch.java]{Tail-Recursive Linear Search}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

class TailRecursiveLinearSearch<V extends Comparable<V>> implements ILinearSearch<V> {
  @Override
  public int linearSearch(AbstractList<V> ls, V v) {
    return this.linearSearchHelper(ls, v, 0);
  }

  private int linearSearchHelper(AbstractList<V> ls, V v, int idx) {
    if (idx == ls.size()) { return -1; }
    else if (ls.get(idx).equals(v)) { return idx; }
    else { return linearSearchHelper(ls, v, idx + 1); }
  }
}
\end{lstlisting}
\end{cl}

\subsubsection*{Loop Linear Search}
\begin{cl}[LoopLinearSearch.java]{Iterative Linear Search}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

class LoopLinearSearch<V extends Comparable<V>> implements ILinearSearch<V> {

  @Override
  public int linearSearch(AbstractList<V> ls, V v) {
    int idx = 0;
    for (int i = 0; i < ls.size(); i++) {
      if (ls.get(i).equals(v)) { return i; }
    }
    return -1;
  }
}
\end{lstlisting}
\end{cl}

\subsection*{Binary Search}

Binary search makes even less sense to design using a standard-recursive algorithm because of the fact that we have to search separate parts of the list. 

\begin{cl}[IBinarySearch.java]{Binary Search Interface}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

interface IBinarySearch<V extends Comparable<V>> {
  
  int binarySearch(AbstractList<V> ls, V v);
}
\end{lstlisting}
\end{cl}

\subsubsection*{Tail Recursive Binary Search}

\begin{cl}[TailRecursiveBinarySearch.java]{Tail-Recursive Binary Search}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.NoSuchElementException;

class TailRecursiveBinarySearch<V extends Comparable<V>> implements IBinarySearch<V> {

  @Override
  public int binarySearch(AbstractList<V> ls, V v) {
    return binarySearchTRHelper(ls, v, 0, ls.size() - 1);
  }

  private int binarySearchTRHelper(AbstractList<V> ls, V v, int low, int high) {
    if (low > high) { return -1; }
    else {
      int mid = low + (high - low) / 2;
      if (ls.get(mid).compareTo(v) > 0) { 
        return binarySearchTRHelper(ls, v, low, mid - 1); 
      } else if (ls.get(mid).compareTo(v) < 0) { 
        return binarySearchTRHelper(ls, v, mid + 1, high); 
      } else { 
        return mid; 
      }
    }
  }
}
\end{lstlisting}
\end{cl}

\subsubsection*{Loop Binary Search}

\begin{cl}[LoopBinarySearch.java]{Iterative Binary Search}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
  
class LoopBinarySearch<V extends Comparable<V>> implements IBinarySearch<V> {
  
  @Override
  public int binarySearch(AbstractList<V> ls, V v) {
    int low = 0;
    int high = ls.size() - 1;
    while (low <= high) {
      int mid = low + (high - low) / 2;
      if (ls.get(mid).compareTo(v) > 0) { high = mid - 1; } 
      else if (ls.get(mid).compareTo(v) < 0) { low = mid + 1; } 
      else { return mid; }
    }
    return -1;
  }
}
\end{lstlisting}
\end{cl}
