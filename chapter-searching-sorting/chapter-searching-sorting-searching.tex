\section{Searching}

\subsection*{Linear Search}
The \textit{linear search} algorithm is a sequential searching algorithm. That is, we check element-by-element to determine if the element we are looking for is in the list. If the element is in the list, we return the index of the element. If the element is not in the list, we (generally) return $-1$. Linear search is nonsensical for non-constant-time access data structures, such as linked lists, because the whole point of linear search is to retrieve an element at its index quickly, then determine if it is the element we are searching. 

\subsubsection*{Standard Recursive Linear Search}
We might think that a standard recursive linear search works, and indeed it is possible to write such an algorithm, but in Java it is almost nonsensical to do so. Consider the possible base cases: if the list is empty, what do we return? As described earlier, we might return $-1$, but think about what happens when the recursive calls unwind. If we add one to the result of the recursive calls when searching, then if the element is not in the list, the returned value will always be the length of the list minus one. Should we find the desired element, we might return zero, which works as expected. It's only in the cases when we do not find the element that we run into trouble. There are two possible solutions: throw an exception if the element is not present, or simply do not use a standard recursive linear search.\footnote{Some languages, e.g., Scheme, use \textit{continuations} to represent ``jump-out'' states; allowing the program to forgo unwinding the call stack when returning $-1$. Since Java does not support continuations by defauilt, we cannot use this methodology.} We might also think to use \ttt{Optional}, but this is not a good idea either, since we would need to check the result of the recursive calls, which detracts from the simplicity of the algorithm.

Another reason why the standard-recursive version is suboptimal is because we have no way of passing the index-to-check; we instead must create sublists of the original list, which is horribly inefficient (at least in Java).

First, let's create an interface for designing linear search algorithms. Recall when we stated that the data structure should guarantee constant-access times. The \ttt{List} interface does not provide this promise, so we will instead opt for a generic \ttt{AbstractList<V>}, where \ttt{V} is any comparable type. The method provided by the interface should receive the list and the element to search.

\begin{cl}[ILinearSearch.java]{Linear Search Interface}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

interface ILinearSearch<V extends Comparable<V>> {
  
  int linearSearch(AbstractList<V> ls, V v);
}
\end{lstlisting}
\end{cl}

\begin{cl}[StandardRecursiveLinearSearch.java]{Standard-Recursive Linear Search with Exceptions}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.NoSuchElementException;
  
class StandardRecursiveLinearSearch<V extends Comparable<V>> implements ILinearSearch<V> {
  
  @Override
  public int linearSearch(AbstractList<V> ls, V v) {
    if (ls.isEmpty()) { throw new NoSuchElementException(); }
    else if (ls.get(0).equals(v)) { return 0; }
    else { return 1 + linearSearch((AbstractList<V>) ls.subList(1, ls.size()), v); }
  }
}
\end{lstlisting}
\end{cl}

\subsubsection*{Tail Recursive Linear Search}

\begin{cl}[TailRecursiveLinearSearch.java]{Tail-Recursive Linear Search}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

class TailRecursiveLinearSearch<V extends Comparable<V>> implements ILinearSearch<V> {
  @Override
  public int linearSearch(AbstractList<V> ls, V v) {
    return this.linearSearchHelper(ls, v, 0);
  }

  private int linearSearchHelper(AbstractList<V> ls, V v, int idx) {
    if (idx == ls.size()) { return -1; }
    else if (ls.get(idx).equals(v)) { return idx; }
    else { return linearSearchHelper(ls, v, idx + 1); }
  }
}
\end{lstlisting}
\end{cl}

\subsubsection*{Loop Linear Search}
\begin{cl}[LoopLinearSearch.java]{Iterative Linear Search}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

class LoopLinearSearch<V extends Comparable<V>> implements ILinearSearch<V> {

  @Override
  public int linearSearch(AbstractList<V> ls, V v) {
    int idx = 0;
    for (int i = 0; i < ls.size(); i++) {
      if (ls.get(i).equals(v)) { return i; }
    }
    return -1;
  }
}
\end{lstlisting}
\end{cl}

\subsection*{Binary Search}

Binary search is the alternative to linear search, and fortunately proves to be significantly faster, but with a catch: the data must be sorted in order to correctly use a binary searching algorithm. Here's how it works: we check the middle element $e$ of the list against our target value $k$ and, if they are equal, we return the middle element index. If $e < k$, we know that $k$ is greater than all elements to the left of $e$ because the data is in sorted order. Therefore, we can check exclusively on the right-half. This idea applies to the left-half as well; if $e > k$, then $k$ must be less than all elements to the right of the middle. 

Binary search makes even less sense to design as a standard-recursive algorithm because of the fact that we have to search separate partitions of the list. So, we will only design tail-recursive and loop versions. The tail-recursive variant is extremely simple and directly follows from the English description of the algorithm: we keep track of the indices to search between $l$ and $h$, assuming $l \leq h$. Given this assumption we compute the middle element index as $l + (h - l) / 2$, and recursively update $l$/$h$ as necessary to change the bounds of the search ``zone''. If $l > h$, the bounds have crossed, meaning the search element does not exist in the list. 

When we state that binary search is faster than linear search, this is of course relative to the problem context; if we want to search an unsorted list exactly once, then taking the time to sort the data, then run binary search, it is not optimal. Repeatedly searching for elements in a list containing many values should be done with first sorting the list, then binary searching. As an example, if we were to use linear search on a sorted list containing half a billion elements for an element that is not present, we must check all half a billion values. Compare this to binary search, which is logarithmic in the number of elements. So, taking the base two logarithm of our input size places an upper-bound of twenty-nine comparisons (after rounding). To say that this is a substantial performance increase is underselling it to the max.

\begin{cl}[IBinarySearch.java]{Binary Search Interface}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

interface IBinarySearch<V extends Comparable<V>> {
  
  int binarySearch(AbstractList<V> ls, V v);
}
\end{lstlisting}
\end{cl}

\subsubsection*{Tail Recursive Binary Search}

\begin{cl}[TailRecursiveBinarySearch.java]{Tail-Recursive Binary Search}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

class TailRecursiveBinarySearch<V extends Comparable<V>> implements IBinarySearch<V> {

  @Override
  public int binarySearch(AbstractList<V> ls, V v) {
    return binarySearchTRHelper(ls, v, 0, ls.size() - 1);
  }

  private int binarySearchTRHelper(AbstractList<V> ls, V v, int low, int high) {
    if (low > high) { return -1; }
    else {
      int mid = low + (high - low) / 2;
      if (ls.get(mid).compareTo(v) > 0) { 
        return binarySearchTRHelper(ls, v, low, mid - 1); 
      } else if (ls.get(mid).compareTo(v) < 0) { 
        return binarySearchTRHelper(ls, v, mid + 1, high); 
      } else { 
        return mid; 
      }
    }
  }
}
\end{lstlisting}
\end{cl}

\subsubsection*{Loop Binary Search}

\begin{cl}[LoopBinarySearch.java]{Iterative Binary Search}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
  
class LoopBinarySearch<V extends Comparable<V>> implements IBinarySearch<V> {
  
  @Override
  public int binarySearch(AbstractList<V> ls, V v) {
    int low = 0;
    int high = ls.size() - 1;
    while (low <= high) {
      int mid = low + (high - low) / 2;
      if (ls.get(mid).compareTo(v) > 0) { high = mid - 1; } 
      else if (ls.get(mid).compareTo(v) < 0) { low = mid + 1; } 
      else { return mid; }
    }
    return -1;
  }
}
\end{lstlisting}
\end{cl}
