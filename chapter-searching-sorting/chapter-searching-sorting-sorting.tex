\section{Sorting}
In this section we will begin our discussion on the analysis and implementation of sorting algorithms. Each algorithm contains two variants: a functional and in-place variant. The functional variant will return a new list that is sorted, while the in-place variant will sort the list in-place. The functional variant is, in principle, easier to implement, but the in-place variant is more efficient in terms of memory usage. Moreover, all lists that are parameters to the sorting algorithms are assumed to be constant-access lists. Accordingly we specify that the input list extends \ttt{AbstractList} class, which guarantees our presumption.

For each algorithm, we will assume the same three lists are declared and properly instantiated within the respective unit testing files. To conserve space, we will list their values below only once.

\begin{verbatim}
AbstractList<Integer> LS1 = 
  new ArrayList<>(List.of(5, 4, 2, 1, 3));
AbstractList<Integer> LS2 = 
  new ArrayList<>(List.of());
AbstractList<Integer> LS3 = 
  new ArrayList<>(List.of(10, 8, 6, 7, 2, 10, 3, 3, 3, 10));
\end{verbatim}

\subsection{Insertion Sort}
\begin{cl}[InsertionSortTester.java]{Insertion Sort Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class InsertionSortTester {

  @Test
  void fInsSort() {
    IInsertionSort<Integer> ss = new FunctionalInsertionSort<>();
    assertAll(
      () -> assertEquals(List.of(1, 2, 3, 4, 5), ss.insertionSort(LS1)),
      () -> assertEquals(List.of(), ss.insertionSort(LS2)),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), ss.insertionSort(LS3))
    );
  }

  @Test
  void ipInsSort() {
    IInsertionSort<Integer> is = new InPlaceInsertionSort<>();
    assertAll(
      () -> is.insertionSort(LS1),
      () -> assertEquals(List.of(1, 2, 3, 4, 5), LS1),
      () -> is.insertionSort(LS2),
      () -> assertEquals(List.of(), LS2),
      () -> is.insertionSort(LS3),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), LS3)
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[IInsertionSort.java]{Insertion Sort Generic Interface}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

interface IInsertionSort<V extends Comparable<V>> {
  AbstractList<V> insertionSort(AbstractList<V> ls);
}
\end{lstlisting}
\end{cl}

\subsubsection*{Functional Insertion Sort}
\begin{cl}[FunctionalInsertionSort.java]{Functional Insertion Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.ArrayList;

class FunctionalInsertionSort<V extends Comparable<V>> implements IInsertionSort<V> {
  
@Override
  public AbstractList<V> insertionSort(AbstractList<V> ls) {
    if (ls.isEmpty()) { return new ArrayList<>(); }
    else { 
      return insert(ls.get(0), 
                    insertionSort((AbstractList<V>) ls.subList(1, ls.size()))); 
    }
  }

  /**
   * Inserts an element into a sorted list of values.
   * 
   * @param val value to insert.
   * @param sortedRest a sorted sublist.
   * @return the sorted sublist with the new value inserted.
   */
  private AbstractList<V> insert(V val, AbstractList<V> sortedRest) {
    if (sortedRest.isEmpty()) {
      ArrayList<V> ls = new ArrayList<>();
      ls.add(val);
      return ls;
    } else if (val.compareTo(sortedRest.get(0)) < 0) {
      ArrayList<V> ls = new ArrayList<>();
      ls.add(val);
      ls.addAll(sortedRest);
      return ls;
    } else {
      ArrayList<V> ls = new ArrayList<>();
      ls.add(sortedRest.get(0));
      ls.addAll(insert(val, (AbstractList<V>) 
                            sortedRest.subList(1, sortedRest.size())));
      return ls;
    }
  }
}
\end{lstlisting}
\end{cl}

\subsubsection*{In-place Insertion Sort}
\begin{cl}[InPlaceInsertionSort.java]{In-place Insertion Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.Collections;

class InPlaceInsertionSort<V extends Comparable<V>> implements IInsertionSort<V> {

  @Override
  public AbstractList<V> insertionSort(AbstractList<V> ls) {
    for (int i = 1; i < ls.size(); i++) {
      V curr = ls.get(i);
      int j = i - 1;
      while (j >= 0 && ls.get(j).compareTo(curr) > 0) {
        Collections.swap(ls, j+1, j);
        j--;
      }
    }
    return ls;
  }
}
\end{lstlisting}
\end{cl}


\subsection{Selection Sort}
\begin{cl}[SelectionSortTester.java]{Selection Sort Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class SelectionSortTester {

  @Test
  void fSelSort() {
    ISelectionSort<Integer> ss = new FunctionalSelectionSort<>();
    assertAll(
      () -> assertEquals(List.of(1, 2, 3, 4, 5), ss.selectionSort(LS1)),
      () -> assertEquals(List.of(), ss.selectionSort(LS2)),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), ss.selectionSort(LS3))
    );
  }

  @Test
  void ipqsTester() {
    ISelectionSort<Integer> ss = new InPlaceSelectionSort<>();
    assertAll(
      () -> ss.selectionSort(LS1),
      () -> assertEquals(List.of(1, 2, 3, 4, 5), LS1),
      () -> ss.selectionSort(LS2),
      () -> assertEquals(List.of(), LS2),
      () -> ss.selectionSort(LS3),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), LS3)
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[ISelectionSort.java]{Insertion Sort Generic Interface}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

interface ISelectionSort<V extends Comparable<V>> {
  AbstractList<V> selectionSort(AbstractList<V> ls);
}
\end{lstlisting}
\end{cl}

\subsubsection*{Functional Selection Sort}
\begin{cl}[FunctionalSelectionSort.java]{Functional Selection Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.IntStream;

class FunctionalSelectionSort<V extends Comparable<V>> implements ISelectionSort<V> {

  @Override
  public AbstractList<V> selectionSort(AbstractList<V> ls) {
    if (ls.isEmpty() || ls.size() == 1) { return ls; }
    else {
      // Remember that min returns an Optional, but we know it is non-empty.
      int minIdx = IntStream.range(0, ls.size())
                            .boxed()
                            .min((i1, i2) -> ls.get(i1).compareTo(ls.get(i2)))
                            .get();

      // Swap the minimum element with the first element.
      Collections.swap(ls, 0, minIdx);

      // Sort the rest of the list (excluding the first element).
      AbstractList<V> sortedRest = selectionSort(new ArrayList<>(ls.subList(1, ls.size())));

      // Construct the final sorted list.
      AbstractList<V> sortedList = new ArrayList<>();
      sortedList.add(ls.get(0));
      sortedList.addAll(sortedRest);
      return sortedList;
    }
  }
}
\end{lstlisting}
\end{cl}

\subsubsection*{In-place Selection Sort}
\begin{cl}[InPlaceSelectionSort.java]{In-place Selection Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.Collections;

class InPlaceSelectionSort<V extends Comparable<V>> implements ISelectionSort<V> {
  
  @Override
  public AbstractList<V> selectionSort(AbstractList<V> ls) {
    for (int i = 0; i < ls.size(); i++) {
      V min = ls.get(i);
      int minIdx = 0;
      boolean needToSwap = false;
      // Find the minimum value. If we get a value less than the current minimum,
      // we need to swap at the end.
      for (int j = i + 1; j < ls.size(); j++) {
        if (ls.get(j).compareTo(min) < 0) {
          min = ls.get(j);
          minIdx = j;
          needToSwap = true;
        }
      }
      // Swap the minimum value with the current index, if need be.
      if(needToSwap) { Collections.swap(ls, minIdx, i); }
    }
    return ls;
  }
}
\end{lstlisting}  
\end{cl}


\subsection{Bubble Sort}
\subsubsection*{Functional Bubble Sort}
\subsubsection*{In-place Bubble Sort}


\subsection{Merge Sort}
\subsubsection*{Functional Merge Sort}
\subsubsection*{In-place Merge Sort}


\subsection{Quick Sort}

\begin{cl}[QuickSortTester.java]{Quick Sort Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class QuickSortTester {

  @Test
  void fqsTester() {
    IQuickSort<Integer> fqs = new FunctionalQuickSort<>();
    assertAll(
      () -> assertEquals(List.of(1, 2, 3, 4, 5), fqs.quicksort(LS1)),
      () -> assertEquals(List.of(), fqs.quicksort(LS2)),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), fqs.quicksort(LS3))
    );
  }

  @Test
  void ipqsTester() {
    IQuickSort<Integer> ipqs = new InPlaceQuickSort<>();
    assertAll(
      () -> ipqs.quicksort(LS1),
      () -> assertEquals(List.of(1, 2, 3, 4, 5), LS1),
      () -> ipqs.quicksort(LS2),
      () -> assertEquals(List.of(), LS2),
      () -> ipqs.quicksort(LS3),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), LS3)
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[IQuickSort.java]{Quick Sort Generic Interface}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

interface IQuickSort<V extends Comparable<V>> {
  AbstractList<V> quicksort(AbstractList<V> ls);
}
\end{lstlisting}
\end{cl}

% talk about the randomized pivot versus the median of the list
\subsubsection*{Functional Quick Sort}
The functional implementation of quick sort is beautiful and elegant. We choose a pivot $p$ at random, then create three sublists $l_<$, $l_>$, $l_=$, where $l_<$ stores all elements less than $p$, where $l_>$ stores all elements greater than $p$, and $l_=$ stores all elements equal to the pivot. Each sublist, excluding $l_=$, is recursively sorted, followed by concatenating the three sublists in order. 

%%%%%%%%%%%%% FUNCTIONAL QUICK SORT %%%%%%%%%%%%% 
\begin{cl}[FunctionalQuickSort.java]{Functional Quick Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.stream.Collectors;

class FunctionalQuickSort<V extends Comparable<V>> implements IQuickSort<V> {

  @Override
  public AbstractList<V> quicksort(AbstractList<V> ls) {
    if (ls.isEmpty()) { return ls; }
    else {
      // Choose a random pivot.
      V pivot = ls.get((int) (Math.random() * ls.size()));

      // Sort the left-half.
      AbstractList<V> leftHalf = (AbstractList<V>) ls.stream()
                                                     .filter(x -> x.compareTo(pivot) < 0)
                                                     .collect(Collectors.toList());
      AbstractList<V> leftSorted = quicksort(leftHalf);

      // Sort the right-half.
      AbstractList<V> rightHalf = (AbstractList<V>) ls.stream()
                                                      .filter(x -> x.compareTo(pivot) > 0)
                                                      .collect(Collectors.toList());
      AbstractList<V> rightSorted = quicksort(rightHalf);

      // Get all elements equal to the pivot.
      AbstractList<V> equal = (AbstractList<V>) ls.stream()
                                                  .filter(x -> x.compareTo(pivot) == 0)
                                                  .collect(Collectors.toList());

      // Merge the three.
      leftSorted.addAll(equal);
      leftSorted.addAll(rightSorted);
      return leftSorted;
    }
  }
}
\end{lstlisting}
\end{cl}

%%%%%%%%%%%%% IN PLACE QUICK SORT %%%%%%%%%%%%% 
\subsubsection*{In-place Quick Sort}
\begin{cl}[InPlaceQuickSort.java]{In-place Quick Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.Collections;
import java.util.Random;

class InPlaceQuickSort<V extends Comparable<V>> implements IQuickSort<V> {

  @Override
  public AbstractList<V> quicksort(AbstractList<V> ls) {
    this.quicksortHelper(ls, 0, ls.size() - 1);
    return ls;
  }

  /**
   * Recursive helper method for quicksort.
   * 
   * @param ls the List to sort.
   * @param low the lower bound of the partition.
   * @param high the upper bound of the partition.
   */
  private void quicksortHelper(AbstractList<V> ls, int low, int high) {
    if (low < high) {
      int pivot = quicksortPartition(ls, low, high);
      quicksortHelper(ls, low, pivot - 1);
      quicksortHelper(ls, pivot + 1, high);
    }
  }

  /**
   * Creates a quicksort partition, where all elements less than the pivot are
   * to the left of the pivot, and all elements greater than the pivot are to its right.
   * 
   * @param ls the List to partition.
   * @param low the lower bound of the partition.
   * @param high the upper bound of the partition.
   * @return the index of the pivot.
   */
  private int quicksortPartition(AbstractList<V> ls, int low, int high) {
    int rand = new Random().nextInt(high - low + 1) + low;
    Collections.swap(ls, rand, high);
    V pivot = ls.get(high);
    int prevLowest = low;
    for (int i = low; i <= high; i++) {
      if (ls.get(i).compareTo(pivot) < 0) {
        Collections.swap(ls, i, prevLowest++);
      }
    }
    Collections.swap(ls, prevLowest, high);
    return prevLowest;
  }
}
\end{lstlisting}
\end{cl}