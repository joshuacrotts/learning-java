\section{Sorting}
In this section we will begin our discussion on the analysis and implementation of sorting algorithms. Each algorithm contains two variants: a functional and in-place variant. The functional variant will return a new list that is sorted, while the in-place variant will sort the list in-place. The functional variant is, in principle, easier to implement, but the in-place variant is more efficient in terms of memory usage. Moreover, all lists that are parameters to the sorting algorithms are assumed to be constant-access lists. Accordingly we specify that the input list extends \ttt{AbstractList}\index{\ttt{AbstractList}} class, which guarantees our presumption.

For each algorithm, we will assume the same three lists are declared and properly instantiated within the respective unit testing files. To conserve space, we will list their values below only once.

\begin{verbatim}
AbstractList<Integer> LS1 = 
  new ArrayList<>(List.of(5, 4, 2, 1, 3));
AbstractList<Integer> LS2 = 
  new ArrayList<>(List.of());
AbstractList<Integer> LS3 = 
  new ArrayList<>(List.of(10, 8, 6, 7, 2, 10, 3, 3, 3, 10));
\end{verbatim}

\subsection*{Insertion Sort}
\begin{cl}[InsertionSortTester.java]{Insertion Sort Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class InsertionSortTester {

  @Test
  void fInsSort() {
    IInsertionSort<Integer> ss = new FunctionalInsertionSort<>();
    assertAll(
      () -> assertEquals(List.of(1, 2, 3, 4, 5), ss.insertionSort(LS1)),
      () -> assertEquals(List.of(), ss.insertionSort(LS2)),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), ss.insertionSort(LS3))
    );
  }

  @Test
  void ipInsSort() {
    IInsertionSort<Integer> is = new InPlaceInsertionSort<>();
    assertAll(
      () -> is.insertionSort(LS1),
      () -> assertEquals(List.of(1, 2, 3, 4, 5), LS1),
      () -> is.insertionSort(LS2),
      () -> assertEquals(List.of(), LS2),
      () -> is.insertionSort(LS3),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), LS3)
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[IInsertionSort.java]{Insertion Sort Generic Interface}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

interface IInsertionSort<V extends Comparable<V>> {
  AbstractList<V> insertionSort(AbstractList<V> ls);
}
\end{lstlisting}
\end{cl}

\subsubsection*{Functional Insertion Sort}
\begin{cl}[FunctionalInsertionSort.java]{Functional Insertion Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.ArrayList;

class FunctionalInsertionSort<V extends Comparable<V>> implements IInsertionSort<V> {
  
  @Override
  public AbstractList<V> insertionSort(AbstractList<V> ls) {
    if (ls.isEmpty()) { return new ArrayList<>(); }
    else { 
      return insert(ls.get(0), 
                    insertionSort((AbstractList<V>) ls.subList(1, ls.size()))); 
    }
  }

  /**
   * Inserts an element into a sorted list of values.
   * 
   * @param val value to insert.
   * @param sortedRest a sorted sublist.
   * @return the sorted sublist with the new value inserted.
   */
  private AbstractList<V> insert(V val, AbstractList<V> sortedRest) {
    if (sortedRest.isEmpty()) {
      ArrayList<V> ls = new ArrayList<>();
      ls.add(val);
      return ls;
    } else if (val.compareTo(sortedRest.get(0)) < 0) {
      ArrayList<V> ls = new ArrayList<>();
      ls.add(val);
      ls.addAll(sortedRest);
      return ls;
    } else {
      ArrayList<V> ls = new ArrayList<>();
      ls.add(sortedRest.get(0));
      ls.addAll(insert(val, (AbstractList<V>) 
                            sortedRest.subList(1, sortedRest.size())));
      return ls;
    }
  }
}
\end{lstlisting}
\end{cl}

\subsubsection*{In-place Insertion Sort}
\begin{cl}[InPlaceInsertionSort.java]{In-place Insertion Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.Collections;

class InPlaceInsertionSort<V extends Comparable<V>> implements IInsertionSort<V> {

  @Override
  public AbstractList<V> insertionSort(AbstractList<V> ls) {
    for (int i = 1; i < ls.size(); i++) {
      V curr = ls.get(i);
      int j = i - 1;
      while (j >= 0 && ls.get(j).compareTo(curr) > 0) {
        Collections.swap(ls, j+1, j);
        j--;
      }
    }
    return ls;
  }
}
\end{lstlisting}
\end{cl}


\subsection*{Selection Sort}
\begin{cl}[SelectionSortTester.java]{Selection Sort Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class SelectionSortTester {

  @Test
  void fSelSort() {
    ISelectionSort<Integer> ss = new FunctionalSelectionSort<>();
    assertAll(
      () -> assertEquals(List.of(1, 2, 3, 4, 5), ss.selectionSort(LS1)),
      () -> assertEquals(List.of(), ss.selectionSort(LS2)),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), ss.selectionSort(LS3))
    );
  }

  @Test
  void ipqsTester() {
    ISelectionSort<Integer> ss = new InPlaceSelectionSort<>();
    assertAll(
      () -> ss.selectionSort(LS1),
      () -> assertEquals(List.of(1, 2, 3, 4, 5), LS1),
      () -> ss.selectionSort(LS2),
      () -> assertEquals(List.of(), LS2),
      () -> ss.selectionSort(LS3),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), LS3)
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[ISelectionSort.java]{Insertion Sort Generic Interface}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

interface ISelectionSort<V extends Comparable<V>> {
  AbstractList<V> selectionSort(AbstractList<V> ls);
}
\end{lstlisting}
\end{cl}

\subsubsection*{Functional Selection Sort}
\begin{cl}[FunctionalSelectionSort.java]{Functional Selection Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.IntStream;

class FunctionalSelectionSort<V extends Comparable<V>> implements ISelectionSort<V> {

  @Override
  public AbstractList<V> selectionSort(AbstractList<V> ls) {
    if (ls.isEmpty() || ls.size() == 1) { return ls; }
    else {
      // Remember that min returns an Optional, but we know it is non-empty.
      int minIdx = IntStream.range(0, ls.size())
                            .boxed()
                            .min((i1, i2) -> ls.get(i1).compareTo(ls.get(i2)))
                            .get();

      // Swap the minimum element with the first element.
      Collections.swap(ls, 0, minIdx);

      // Sort the rest of the list (excluding the first element).
      AbstractList<V> sortedRest = selectionSort(new ArrayList<>(ls.subList(1, ls.size())));

      // Construct the final sorted list.
      AbstractList<V> sortedList = new ArrayList<>();
      sortedList.add(ls.get(0));
      sortedList.addAll(sortedRest);
      return sortedList;
    }
  }
}
\end{lstlisting}
\end{cl}

\subsubsection*{In-place Selection Sort}
\begin{cl}[InPlaceSelectionSort.java]{In-place Selection Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.Collections;

class InPlaceSelectionSort<V extends Comparable<V>> implements ISelectionSort<V> {
  
  @Override
  public AbstractList<V> selectionSort(AbstractList<V> ls) {
    for (int i = 0; i < ls.size(); i++) {
      V min = ls.get(i);
      int minIdx = 0;
      boolean needToSwap = false;
      // Find the minimum value. If we get a value less than the current minimum,
      // we need to swap at the end.
      for (int j = i + 1; j < ls.size(); j++) {
        if (ls.get(j).compareTo(min) < 0) {
          min = ls.get(j);
          minIdx = j;
          needToSwap = true;
        }
      }
      // Swap the minimum value with the current index, if need be.
      if(needToSwap) { Collections.swap(ls, minIdx, i); }
    }
    return ls;
  }
}
\end{lstlisting}  
\end{cl}


\subsection*{Bubble Sort}
\begin{cl}[BubbleSortTester.java]{Bubble Sort Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class BubbleSortTester {

  @Test
  void fbs() {
    IBubbleSort<Integer> fbs = new FunctionalBubbleSort<>();
    assertAll(
      () -> assertEquals(List.of(1, 2, 3, 4, 5), fbs.bubbleSort(LS1)),
      () -> assertEquals(List.of(), fbs.bubbleSort(LS2)),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), fbs.bubbleSort(LS3))
    );
  }

  @Test
  void ipbs() {
    IBubbleSort<Integer> ipbs = new InPlaceBubbleSort<>();
    assertAll(
      () -> ipbs.bubbleSort(LS1),
      () -> assertEquals(List.of(1, 2, 3, 4, 5), LS1),
      () -> ipbs.bubbleSort(LS2),
      () -> assertEquals(List.of(), LS2),
      () -> ipbs.bubbleSort(LS3),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), LS3)
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[IBubbleSort.java]{Bubble Sort Generic Interface}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

interface IBubbleSort<V extends Comparable<V>> {
  AbstractList<V> bubbleSort(AbstractList<V> ls);
}
\end{lstlisting}
\end{cl}

\subsubsection*{Functional Bubble Sort}
\begin{cl}[FunctionalBubbleSort.java]{Functional Bubble Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.ArrayList;

class FunctionalBubbleSort<V extends Comparable<V>> implements IBubbleSort<V> {

  @Override
  public AbstractList<V> bubbleSort(AbstractList<V> ls) {
    if (ls.size() <= 1) { return ls; }
    else {
      // Find the largest element.
      V largest = getLargest(ls);
      boolean removed = false;

      // Get all elements but the largest. Removes only
      // one occurrence of the largest element.
      AbstractList<V> rest = new ArrayList<>();
      for (V v : ls) {
        if (v.equals(largest) && !removed) { removed = true; }
        else { rest.add(v); }
      }

      // Bubble sort the rest, then add the largest as the last element.
      AbstractList<V> newLs = bubbleSort(rest);
      newLs.add(largest);
      return newLs;
    }
  }

  /**
    * Get the largest element in the list.
    *
    * @param ls the list to search.
    * @return the largest element in the list.
    */
  private V getLargest(AbstractList<V> ls) {
    return ls.stream()
              .max(Comparable::compareTo)
              .orElse(null);
  }
}
\end{lstlisting}
\end{cl}

\subsubsection*{In-place Bubble Sort}
\begin{cl}[InPlaceBubbleSort.java]{In-place Bubble Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.Collections;

class InPlaceBubbleSort<V extends Comparable<V>> implements IBubbleSort<V> {

  @Override
  public AbstractList<V> bubbleSort(AbstractList<V> ls) {
    for (int i = 0; i < ls.size(); i++) {
      for (int j = 0; j < ls.size() - i - 1; j++) {
        if (ls.get(j).compareTo(ls.get(j + 1)) > 0) {
          Collections.swap(ls, j, j + 1);
        }
      }
    }
    return ls;
  }
}
\end{lstlisting}
\end{cl}


\subsection*{Merge Sort}
\begin{cl}[MergeSortTester.java]{Merge Sort Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class MergeSortTester {

  @Test
  void fmsTester() {
    IMergeSort<Integer> ms = new FunctionalMergeSort<>();
    assertAll(
      () -> assertEquals(List.of(1, 2, 3, 4, 5), ms.mergeSort(LS1)),
      () -> assertEquals(List.of(), ms.mergeSort(LS2)),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), ms.mergeSort(LS3))
    );
  }

  @Test
  void ipmsTester() {
    IMergeSort<Integer> ms = new FunctionalMergeSort<>();
    assertAll(
      () -> ms.mergeSort(LS1),
      () -> assertEquals(List.of(1, 2, 3, 4, 5), LS1),
      () -> ms.mergeSort(LS2),
      () -> assertEquals(List.of(), LS2),
      () -> ms.mergeSort(LS3),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), LS3)
    );
  }
}
\end{lstlisting}
\end{cl}
  
\begin{cl}[IMergeSort.java]{Merge Sort Generic Interface}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

interface IMergeSort<V extends Comparable<V>> {
  AbstractList<V> mergeSort(AbstractList<V> ls);
}
\end{lstlisting}
\end{cl}

\subsubsection*{Functional Merge Sort}
\begin{cl}[FunctionalMergeSort.java]{Functional Merge Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.ArrayList;
  
class FunctionalMergeSort<V extends Comparable<V>> implements IMergeSort<V> {
  
  @Override
  public AbstractList<V> mergeSort(AbstractList<V> ls) {
    return this.mergeSortHelper(ls);
  }
  
  /**
   * Recursive helper method for merge sort. Splits the list in half and merges
   * the two halves after recursively sorting them.
   * 
   * @param ls the list to sort.
   * @return the sorted list.
   */
  private AbstractList<V> mergeSortHelper(AbstractList<V> ls) {
    if (ls.isEmpty()) { return new ArrayList<>(); }
    else if (ls.size() == 1) {
      AbstractList<V> newLs = new ArrayList<>();
      newLs.add(ls.get(0));
      return newLs;
    } else {
      int mid = (ls.size() - 1) / 2;
      AbstractList<V> leftHalf = mergeSortHelper((AbstractList<V>) ls.subList(0, mid + 1));
      AbstractList<V> rightHalf = mergeSortHelper((AbstractList<V>) ls.subList(mid + 1, ls.size()));
      return merge(leftHalf, rightHalf);
    }
  }
  
  /**
   * Merges two sorted lists into one sorted list. Compares each element one-by-one
   * and adds the smaller element to the new list. If one list is exhausted, then
   * the remaining elements of the other list are added to the new list.
   *
   * @param ls1 the first sorted list.
   * @param ls2 the second sorted list.
   * @return the merged sorted list.
   */
  private AbstractList<V> merge(AbstractList<V> ls1, AbstractList<V> ls2) {
    int i = 0;
    int j = 0;
    AbstractList<V> newLs = new ArrayList<>();
          
    // Merge the lists, comparing the elements.
    while (i < ls1.size() && j < ls2.size()) {
      if (ls1.get(i).compareTo(ls2.get(j)) < 0) { newLs.add(ls1.get(i++)); }
      else { newLs.add(ls2.get(j++)); }
    }
  
    // Finish copying ls1.
    while (i < ls1.size()) { newLs.add(ls1.get(i++)); }
  
    // Finish copying ls2.
    while (j < ls2.size()) { newLs.add(ls2.get(j++)); }
  
    return newLs;
  }
}
\end{lstlisting}
\end{cl}

\subsubsection*{In-place Merge Sort}
\begin{cl}[InPlaceMergeSort.java]{In Place Merge Sort}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.ArrayList;

class InPlaceMergeSort<V extends Comparable<V>> implements IMergeSort<V> {

  @Override
  public AbstractList<V> mergeSort(AbstractList<V> ls) {
    this.mergeSortHelper(ls, 0, ls.size() - 1);
    return ls;
  }

  /**
   * Recursively sorts the list by splitting it in half and merging the two halves.
   * 
   * @param ls the list to sort.
   * @param low the lower bound of the sublist. 
   * @param high the upper bound of the sublist.
   */
  private void mergeSortHelper(AbstractList<V> ls, int low, int high) {
    if (low < high) {
      int mid = low + (high - low) / 2;
      mergeSortHelper(ls, low, mid);
      mergeSortHelper(ls, mid + 1, high);
      merge(ls, low, mid, high);
    }
  }

  /**
   * Merges two sorted sublists into one sorted list. 
   * 
   * @param ls the list to sort.
   * @param low the lower bound of the sublist.
   * @param mid the middle index of the sublist.
   * @param high the upper bound of the sublist.
   */
  private void merge(AbstractList<V> ls, int low, int mid, int high) {
    // Create two auxiliary arrays.
    AbstractList<V> left = new ArrayList<>();
    AbstractList<V> right = new ArrayList<>();

    // Copy the elements over into the auxiliary lists.
    for (int i = low; i <= mid; i++) { left.add(ls.get(i)); }
    for (int j = mid + 1; j <= high; j++) { right.add(ls.get(j)); }

    int mergedIdx = low;
    int i = 0;
    int j = 0;
        
    // Merge the elements into the existing list.
    while (i < left.size() && j < right.size()) {
      if (left.get(i).compareTo(right.get(j)) < 0) { ls.set(mergedIdx++, left.get(i++)); }
      else { ls.set(mergedIdx++, right.get(j++)); }
    }

    // Copy the rest of the elements over.
    while (i < left.size()) { ls.set(mergedIdx++, left.get(i++)); }
    while (j < right.size()) { ls.set(mergedIdx++, right.get(j++)); }
  }
}
\end{lstlisting}
\end{cl}


\subsection*{Quick Sort}

\begin{cl}[QuickSortTester.java]{Quick Sort Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class QuickSortTester {

  @Test
  void fqsTester() {
    IQuickSort<Integer> fqs = new FunctionalQuickSort<>();
    assertAll(
      () -> assertEquals(List.of(1, 2, 3, 4, 5), fqs.quicksort(LS1)),
      () -> assertEquals(List.of(), fqs.quicksort(LS2)),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), fqs.quicksort(LS3))
    );
  }

  @Test
  void ipqsTester() {
    IQuickSort<Integer> ipqs = new InPlaceQuickSort<>();
    assertAll(
      () -> ipqs.quicksort(LS1),
      () -> assertEquals(List.of(1, 2, 3, 4, 5), LS1),
      () -> ipqs.quicksort(LS2),
      () -> assertEquals(List.of(), LS2),
      () -> ipqs.quicksort(LS3),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), LS3)
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[IQuickSort.java]{Quick Sort Generic Interface}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;

interface IQuickSort<V extends Comparable<V>> {
  AbstractList<V> quicksort(AbstractList<V> ls);
}
\end{lstlisting}
\end{cl}

% talk about the randomized pivot versus the median of the list
\subsubsection*{Functional Quick Sort}
The functional implementation of quick sort is beautiful and elegant. We choose a pivot $p$ at random, then create three sublists $l_<$, $l_>$, $l_=$, where $l_<$ stores all elements less than $p$, where $l_>$ stores all elements greater than $p$, and $l_=$ stores all elements equal to the pivot. Each sublist, excluding $l_=$, is recursively sorted, followed by concatenating the three sublists in order. 

%%%%%%%%%%%%% FUNCTIONAL QUICK SORT %%%%%%%%%%%%% 
\begin{cl}[FunctionalQuickSort.java]{Functional Quick Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.stream.Collectors;

class FunctionalQuickSort<V extends Comparable<V>> implements IQuickSort<V> {

  @Override
  public AbstractList<V> quicksort(AbstractList<V> ls) {
    if (ls.isEmpty()) { return ls; }
    else {
      // Choose a random pivot.
      V pivot = ls.get((int) (Math.random() * ls.size()));

      // Sort the left-half.
      AbstractList<V> leftHalf = (AbstractList<V>) ls.stream()
                                                     .filter(x -> x.compareTo(pivot) < 0)
                                                     .collect(Collectors.toList());
      AbstractList<V> leftSorted = quicksort(leftHalf);

      // Sort the right-half.
      AbstractList<V> rightHalf = (AbstractList<V>) ls.stream()
                                                      .filter(x -> x.compareTo(pivot) > 0)
                                                      .collect(Collectors.toList());
      AbstractList<V> rightSorted = quicksort(rightHalf);

      // Get all elements equal to the pivot.
      AbstractList<V> equal = (AbstractList<V>) ls.stream()
                                                  .filter(x -> x.compareTo(pivot) == 0)
                                                  .collect(Collectors.toList());

      // Merge the three.
      leftSorted.addAll(equal);
      leftSorted.addAll(rightSorted);
      return leftSorted;
    }
  }
}
\end{lstlisting}
\end{cl}

%%%%%%%%%%%%% IN PLACE QUICK SORT %%%%%%%%%%%%% 
\subsubsection*{In-place Quick Sort}
\begin{cl}[InPlaceQuickSort.java]{In-place Quick Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.Collections;
import java.util.Random;

class InPlaceQuickSort<V extends Comparable<V>> implements IQuickSort<V> {

  @Override
  public AbstractList<V> quicksort(AbstractList<V> ls) {
    this.quicksortHelper(ls, 0, ls.size() - 1);
    return ls;
  }

  /**
   * Recursive helper method for quicksort.
   * 
   * @param ls the List to sort.
   * @param low the lower bound of the partition.
   * @param high the upper bound of the partition.
   */
  private void quicksortHelper(AbstractList<V> ls, int low, int high) {
    if (low < high) {
      int pivot = quicksortPartition(ls, low, high);
      quicksortHelper(ls, low, pivot - 1);
      quicksortHelper(ls, pivot + 1, high);
    }
  }

  /**
   * Creates a quicksort partition, where all elements less than the pivot are
   * to the left of the pivot, and all elements greater than the pivot are to its right.
   * 
   * @param ls the List to partition.
   * @param low the lower bound of the partition.
   * @param high the upper bound of the partition.
   * @return the index of the pivot.
   */
  private int quicksortPartition(AbstractList<V> ls, int low, int high) {
    int rand = new Random().nextInt(high - low + 1) + low;
    Collections.swap(ls, rand, high);
    V pivot = ls.get(high);
    int prevLowest = low;
    for (int i = low; i <= high; i++) {
      if (ls.get(i).compareTo(pivot) < 0) {
        Collections.swap(ls, i, prevLowest++);
      }
    }
    Collections.swap(ls, prevLowest, high);
    return prevLowest;
  }
}
\end{lstlisting}
\end{cl}

% \subsubsection*{Randomized Quick Sort Asymptotic Analysis}

% \subsection*{Lower-Bound for Comparison-Based Sorting Algorithms}
