\section{Sorting}
In this section we will begin our discussion on the analysis and implementation of sorting algorithms. Each algorithm contains two variants: a functional and in-place variant. The functional variant will return a new list that is sorted, while the in-place variant will sort the list in-place. The functional variant is, in principle, easier to implement, but the in-place variant is more efficient in terms of memory usage. Moreover, all lists that are parameters to the sorting algorithms are assumed to be constant-access lists. Accordingly we specify that the input list extends \ttt{AbstractList} class, which guarantees our presumption.
\subsection{Insertion Sort}
\subsubsection*{Functional Insertion Sort}
\subsubsection*{In-place Insertion Sort}

\subsection{Selection Sort}
\subsubsection*{Functional Selection Sort}
\begin{cl}[FunctionalSelectionSortTester.java]{Functional Selection Sort Tester}
\begin{lstlisting}[language=MyJava]

\end{lstlisting}
\end{cl}
\begin{cl}[FunctionalSelectionSort.java]{Functional Selection Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Collections;
import java.util.stream.IntStream;

class FunctionalSelectionSort<V extends Comparable<V>> implements ISelectionSort<V> {

  /**
   * Sorts a give list, using selection sort, in ascending order. 
   *
   * @param ls the list to sort.
   * @return a new list that is sorted in ascending order.
   */
  @Override
  public AbstractList<V> selectionSort(AbstractList<V> ls) {
    if (ls.isEmpty() || ls.size() == 1) { return ls; }
    else {
      // Remember that min returns an Optional, but we know it is non-empty.
      int minIdx = IntStream.range(0, ls.size())
                            .boxed()
                            .min((i1, i2) -> ls.get(i1).compareTo(ls.get(i2)))
                            .get();

      // Swap the minimum element with the first element.
      Collections.swap(ls, 0, minIdx);

      // Sort the rest of the list (excluding the first element).
      AbstractList<V> sortedRest = selectionSort(new ArrayList<>(ls.subList(1, ls.size())));

      // Construct the final sorted list.
      AbstractList<V> sortedList = new ArrayList<>();
      sortedList.add(ls.get(0));
      sortedList.addAll(sortedRest);
      return sortedList;
    }
  }
}
\end{lstlisting}
\end{cl}
\subsubsection*{In-place Selection Sort}

\subsection{Bubble Sort}
\subsubsection*{Functional Bubble Sort}
\subsubsection*{In-place Bubble Sort}

\subsection{Merge Sort}
\subsubsection*{Functional Merge Sort}
\subsubsection*{In-place Merge Sort}

\subsection{Quick Sort}
% talk about the randomized pivot versus the median of the list
\subsubsection*{Functional Quick Sort}
The functional implementation of quick sort is beautiful and elegant. We choose a pivot $p$ at random, then create three sublists $l_<$, $l_>$, $l_=$, where $l_<$ stores all elements less than $p$, where $l_>$ stores all elements greater than $p$, and $l_=$ stores all elements equal to the pivot. Each sublist, excluding $l_=$, is recursively sorted, followed by concatenating the three sublists in order. 
\begin{cl}[FunctionalQuickSortTester.java]{Functional Quick Sort Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;
import static FunctionalQuickSort.funcQuickSort;

class FunctionalQuickSortTester {
  private final List<Integer> LS1 = new ArrayList<>(List.of(5, 4, 2, 1, 3));
  private final List<Integer> LS2 = new ArrayList<>(List.of());
  private final List<Integer> LS3 = new ArrayList<>(List.of(10, 8, 6, 7, 2, 10, 3, 3, 3, 10));

  void fqsTester() {
    assertAll(
      () -> assertEquals(List.of(1, 2, 3, 4, 5), funcQuickSort(LS1)),
      () -> assertEquals(List.of(), funcQuickSort(LS2)),
      () -> assertEquals(List.of(2, 3, 3, 3, 6, 7, 8, 10, 10, 10), funcQuickSort(LS3))
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[FunctionalQuickSort.java]{Functional Quick Sort Implementation}
\begin{lstlisting}[language=MyJava]
class FunctionalQuickSort {

  /**
   * Sorts a given List, whose elements are comparable, in ascending order.
   *
   * @param ls the List to sort whose elements are comparable.
   * @return a new List that is sorted in ascending order.
   */
  static <T extends AbstractList<V extends Comparable<V>>> T quicksort(T<V> ls) {
    if (ls.isEmpty()) { return ls; }
    else {
      // Choose a random pivot.
      T pivot = ls.get((int) (Math.random() * ls.size()));
      
      // Sort the left-half.
      List<T> leftHalf = ls.stream()
                           .filter(x -> x.compareTo(pivot) < 0)
                           .collect(Collectors.toList());
      List<T> leftSorted = quicksort(leftHalf); 

      // Sort the right-half.
      List<T> rightHalf = ls.stream()
                            .filter(x -> x.compareTo(pivot) > 0)
                            .collect(Collectors.toList());
      List<T> rightSorted = quicksort(rightHalf);

      // Get all elements equal to the pivot.
      List<T> equal = ls.stream()
                        .filter(x -> x.compareTo(pivot) == 0)
                        .collect(Collectors.toList());

      // Merge the three.
      return leftSorted.addAll(equal.addAll(rightSorted));
    }
  }
}
\end{lstlisting}
\end{cl}
\subsubsection*{In-place Quick Sort}
\begin{cl}[InPlaceQuickSortTester.java]{In-place Quick Sort Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

\end{lstlisting}
\end{cl}

\begin{cl}[InPlaceQuickSort.java]{In-place Quick Sort Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.AbstractList;
import java.util.Collections;
import java.util.Random;


class InPlaceQuickSort<V extends Comparable<V>> implements IQuickSort<V> {

  /**
    * Sorts a given List, whose elements are comparable, in ascending order.
    *
    * @param ls the List to sort.
    * @param <V extends Comparable<V>> the type of the elements in the List.
    * @return the original, but now sorted, list.
    */
  @Override
  public AbstractList<V> quicksort(AbstractList<V> ls) {
    this.quicksortHelper(ls, 0, ls.size() - 1);
    return ls;
  }

  /**
    * Recursive helper method for quicksort.
    * 
    * @param ls the List to sort.
    * @param low the lower bound of the partition.
    * @param high the upper bound of the partition.
    */
  private void quicksortHelper(AbstractList<V> ls, int low, int high) {
    if (low < high) {
      int pivot = quicksortPartition(ls, low, high);
      quicksortHelper(ls, low, pivot - 1);
      quicksortHelper(ls, pivot + 1, high);
    }
  }

  /**
    * Creates a quicksort partition, where all elements less than the pivot are
    * to the left of the pivot, and all elements greater than the pivot are to its right.
    * 
    * @param ls the List to partition.
    * @param low the lower bound of the partition.
    * @param high the upper bound of the partition.
    * @return the index of the pivot.
    */
  private int quicksortPartition(AbstractList<V> ls, int low, int high) {
    int rand = new Random().nextInt(high - low + 1) + low;
    Collections.swap(ls, rand, high);
    V pivot = ls.get(high);
    int prevLowest = low;
    for (int i = low; i <= high; i++) {
      if (ls.get(i).compareTo(pivot) < 0) {
        Collections.swap(ls, i, prevLowest++);
      }
    }
    Collections.swap(ls, prevLowest, high);
    return prevLowest;
  }
}
\end{lstlisting}
\end{cl}