\section*{Chapter Exercises}
\addcontentsline{toc}{section}{Exercises}

\exercise{1}{chapter-classes}{Design the \ttt{Car} class, which stores a \ttt{String} representing the car's make, a \ttt{String} representing the car's model, and an \ttt{int} representing the car's year. Its constructor should receive these three values and store them in the instance variables. Be sure to write instance accessor and mutator methods for modifying all three fields. That is, you should write \ttt{getMake()}, \ttt{setMake(String s)}, and so forth, to access and modify the fields directly.}

\exercise{1}{chapter-classes}{Design the \ttt{Dog} class, which stores a \ttt{String} representing the breed, a \ttt{String} representing its name, and an \ttt{int} representing its age in years. You should also store a boolean to keep track of whether or not the dog is a puppy. A dog is a puppy if it is less than two years old. Its constructor should receive these three values and store them in the instance variables. Be sure to write instance accessor and mutator methods for modifying all three fields. That is, you should write \ttt{getBreed()}, \ttt{setBreed(String s)}, and so forth, to access and modify the fields directly.}

\exercise{1}{chapter-classes}{Design the \ttt{Person} class, which stores a \ttt{String} representing the person's first name, a \ttt{String} representing the person's last name, and an \ttt{int} representing the person's age in years. Its constructor should receive these three values and store them in the instance variables. Be sure to write instance accessor and mutator methods for modifying all three fields. That is, you should write \ttt{getFirstName()}, \ttt{setFirstName(String s)}, and so forth, to access and modify the fields directly.}

\exercise{1}{chapter-classes}{Design the \ttt{Employee} class, which stores the employee's first and last names as strings, their birthyear as an integer, their yearly salary as a double (we will assume that all employees are paid some value greater than zero), and their employee ID as a string. To make things interesting, assume that an employee's ID is not alterable and must be set in the constructor. The employee ID is constructed using the first five characters of their last name, the first letter of their first name, and the last two digits of their birthyear. For instance, if the employee's name is \ttt{Joshua Crotts} and their birthyear is \ttt{1999}, their employee ID is \ttt{CrottJ99}. Its constructor should receive the name, birthyear, and salary as parameters, but build the employee ID from the name and birthyear. Be sure to design the relevant accessor and mutator methods.}

\exercise{1}{chapter-classes}{As part of the \ttt{Employee} class, design the \ttt{void bonus()} method, which updates the salary of an employee. Calling \ttt{bonus} on an employee increases their salary by ten percent.}

\exercise{2}{chapter-classes}{As part of the \ttt{Employee} class, override the \ttt{equals} and \ttt{toString} methods from the \ttt{Object} class to compare two employees by their employee ID and to print the employee's name, birthyear, salary, and employee ID respectively separated by commas.}

\exercise{2}{chapter-classes}{In this exercise you will design a class for storing employees. This relies on completing the \ttt{Employee} class exercise.}
\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{Job} class, which stores a list of employees \ttt{ArrayList<Employee>} as an instance variable. Its constructor should receive no arguments.
    \item Design the \ttt{void addEmployee(Employee e)} method, which adds an employee to the \ttt{Job}.
    \item Design the \ttt{void removeEmployee(Employee e)} method, which removes an employee from the \ttt{Job}.
    \item Design the \ttt{Optional<Double> computeAverageSalary()} method, which returns the average salary of all employees in the \ttt{Job}. If there are no employees, return an empty \ttt{Optional}.
    \item Design the \ttt{Optional<Employee> highestPaid()} method, which returns the \ttt{Employee} whose salary is the highest of all employees in the \ttt{Job}. If there are no employees, return an empty \ttt{Optional}.
    \item Override the \ttt{toString} method to print out the list of employees in the \ttt{Job}. You can use the default \ttt{toString} implementation of the \ttt{ArrayList} class.
\end{enumerate}

\exercise{2}{chapter-classes}{In this exercise you will design a \textit{linear congruential generator}: a pseudorandom number generation algorithm. In particular, the C programming language standard library defines two functions: \ttt{rand} and \ttt{srand}. The latter sets the \textit{seed} for the generator, and \ttt{rand} returns a random integer between $[0, 2^{15})$. The formula for this generator is a recurrence relation:}
\begin{align*}
    \textit{next} &= |r_n \cdot 1103515245 + 12345|\\
    r_{n+1} &= \left(\dfrac{\textit{next}}{2^{16}}\right)\;\%\;2^{15};
\end{align*}

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{LcgRandom} class, which implements this behavior. In particular, it should have two constructors: one that receives a seed value $s$, and another that sets the seed to one. The seed initializes the value of $r_0$.
    \item Design the \ttt{genInt} method, which returns a random integer between $0$ and $2^{15}$ using this algorithm.
    \item Design the \ttt{IntStream stream()} method, which returns a stream of random numbers that uses \ttt{genInt} to generate numbers. Hint: use \ttt{generate}!
    \item Design the \ttt{genInt(int b)} method that returns an integer between $[0, b]$. Note that $0 \leq b < 2^{15}$; you do not need to account for values outside of this range. Do \textbf{not} simply loop until you find a value between that range; instead, use modulus to your advantage.
\end{enumerate}

\exercise{3}{chapter-classes}{This question has six parts.}

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{Matrix} class, which stores a two-dimensional array of integers. Its constructor should receive two integers $m$ and $n$ representing the number of rows and columns respectively, as well as a two-dimensional array of integers. Copy the integers from the passed array into an instance variable array.
    \item Design the \ttt{void set(int i, int j, int val)} method, which sets the value at row $i$ and column $j$ to \ttt{val}.
    \item Design the \ttt{void add(Matrix m)} method, which adds the values of the passed matrix to the current matrix. If the dimensions of the passed matrix do not match the dimensions of the current matrix, do nothing.
    \item Design the \ttt{void multiply(Matrix m)} method, which multiplies the values of the passed matrix to the current matrix. If we cannot multiply $m$ with this matrix, do nothing.
    \item Design the \ttt{void transpose()} method, which transposes the matrix. That is, the rows become the columns and the columns become the rows. You may need to alter the dimensions of the matrix.
    \item Design the \ttt{void rotate()} method, rotates the matrix $90$ degrees clockwise. To rotate a matrix, compute the transposition and then reverse the rows. You may need to alter the dimensions of the matrix.
    \item Override the \ttt{toString} method to print out the matrix in a boxed format.
\end{enumerate}

\exercise{2}{chapter-classes}{This exercise has five parts.}
\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{GameObject} class, which stores a \ttt{Pair<Double, Double>} denoting its center $(x, y)$ position and a \ttt{Pair<Double, Double>} denoting its width and height respectively. Its constructor should receive four \ttt{double} values representing $x$, $y$, $\textit{width}$, and $\textit{height}$. Be sure to write instance accessor and mutator methods for modifying both fields. That is, you should write \ttt{getLocationX()}, \ttt{setLocationX(double d)}, and so forth, to access and modify the \ttt{Pair} values directly. 

    \item Design the \ttt{public boolean collidesWith(GameObject obj)} method that returns if \ttt{this} \ttt{GameObject} collides with the parameter \ttt{obj}. You should design this solution as if the game objects are shaped like rectangles (which they are!).

    \item Design the \ttt{public double distance(GameObject obj)} method that returns the Euclidean distance from the center of \ttt{this} \ttt{GameObject} to the center of the parameter \ttt{obj}. 

    \item Design the \ttt{public double move(double dx, double dy)} method that moves the object about the Cartesian (two-dimensional) plane. The distance should be a delta represented as two \ttt{double} numbers \ttt{dx} and \ttt{dy} that directly manipulate the object position. For instance, if \ttt{dx} is $3.0$ and \ttt{dy} is $-2.0$ and the object is currently at $<2.0, -9.0>$, invoking \ttt{move(3.0, -2.0)} updates the object to be at $<5.0, -11.0>$.

    \item Override the \ttt{toString} method to call the \ttt{toString} methods of the two instance variables, conjoined by a semicolon.
\end{enumerate}

\exercise{2}{chapter-classes}{This exercise has three parts.}
\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{GameRunner} class, which stores a list of objects \ttt{ArrayList<GameObject>} as an instance variable. Its constructor should receive an integer representing a random number generator seed. It should first instantiate \ttt{rand} to a new \ttt{Random} object with this seed, and then populate the list with twenty random \ttt{GameObject} instances at random \textbf{integer} positions with random \textbf{integer} sizes. These random positions should be between $[-10, 10]$ for both coordinates and the random sizes should be between $[1, 10]$ for both dimensions.

    \item Design the \ttt{moveObjects} method, which moves each object by three positive $x$ units and four negative $y$ units.

    \item Design the \ttt{stringifyObjects} method, which converts each object in the list into its string representation, with brackets around the elements, and separated by commas. Hint: you can use one method from the \ttt{Stream} class to do this quickly!
\end{enumerate}

\exercise{2}{chapter-classes}{This exercise involves the ``Twenty-One'' game implementation from the chapter.}
\begin{enumerate}[label=(\alph*)]
    \item Change each card to use the Unicode symbol counterpart rather than the default \ttt{"X of Y"} \ttt{toString} model, where \ttt{X} is the value and \ttt{Y} is the suit. The Unicode symbols are available on the second page of this PDF: \url{https://www.unicode.org/charts/PDF/U1F0A0.pdf}. This will be a little tedious, but it makes the game look cooler!
    \item Add the Ace, Jack, Queen, and King cards, instead of the previous implementation of using four cards whose values were all ten. A simple solution is to use a \ttt{String} that keeps track of the ``name'' of a card alongside the other instance variables. 
    \item Add an AI to the game (you do not need to test this class). This involves writing the \ttt{AI} class and designing the \ttt{boolean play(Deck deck)} method. An \ttt{AI} has a \ttt{ArrayList<Card>}, similar to \ttt{Player}, but makes decisions autonomously using the following algorithm:
    {\footnotesize
\begin{verbatim}
boolean play(Deck d) {
  score = getScore()
  if score < 16 then:
    cards.add(d.drawCard())
    return true;
  else if (score > 16 && score < 21) {
    k = Generate a random integer between [0, 3).
    if k is zero then:
      cards.add(d.drawCard())
      return true;
  } 
  return false;
}
\end{verbatim}
\par}
The method returns whether or not the AI drew a card. If they did not draw a card, then their turn is over. When playing the game, the player can see the first two cards dealt to an AI, but nothing more. You might want to add a static variable to the \ttt{Card} class representing the ``covered card''. Note that the AI knows only the context of its deck of cards; it is not aware of any other \ttt{Player} or \ttt{AI}.
\item After designing the \ttt{AI} class and adding one to your game, create an \ttt{ArrayList<AI>} simulating multiple computer players in the game.
\end{enumerate}

\exercise{1}{chapter-classes}{Add the \ttt{public void set(T e, int idx)} method to the \ttt{MiniArrayList} class, which sets the element at $\textit{idx}$ to the given $e$ element.}

\exercise{1}{chapter-classes}{Add the \ttt{public void isEmpty()} method to the \ttt{MiniArrayList} class, which returns whether or not the list is empty.}

\exercise{2}{chapter-classes}{Add the \ttt{public void clear()} method to the \ttt{MiniArrayList} class, which ``removes'' all elements from the list. This should not change the capacity of the list. Note that there's a reason why ``removes'' is in quotes. We rank this exercise as a two-star not because of its length, but because it is a little tricky.}

\exercise{2}{chapter-classes}{Override the \ttt{equals} method (from \ttt{Object}) in the \ttt{MiniArrayList} class to compare two lists by their elements. Return \ttt{true} if all elements in the two lists are \ttt{.equals} to one another, and \ttt{false} otherwise.}

