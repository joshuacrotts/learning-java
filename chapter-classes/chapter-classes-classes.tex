\section{Classes}
From the first page, we have made prolific use of classes, but in this section we will finally venture into the inner workings of a class, and how to create our own.

\textit{Classes}\index{classes} are blueprints for \textit{objects}. When we create a class, we declare a new type of object. As we stated, we have repeatedly used classes, e.g., strings, arrays, \ttt{Scanner}, \ttt{Random}, as well as those classes from the Collections API. Until now, however, we viewed these as forms of abstraction, whose details were not important. 

To create a class, we use the \ttt{class} keyword, followed by the name of the class. The name of the class should be capitalized, and should, in general, describe a noun. All Java files describe a class and must be named accordingly. We, of course, have seen this repeatedly before, but we omitted the details.

Classes can \textit{inherit} methods from other classes, a relationship called the superclass/subclass hierarchy. For now we will only mention that the \ttt{Object} class is the ``ultimate'' superclass, in which all classes are implicit subclasses. The \ttt{Object} class, in particular, has two methods that we will override in almost every class that we write: \ttt{equals}, for comparing two classes for equality, and \ttt{toString}, a means of ``stringifying'' an object. In subsequent chapters we will dive more into inheritance and hierarchies.

\example{Let's create a class called \ttt{Point}, which stores two \ttt{int} values representing a Cartesian coordinate $x$ and $y$. By ``store'', we mean to say that $x$ and $y$ are \textit{instance variables}\index{instance variables} of the \ttt{Point} class, also sometimes called \textit{attributes} or \textit{fields}. Instance variables denote the values associated with an arbitrary \textit{instance} of that object (an instance may also be defined as an entity). For example, if we have a \ttt{Point} object \ttt{p}, then \ttt{p} has two instance variables, \ttt{x} and \ttt{y}, which are the $x$ and $y$ coordinates of \ttt{p}. Then, if we declare another point \ttt{p2}, \ttt{p2} will have its own instance variables \ttt{x} and \ttt{y}, which are independent of \ttt{p}'s instance variables. In almost all circumstances, instance variables of a class should be marked as \ttt{private}. Instance variables that are \ttt{private} denotes that direct access to their values is granted only within the class definition. Lastly, for the time being, instance variables are immutable and cannot change. Thus, every instance variable will use the \ttt{final} keyword in its declaration, alongside the \ttt{UPPER\_CASE} naming convention.}

Speaking of \textit{access modifiers}, we should mention the four that Java provides, even though we make prolific use of only three:

\begin{itemize}
  \item A class, variable, or method declared with the \ttt{public} modifier is accessible to/by any other class. Variables that are \ttt{public} should be used sparingly.
  \item A class, variable, or method declared with the \ttt{private} modifier is accessible only to/by the class in which it is declared. 
  \item A class, variable, or method declared without an access modifier, also called the \textit{default access modifier}, behaves similarly to \ttt{public}, only that it is accessible only to/by classes in the same package. Packages are a means of organizing classes into groups, similar to directories.
\end{itemize}

The fourth and final access modifier is \ttt{protected}, which is similar to the default access modifier, but allows subclasses to access the variable or method.\footnote{If you have not heard of inheritance/subclasses yet, do not worry, as we will cover this in the next chapter; we explain it here to describe the relevant difference between the access modifiers.} We will not use \ttt{protected} in this text, but it is worth mentioning.

\begin{cl}[Point.java]{\ttt{Point} Class Skeleton}
\begin{lstlisting}[language=MyJava]
class Point {

  private final int X;
  private final int Y;
}
\end{lstlisting}
\end{cl}

We now want a way to create an instance of a \ttt{Point}. We declare instances of objects using the \ttt{new} keyword followed by the class constructor. \textit{Constructors} are special methods that are called when we wish to create a new object of that class. Our \ttt{Point} class constructor can receive parameters, which we can use to initialize the relevant $x$ and $y$ instance variables. So, let's declare the constructor for our \ttt{Point} class. Constructors, in general, should be \ttt{public}, as we will need to call them from outside the class definition. Constructors are also special in that they do not have a return type.\footnote{It is a bit of a misnomer to say that constructors do not have a return type. Indeed, they do have a return type, but it is the type of the class itself.} We create a constructor by specifying the class name alongside any desired parameters.

\begin{cl}[Point.java]{\ttt{Point} Class Constructor}
\begin{lstlisting}[language=MyJava]
class Point {
  
  private final int X;
  private final int Y;
  
  public Point(int x, int y) {
    this.X = x;
    this.Y = y;
  }
}
\end{lstlisting}
\end{cl}
Remember that the purpose of the constructor is to initialize the class instance variables. So, unless we wish to use distinct identifiers for referencing the parameters and instance variables, we need to use the \ttt{this} keyword.\footnote{Some software engineers and projects use identifier prefixes to refer to instance variables.} The \ttt{this} keyword refers to the current object, and aids in distinguishing between instance variables and parameters. In this case, we are assigning the value of the parameter \ttt{x} to the instance variable \ttt{x}.\footnote{Should we opt to not use \ttt{this}, then the parameter \ttt{x} would shadow the instance variable \ttt{x}, meaning that writing \ttt{x = x} would assign the parameter to itself!}. At last, we can create a \ttt{Point} object by calling the constructor. But wait, we have no way of accessing the instance variables of the \ttt{Point} object! We need to create \textit{accessor methods}\index{accessor methods} to retrieve the values of the instance variables. Accessor methods are \ttt{public} methods that return the value of an instance variable. 

\begin{cl}[Point.java]{Designing Accessor Methods}
\begin{lstlisting}[language=MyJava]
public Point {

  private final int X;
  private final int Y;
  
  public Point(int x, int y) {
    this.X = x;
    this.Y = y;
  }
  
  public int getX() { return this.X; }
  
  public int getY() { return this.Y; }
}
\end{lstlisting}
\end{cl}

This principle of hiding the implementation details of a class is called \textit{encapsulation}\index{encapsulation}. Encapsulation is a key principle of object-oriented programming, and is one of the primary reasons why object-oriented programming is so powerful. It can be dangerous to directly modify or access the fields of an object.\footnote{By ``dangerous'', we mean to suggest that it is prone to logic errors.} 

Creating an instance of the \ttt{Point} class is identical to creating an instance of any other arbitrary class. Though, we should first explain a slight terminology distinction.

Declaring, or initializing, an object refers to typing the class name followed by the variable name. For instance, the following code declares a \ttt{Point} object \ttt{p}.

\begin{footnotesize}
\begin{verbatim}
Point p;
\end{verbatim}
\end{footnotesize}

By default, $p$ now points to \ttt{null}, since we have not yet created an instance of the \ttt{Point} class. We can create an instance of the \ttt{Point} class by invoking its constructor, an action otherwise called \textit{object instantiation}. We use the \ttt{new} keyword and pass the desired $x$ and $y$ coordinates. 

\begin{footnotesize}
\begin{verbatim}
Point p = new Point(3, 4);
\end{verbatim}
\end{footnotesize}

We should write some tests to ensure that our \ttt{Point} class is working as expected. We note that this may seem redundant for such a simple class and the fact that the accessor methods do nothing more than retrieve instance variable values, but it is a good habit for beginning object-oriented programmers.

\begin{cl}[PointTester.java]{Testing Accessor Methods}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {
  
  @Test
  void testPoint() {
    Point p = new Point(3, 4);
    assertEquals(3, p.getX());
    assertEquals(4, p.getY());
  }
}
\end{lstlisting}
\end{cl}

Of course, testing the accessor methods is a little boring, so let's override the \ttt{toString} method to print a stringified representation of the \ttt{Point} class. Every object in Java has a \ttt{toString} method, which returns a string representation of the object. By default, the \ttt{toString} method returns the class name followed by the object's hash code. We can override the \ttt{toString} method by declaring a \ttt{public} method with the signature \ttt{public String toString()}. We can then return a string representation of the object. In this case, we will return a string of the form \ttt{"(x=$x$, y=$y$)"}, where $x$ and $y$ refer to the respecitve instance variables.

\begin{cl}[]{Overriding the \ttt{toString} Method}
\begin{lstlisting}[language=MyJava]
class Point {
  // ... previous code not shown.

  @Override
  public String toString() {
    return String.format("(x=%d, y=%d)", this.X, this.Y);
  }
}
\end{lstlisting}
\end{cl}

Testing the \ttt{toString} method provides more interesting results, since it requires us to not only override the default implementation of \ttt{toString}, but it also ensures that our constructor correctly initializes the instance variables. Because we will refer to $p$ across several methods, we can declare it as an instance variable of our \ttt{PointTester} class so as to reduce the redundant object instantiation.

\begin{cl}[]{}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {

  private final Point P = new Point(3, 4);

  @Test
  void testPointAccessors() {
    assertEquals(3, P.getX());
    assertEquals(4, P.getY());
  }

  @Test
  void testPointToString() {
    assertEquals("(x=3, y=4)", P.toString());
  }
}
\end{lstlisting}
\end{cl}

In addition to the \ttt{toString} method, we might also write other methods associated with a \ttt{Point} object. For example, we might want to calculate the distance between two points. We can write a \ttt{public} method that takes a \ttt{Point} object as a parameter and returns the distance between the two points, the first being the \textit{implicit parameter}, and the second being the \textit{explicit parameter}. We say the first is \textit{implicit} because, under the hood, all class methods take an implicit parameter, which is the object on which the method is called, which is accessible through \ttt{this}. We say the second is \textit{explicit} because we explicitly pass the object as a parameter. 

This is also a good time to bring up another terminology distinction. Some programming languages use \textit{functions}, others use \textit{procedures}, \textit{subroutines}, or \textit{methods}. Going from simplest to most complex, subroutines are simply a sequence of instructions that are executed in order. Procedures are subroutines that return a value. Functions are procedures that take parameters. Methods are functions that are associated with a class. In Java, we use the term \textit{method} to refer to all of these, since all methods must be associated with a class. A language like C++, on the other hand, uses the term \textit{function} to refer to methods that are not associated with a class, and \textit{method} to refer to methods that are associated with a class.

Returning to the \ttt{Point} class, we will now write \ttt{distance}, which receives a \ttt{Point} as a parameter and returns the Euclidean distance from \ttt{this} to the parameter. Before doing so, however, we should write a few tests. Conveniently, the three points that we test all have a distance of five between each other.

\begin{cl}[PointTester.java]{Testing the \ttt{distance} Method}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {

  private static final double DELTA = 0.01;

  private final Point P1 = new Point(3, 4);
  private final Point P2 = new Point(6, 8);
  private final Point P3 = new Point(0, 0);

  @Test
  void testPointDistance() {
    assertAll(
      () -> assertEquals(5, P1.distance(P2), DELTA),
      () -> assertEquals(5, p2.distance(P1), DELTA),
      () -> assertEquals(5, P1.distance(P3), DELTA),
      () -> assertEquals(5, P3.distance(P1), DELTA),
      () -> assertEquals(5, P2.distance(P3), DELTA),
      () -> assertEquals(5, P3.distance(P2), DELTA)
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Point.java]{Distance Between Two Points}
\begin{lstlisting}[language=MyJava]
class Point {
  // ... previous code not shown.

  /**
   * Determines the Euclidean distance between two points.
   * 
   * @param p the other point.
   * @return the distance between this point and p.
   */
  public double distance(Point p) {
    int dx = this.X - p.Y;
    int dy = this.Y - p.Y;
    return Math.sqrt(dx * dx + dy * dy);
  }
}
\end{lstlisting}
\end{cl}

The \ttt{distance} method is called an \textit{instance method} because it is associated with an instance of the class. We can also write \textit{static methods}, which are not associated with an object, but rather the class as a whole. Static methods are declared using the \ttt{static} keyword. Static methods are useful for utility methods that are not associated with a particular instance of the class. All methods designed up until this chapter were static methods, which were not associated with the class in which they resided.

\subsubsection*{Method Overloading}
A method is identified by two attributes: its name, and its signature. Java allows us to \textit{overload}\index{method overloading} a method or constructor by using the same identifier but different parameters.

\example{Let's overload the \ttt{distance} method by writing a version that does not receive a parameter at all, and instead returns the magnitude/distance from the point to the origin. Fortunately this is extremely easy, because we can make use of the existing \ttt{distance} method that does receive a \ttt{Point}; we can pass it the origin point, namely \ttt{new Point(0, 0)}, and everything works out wonderfully! Because this version of \ttt{distance} simply refers to the existing definition, which we have thoroughly tested, we will omit a separate tester.}

\begin{cl}[Point.java]{Distance Method Overloading}
\begin{lstlisting}[language=MyJava]
class Point {
  // Previous code not shown.
  
  /**
   * Computes the distance from this point to the origin,
   * i.e., (0, 0).
   *
   * @return returns the magnitude of this distance.
   */
   public double distance() {
     return this.distance(new Point(0, 0));
   }
}
\end{lstlisting}
\end{cl} 

We could, if desired, overload the \ttt{Point} constructor as well. Though, it makes little sense to do so in this specific instance, since a point is defined by its two coordinate members. In subsequent sections, however, we will overload the constructor and demonstrate its utility/practicality.

\example{Let's create the static method \ttt{random}, which returns a random \ttt{Point} object. We will use the \ttt{Random} class to generate a random radius and angle as a polar coordinate. Then, we will convert the polar coordinate to Cartesian coordinates. Let's also add a parameter that specifies the maximum radius.}

Because the \ttt{random} method generates a random point, we cannot reasonably write a test that asserts the exact location of the point without prior knowledge of the random seed. Instead, we can write a test that asserts that the point is within a certain radius of the origin. 

\begin{cl}[PointTester.java]{Testing the \ttt{random} Method}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {

  private static final double DELTA = 0.01;

  @Test
  void testPointRandom() {
    assertTrue(Point.random(10).distance() <= 10);
    assertTrue(Point.random(1).distance() <= 1);
    assertTrue(Point.random(5).distance() <= 5);
    assertTrue(Point.random(5000000).distance() <= 5000000);
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Point.java]{Random Point Generation Method}
\begin{lstlisting}[language=MyJava]
import java.util.Random;

class Point {
  // ... previous code not shown.

  /**
   * Generates a random point with a maximum radius.
   *
   * @param maxRadius the maximum radius.
   * @return a random point.
   */
  public static Point random(double maxRadius) {
    Random r = new Random();
    double radius = r.nextDouble(maxRadius);
    double angle = r.nextDouble() * Math.PI * 2;
    int x = (int) (radius * Math.cos(angle));
    int y = (int) (radius * Math.sin(angle));
    return new Point(x, y);
  }
}
\end{lstlisting}
\end{cl}

We have seen static methods, but what about static variables? A static variable, as we mentioned before, is a variable that is associated with the class and not a specific instance thereof. We can declare a static variable using the \ttt{static} keyword. Static variables are useful for storing information that is shared across all instances of the class. Static variables may be either \ttt{private} or \ttt{public}, depending on whether we want to allow direct access to the variable. As with instance variables, however, be wary of granting direct access, since it may lead to logic errors.

\example{Suppose we want to keep track of how many instances of \ttt{Point} have been instantiated. Since this is a property of the \ttt{Point} class rather than an instance of the class, we can declare a static variable \ttt{count} to keep track of the number of instances, which is incremented inside the constructor. To remain consistent with our recurring theme of encapsulation, \ttt{count} will be declared as \ttt{private}, and we will write a static method \ttt{getCount} to retrieve the number of instances, which is invoked on the class.\footnote{It is possible to invoke a static method on an instance of the class, but it is considered bad practice and unnecessary.} When testing, we need to be careful to only instantiate instances of \ttt{Point} when we are ready to check the status of \ttt{count}, since the static \ttt{count} variable is incremented inside the constructor.}

\begin{cl}[PointTester]{Testing the \ttt{count} Static Variable}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {

  @Test
  void testPointCount() {
    assertEquals(0, Point.getCount())
    Point p1 = new Point(3, 4);
    assertEquals(1, Point.getCount());
    Point p2 = new Point(6, 8);
    assertEquals(2, Point.getCount());
    Point p3 = new Point(0, 0);
    assertEquals(3, Point.getCount());
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Point.java]{\ttt{Point} Class with \ttt{count} Static Variable}
\begin{lstlisting}[language=MyJava]
class Point {

  private static int count = 0;

  private final int X;
  private final int Y;

  public Point(int x, int y) { this.X = x; this.Y = y; count++; }

  public static int getCount() { return count; }
}
\end{lstlisting}
\end{cl}

Notice that, inside the \ttt{getCount} method, we do not refer to \ttt{count} with \ttt{this}, since \ttt{count} is a static variable and not an instance variable. Prefixing the \ttt{count} variable with \ttt{this} results in a compiler error.

\example{Let's amplify the complexity a bit by designing a ``21'' card game, which is a card game where the players try to get a card value total of $21$ without going over. We should think about the design process of this game, namely what classes we need to create. It makes sense to start off with a \ttt{Card} class, which stores its suit and its numeric value. Because a suit is one of four possibilities, each of which uses a different symbol, we can create another class called \ttt{Suit}. In \ttt{Suit} we instantiate four static instances of \ttt{Suit}, each of which represents one of the four valid suits. Its constructor is privatized because we, as the programmers, define the four possible suits; it should not be possible for the user to define their own custom suit, at least for this particular game. The notion of \ttt{Suit} being an instance variable of \ttt{Card}, and only exists due to \ttt{Card} is called \textit{object composition}. Lastly, we will provide a method that returns an \ttt{Iterator<Suit>} over the four suit possibilities to make our lives easier when designing the \ttt{Deck} class. The method should be static so it is accessible through the class.}

\begin{cl}[Suit.java]{\ttt{Suit} Class}
\begin{lstlisting}[language=MyJava]
class Suit {

  public static final Suit CLUBS = new Suit("(*;$\clubsuit$;*)");
  public static final Suit DIAMONDS = new Suit("(*;$\diamondsuit$;*)");
  public static final Suit HEARTS = new Suit("(*;$\heartsuit$;*)");
  public static final Suit SPADES = new Suit("(*;$\spadesuit$;*)");
  public static final int NUM_SUITS = 4;

  private final String S_VAL;

  private Suit(String s) { this.S_VAL = s; }

  public static Iterator<Suit> iterator() {
    return new ArrayList<Suit>(List.of(CLUBS, DIAMONDS, HEARTS, SPADES))
                              .iterator();
  }

  @Override
  public String toString() { return this.S_VAL; }
}
\end{lstlisting}
\end{cl}

Testing the \ttt{Card} class is simple and straightforward; we only need to test one method, the \ttt{toString} method, since testing \ttt{getValue}, at this point, is superfluous. We could also test the \ttt{Suit} class, but we will not do so here.

\begin{cl}[CardTest.java]{Testing the \ttt{Card} Class}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class CardTest {

  @Test
  void testCardToString() {
    assertAll(
      () -> assertEquals("2 of (*;$\clubsuit$;*)", new Card(Suit.CLUBS, 2).toString()),
      () -> assertEquals("3 of (*;$\diamondsuit$;*)", new Card(Suit.DIAMONDS, 3).toString()),
      () -> assertEquals("4 of (*;$\heartsuit$;*)", new Card(Suit.HEARTS, 4).toString()),
      () -> assertEquals("5 of (*;$\spadesuit$;*)", new Card(Suit.SPADES, 5).toString())
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Card.java]{\ttt{Card} Class}
\begin{lstlisting}[language=MyJava]
class Card {

  private final Suit SUIT;
  private final int VALUE;

  public Card(Suit suit, int value) { this.SUIT = suit; this.VALUE = value; }
  
  @Override
  public String toString() { 
    return String.format("%d of %s", this.VALUE, this.SUIT); 
  }

  public int getValue() { return this.VALUE; } 
}
\end{lstlisting}
\end{cl}

In a standard fifty-two deck of cards, some are ``special'', e.g., the Jacks, Queens, Kings, and Ace cards. To simplify our design, these cards will be treated the same as a ``ten'' card, showing no syntactic nor semantic difference. Now that we have a class to represents cards, let's design the \ttt{Deck} class, which stores an \ttt{ArrayList<Card>} representing the current state of the deck. It also contains a static variable representing the maximum number of allowed cards. For our purposes, as we alluded to, this quantity is fifty-two. In the \ttt{Deck} constructor, we will call the \ttt{populateDeck} method, which adds four cards of the same value, but of each suit. So, to exemplify, this means that there are four cards whose value is three, where each is one of the four suits. We make use of the iterator from the \ttt{Suit} class to simplify our deck population. Only the \ttt{Deck} class needs to know how to populate an initial (empty) deck, so we privatize its implementation.

To test a \ttt{Deck}, we can write a \ttt{drawCard} method, which retrieves the ``top-most'' card on the deck to see if it is in the correct order. According to our implementation of the iterator, the top-most cards should have values of ten and be of the same suit. From there, we can draw three more cards to ensure they are of values nine, eight, and seven of the same suit. The iterator places \ttt{DIAMOND} as the final suit, so this is what we will assume in our tester. It might also be beneficial to test the \ttt{isEmpty} method, which returns \ttt{true} if the deck is empty, and \ttt{false} otherwise. We can test this functionality by drawing all fifty-two cards from the deck and ensuring that the deck is empty afterwards. 

\begin{cl}[DeckTest.java]{Testing the \ttt{Deck} Class}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class DeckTest {

  @Test
  void testDeckDrawCard() {
    Deck d = new Deck();
    assertAll(
      // We draw four tens because there are no "Kings", "Queens", or "Jacks".
      () -> assertEquals("10 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("10 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("10 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("10 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("9 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("8 of (*;$\diamondsuit$;*)", d.drawCard().toString()),
      () -> assertEquals("7 of (*;$\diamondsuit$;*)", d.drawCard().toString())
    );
  }

  @Test
  void testDeckIsEmpty() {
    Deck d = new Deck();
    for (int i = 0; i < 52; i++) {
      assertFalse(d.isEmpty());
      d.drawCard();
    }
    assertTrue(d.isEmpty());
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Deck.java]{\ttt{Deck} Class}
\begin{lstlisting}[language=MyJava]
import java.util.ArrayList;

class Deck {

  private static final int MAX_NUM_CARDS = 52;

  private final ArrayList<Card> CARDS;

  public Deck() {
    this.CARDS = new ArrayList<Card>();
    this.populateDeck();
  }

  /**
  * Retrieves a card from the "top" of the deck.
  *
  * @return card on top of the deck.
  */
  public Card drawCard() {
    return this.CARDS.isEmpty() ? null : this.CARDS.remove(this.CARDS.size() - 1);
  }

  /**
   * Determines if the deck is empty.
   *
   * @return true if the deck is empty, false otherwise.
   */
  public boolean isEmpty() {
    return this.CARDS.isEmpty();
  }

  /**
   * Instantiates the deck to contain all 52 cards.
   */
  private void populateDeck() {
    // For every suit, create 13 cards, the last four of which all have
    // a value of four.
    Iterator<Suit> it = Suit.iterator();
    while (it.hasNext()) {
      Suit s = it.next();
      for (int i = 1; i <= MAX_NUM_CARDS / Suit.NUM_SUITS; i++) {
        this.CARDS.add(new Card(s, Math.min(10, i)));
      }
    }
  }
}
\end{lstlisting}
\end{cl}

Hopefully the \ttt{populateDeck} method is intuitive and not intimidating. All we do is create fifty two cards, thirteen of which are of the same suit, and add them to the deck. We use the \ttt{Math.min} method to ensure that the value of the card is at most ten, since we do not have ``King'', ``Queen'', or ``Jack'' cards. We also use the ternary operator to check if the deck is empty before drawing a card. If the deck is empty, we return \ttt{null}.

Finally we come to the \ttt{Player} class, which stores a ``hand'' containing the cards in their possession. Fortunately this is a very straightforward definition and contains four one-line methods: \ttt{addCard}, \ttt{clearHand}, \ttt{getScore}, and \ttt{toString}. The former two are trivial to explain, as is \ttt{toString}, whereas \ttt{getScore} is the only slightly convoluted method. The idea is to return an integer that represents the total value of the cards in the player's hand. Since streams were introduced a couple of chapters ago, we will once again use them to our advantage.

\begin{cl}[Player.java]{\ttt{Player} Class}
\begin{lstlisting}[language=MyJava]
import java.util.ArrayList;

class Player {

  private final ArrayList<Card> HAND;

  public Player() { this.HAND = new ArrayList<Card>(); }

  /**
   * Adds a card to the player's hand.
   *
   * @param c card to add to the player's hand.
   */
  public void addCard(Card c) { this.HAND.add(c); }

  /**
   * Removes all cards from the player's hand.
   */
  public void clearHand() { this.HAND.clear(); }

  /**
   * Determines the player's score.
   *
   * @return the player's score.
   */
  public int getScore() {
    return this.HAND.stream().map(c -> c.getValue()).reduce(0, Integer::sum);
  }

  @Override
  public String toString() {
    return String.format("Score: %d\nHand: %s\n", 
                         this.getScore(), this.HAND.toString());
  }
}
\end{lstlisting}
\end{cl}

Using the capabilities of \ttt{Player}, \ttt{Deck}, and \ttt{Card}, we will write \ttt{TwentyOne}: the class that runs a game of ``twenty-one''. The game logic is simple: if the game is still running, clear the player's hand, create a new deck of cards, shuffle them, and give the player two. Then, ask the player if they want to draw another card. If they do, draw a card and add it to their hand. If they do not, then the game is over. If the player's score is greater than twenty-one, then the player loses. Otherwise, the player wins. We will also write a \ttt{main} method that runs the game. We will not write any tests for this class, since it interacts with the user through the \ttt{Scanner} class.

\begin{cl}[TwentyOne.java]{\ttt{TwentyOne} Class}
\begin{lstlisting}[language=MyJava]
import java.util.Scanner;

class TwentyOne {

  private static final int MAX_SCORE = 21;

  private final Player PLAYER;

  public TwentyOne() { this.PLAYER = new Player(); }

  /**
   * Plays a game of "21", where the player has to draw cards until they
   * get as close to 21 as possible without going over.
   */
  public void playGame() {
    Scanner in = new Scanner(System.in);
    boolean continuePlaying = true;
    while (continuePlaying) {
      // Clear the player's hand.
      this.player.clearHand();
      // Create and shuffle the deck.
      Deck d = new Deck();
      d.shuffleDeck();
      // First, deal two cards.
      this.PLAYER.addCard(d.drawCard());
      this.PLAYER.addCard(d.drawCard());
      // While the player has not "busted", ask them to draw a card or stand.
      while (this.PLAYER.getScore() <= this.MAX_SCORE) {
        System.out.println(this.PLAYER);
        System.out.println("Do you want to draw? (Y/n)");
        String resp = in.nextLine();
        if (resp.equals("Y")) { this.PLAYER.addCard(d.drawCard()); }
        else { break; }
      }

      // Print the final results of the player.
      System.out.println(this.PLAYER);
      if (this.PLAYER.getScore() > this.MAX_SCORE) {
        System.out.println("You lose!");
      } else {
        System.out.println("You did not go over!");
      }

      // Determine if we're still playing.
      System.out.println("Do you want to continue playing?");
      String resp = in.nextLine();
      continuePlaying = resp.equals("Y");
    }
  }

  public static void main(String[] args) {
    new TwentyOne().playGame();
  }
}
\end{lstlisting}
\end{cl}

Designing a game caused some strife, but it was a good exercise in object-oriented design.

\example{Let's design the \ttt{Rational} class, which stores a rational number as a numerator and denominator. In doing so we will create methods for adding, subtracting, multiplying, and dividing rational numbers. Testing is paramount with this example, so we will be sure to write plenty. Recall the definition of a rational number: a number that can be expressed as the ratio of two integers $p$ and $q$, namely $p/q$. We are acutely familiar with how to perform basic operations on fractions from grade school, so we will glide through the actual mathematics and focus more on the Java implementation and class design.}

The \ttt{Rational} constructor receives two integers $p$ and $q$, and assigns them as instance variables. The \ttt{toString} method is trivial to write and only involves us adding a slash between our numerator and denominator. Though, let's back up for a second and rethink the constructor. Do we really want to be able to store fractions that are not in their simplest form? For example, do we want to allow the user to create a \ttt{Rational} object with a numerator of $2$ and a denominator of $4$? The answer is probably not, meaning that we should add a method that simplifies the fraction. We can do this by finding the greatest common divisor of the numerator and denominator, and dividing both by that value. Euclid's algorithm for finding the greatest common divisor of two integers works wonderfully here. Due to its trivial implementation and the fact that it is a tail recursive algorithm exercise from the previous chapters, we will omit its implementation.

\begin{cl}[RationalTest.java]{Testing the \ttt{Rational} Class}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RationalTester {
  
    @Test
    void testRationalToString() {
      assertAll(
        () -> assertEquals("1/2", new Rational(1, 2).toString()),
        () -> assertEquals("3/400", new Rational(3, 400).toString()),
        () -> assertEquals("1/1305", new Rational(5, 6525).toString()),
        () -> assertEquals("3591/46562", new Rational(7182, 93124).toString()),
        () -> assertEquals("7/32", new Rational(7, 32).toString())
      );
    }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Rational.java]{\ttt{Rational} Class}
\begin{lstlisting}[language=MyJava]
class Rational {
  
  private final long NUMERATOR;
  private final long DENOMINATOR;

  public Rational(long numerator, long denominator) {
    long gcd = gcd(numerator, denominator);
    this.NUMERATOR = numerator / gcd;
    this.DENOMINATOR = denominator / gcd; 
  }

  @Override
  public String toString() {
    return String.format("%ld/%ld", this.NUMERATOR, this.DENOMINATOR);
  }
}
\end{lstlisting}
\end{cl}

To add two rational numbers $r_1$ and $r_2$, they must share a denominator. If they do not, then we must find a common denominator by multiplying the denominators together, then multiplying the relevant numerators by the reciprocals of the denominator. For instance, if we want to add $2/3$ and $7/9$, the (not-necessarily lowest) common denominator is $3\cdot{9} = 27$. We then multiply $2$ by $9$ and $7$ by $3$ to get $18/27$ and $24/27$. Adding across the numerators results in $42/27$, which reduces to $14/9$. Since we wish to preserve the original rational number, we will write a method that returns a new \ttt{Rational} rather than modifying the one we have in-place (this also allows us to omit a step in which we simplify the resulting fraction, since the constructor takes care of this task).

\begin{cl}[RationalTest.java]{Testing Addition of Rationals}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RationalTest {

  @Test
  void testRationalAdd() {
    assertAll (
      () -> assertEquals("14/9", new Rational(2, 3).add(new Rational(7, 9)).toString()),
      () -> assertEquals("5/6", new Rational(1, 2).add(new Rational(1, 3)).toString()),
      () -> assertEquals("1/3", new Rational(1, 4).add(new Rational(1, 12)).toString()),
      () -> assertEquals("1/4", new Rational(1, 8).add(new Rational(1, 8)).toString()),
      () -> assertEquals("1/8", new Rational(1, 16).add(new Rational(1, 16)).toString())
    )
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Rational.java]{Adding Two Rational Numbers}
\begin{lstlisting}[language=MyJava]
class Rational {
  // Other details not shown.

  /**
   * Adds two rational numbers.
   *
   * @param r the other rational number.
   * @return the (simplified) sum of this and r.
   */
  public Rational add(Rational r) {
    long commonDenominator = this.DENOMINATOR * r.DENOMINATOR;
    long newNumerator = this.NUMERATOR * r.DENOMINATOR 
                        + r.NUMERATOR * this.DENOMINATOR;
    return new Rational(newNumerator, commonDenominator);
  }
}
\end{lstlisting}
\end{cl}

Due to the correspondence to addition, we will leave \ttt{subtraction} as an exercise to the reader. We can now do multiplication, which is even simpler than addition; all that is needed is to multiply the numerators and denominators together. We will also leave \ttt{division} as an exercise to the reader.

\begin{cl}[RationalTest.java]{Testing Multiplication of Rationals}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RationalTest {

  @Test
  void testRationalMultiply() {
    assertAll (
      () -> assertEquals("14/27", new Rational(2, 3).multiply(new Rational(7, 9)).toString()),
      () -> assertEquals("1/6", new Rational(1, 2).multiply(new Rational(1, 3)).toString()),
      () -> assertEquals("1/48", new Rational(1, 4).multiply(new Rational(1, 12)).toString()),
      () -> assertEquals("1/64", new Rational(1, 8).multiply(new Rational(1, 8)).toString())
    )
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Rational.java]{Multiplying Two Rational Numbers}
\begin{lstlisting}[language=MyJava]
class Rational {
  // Other details not shown.

  /**
   * Multiplies two rational numbers.
   *
   * @param r the other rational number.
   * @return the (simplified) product of this and r.
   */
  public Rational multiply(Rational r) {
    return new Rational(this.NUMERATOR * r.NUMERATOR, 
                        this.DENOMINATOR * r.DENOMINATOR);
  }
}
\end{lstlisting}
\end{cl}
