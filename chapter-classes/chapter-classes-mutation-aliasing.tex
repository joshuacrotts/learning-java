\section{Object Mutation and Aliasing}
\label{sec:object-mutation-and-aliasing}
A limitation that we have purposefully imposed on our object/class design is the inability to modify the values of instance variables. Value mutation is a foreign concept in some programming languages, but we have made extensive use of it throughout our time in the land of Java. In this section, we will discuss the implications of allowing instance variable mutation and how it can lead to some unexpected behavior.

To access a \ttt{private} instance variable, we design a \ttt{public} accessor method, which returns the instance variable. To modify a \ttt{private} instance variable, we design a \ttt{public} mutator method, which takes in a parameter and assigns the instance variable to the parameter. Let's return to the \ttt{Point} class to demonstrate. Suppose that we instantiate a point $p$ to $(7, 4)$, but we then want to change or modify either coordinate. We can do so by calling the \ttt{setX} or \ttt{setY} methods, respectively. Testing setter methods is important to verify that a change occurred when invoking the setter/mutator method, which we confirm through the accessor method. Because we want to be able to alter an instance variable, these can no longer be marked as \ttt{final}, so we remove this keyword.\footnote{This is not to suggest that we should never use \ttt{final} instance variables. In fact, we should use \ttt{final} instance variables whenever possible, since object mutation introduces the possibility of easy-to-overlook bugs.}

\begin{cl}[PointTester.java]{Testing \ttt{Point} Setter Methods}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {

  @Test
  void testSetX() {
    Point p = new Point(7, 4);
    p.setX(3);
    assertEquals(3, p.getX());
  }

  @Test
  void testSetY() {
    Point p = new Point(7, 4);
    p.setY(2);
    assertEquals(2, p.getY());
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Point.java]{\ttt{Point} Class with Accessor and Mutator Methods}
\begin{lstlisting}[language=MyJava]
class Point {

  private int x;
  private int y;

  public Point(int x, int y) { this.x = x; this.y = y; }

  public int getX() { return this.x; }

  public int getY() { return this.y; }

  public void setX(int x) { this.x = x; }

  public void setY(int y) { this.y = y; }
}
\end{lstlisting}
\end{cl}

What are some consequences to mutating an object? One comes through the notion of \textit{object aliasing}. Recall that objects point to references in memory. Therefore if we instantiate a \ttt{Point} $p_1$, then initialize another \ttt{Point} $p_2$ to reference $p_1$, then both objects refer to the same \ttt{Point} instance in memory. If we modify $p_1$ through a setter method, then $p_2$ will reflect the change.

\begin{cl}[PointTester.java]{Object Aliasing}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {

  @Test
  void pointAliasing() {
    Point p1 = new Point(7, 4);
    Point p2 = p1;
    p1.setX(3);
    assertEquals(3, p1.getX());
    assertEquals(3, p2.getX());
  }

  @Test
  void testSetY() {
    Point p1 = new Point(7, 4);
    Point p2 = p1;
    p1.setY(2);
    assertEquals(2, p1.getY());
    assertEquals(2, p2.getY());
  }
}
\end{lstlisting}
\end{cl}

This idea carries over to other, more complex classes as well. For example, strings, arrays, lists, and others are all objects, and therefore, they are all subject to object aliasing. Modifying one \ttt{ArrayList} instance will modify all other \ttt{ArrayList} instances that reference the same object. This is a common source of bugs in Java programs, and it is important to be aware of this behavior. In the following example, we will demonstrate aliasing through the \ttt{ArrayList} data structure containing \ttt{Point} objects. We add a series of \ttt{Point} instances to an \ttt{ArrayList}, which is then aliased by another \ttt{ArrayList}. We then add another \ttt{Point} instance to the first \ttt{ArrayList}, followed by a verification that the lists are the same size. Additionally, we traverse over the lists and verify that the elements are the same through the \ttt{==} operator. Remember that \ttt{==} returns whether or not two objects reference the same instance in memory. Because these lists are merely aliases of each other, they will contain references to the same \ttt{Point} instances.

\begin{cl}[PointTester.java]{Testing \ttt{ArrayList} Aliasing}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class PointTester {

  private final Point P1 = new Point(7, 4);
  private final Point P2 = new Point(3, 2);
  private final Point P3 = new Point(1, 8);

  @Test
  void pointArrayListAliasingTest() {
    ArrayList<Point> list1 = new ArrayList<>(List.of(P1, P2, P3));
    ArrayList<Point> list2 = list1;
    list1.add(new Point(5, 6));

    // First we can verify that the lists are actually the same.
    assertTrue(list1 == list2);

    // Size testing.
    assertTrue(list1.size() == list2.size());

    // Make sure both lists contain the same elements.
    for (int i = 0; i < list1.size(); i++) {
      assertTrue(list1.get(i) == list2.get(i));
    }
  }
}
\end{lstlisting}
\end{cl}

\example Now that we have classes, mutation, and accessibility, we can finally implement generic data structures such as an \ttt{ArrayList}. In this example we will implement the behavior of the \ttt{ArrayList} data structure, which means we finally understand what is going on under the hood in the Collections API. We will create a class \ttt{MiniArrayList}, which operates over any type using generics. Like generic static methods, we must quantify the generic type. Unlike static methods, however, we quantify the type in the class declaration, meaning that all instance and static methods inside the generic class do not need to be separately quantified.

In addition to the class header, what else does an \ttt{ArrayList} store? A backing array of elements and its corresponding length, of course! The array, as we described in Chapter~\ref{chapter-arrays-collections}, dynamically resizes as we add or insert elements. The logical size of the array, i.e., the number of presently-existing elements, is stored in \ttt{size}, whereas the current capacity, i.e., how many elements can currently be stored without a resize, is stored in \ttt{capacity}. Our class will provide two constructors: one that instantiates the backing array to store ten elements, and another that allows the user to specify. Interestingly, this shows off a great example of one constructor calling another of the same class; this idea is called \textit{constructor chaining}. 

\begin{cl}[MiniArrayList.java]{\ttt{MiniArrayList} Class}
\begin{lstlisting}[language=MyJava]
class MiniArrayList<T> {

  private T[] elements;
  private int size;
  private int capacity;

  public MiniArrayList() { this(10); }

  public MiniArrayList(int capacity) {
    this.size = 0;
    this.capacity = capacity;
  }
}
\end{lstlisting}
\end{cl}

Notice that we declare an array of type \ttt{T} to store the elements of our mini array list. We now must instantiate the array inside the second constructor. The problem is that we cannot instantiate an array of a generic type. Recall that generics are a compile-time feature, and arrays are a runtime feature. Therefore, we cannot instantiate an array of a generic type. Instead, we must instantiate an array containing type \ttt{Object}, followed by a cast to contain type \ttt{T}.\footnote{To be pedantic, the array is of type \ttt{Object[]}, and we cast it to type \ttt{T[]}.} This is called an \textit{unchecked cast}, and it is a necessary evil in Java to support powerful classes that operate over generic arrays. Doing so means the program typechecks and successfully compiles.

\begin{cl}[MiniArrayList.java]{\ttt{MiniArrayList} Class Instantiating the Backing Array}
\begin{lstlisting}[language=MyJava]
class MiniArrayList<T> {

  private T[] elements;
  private int size;
  private int capacity;

  public MiniArrayList() { this(10); }

  public MiniArrayList(int capacity) {
    this.size = 0;
    this.capacity = capacity;
    this.array = (T[]) new Object[capacity];
  }
}
\end{lstlisting}
\end{cl}

We now need to implement the \ttt{add} method, which adds an element to the end of the array list. We first check if the array is full, and if so, we resize the array. We then add the element to the end of the array and increment the size. Resizing the array is, fortunately, not complicated; all we need to do is instantiate a new, larger array, copy the existing elements over, then reassign the instance variable. The question now is, by what factor should the array capacity increase? This decision is implementation-dependent, but we will use a doubling factor out of convenience. We make \ttt{resize} private because it is an implementation detail that the user does not need to know about. To write coherent tests, we should also write the \ttt{get} method, which returns the element at a given index, as well as \ttt{size}, which returns the number of logical elements in the list. For now, we will not worry about bounds checking, but we will return to this in a later chapter on exceptions.

\begin{cl}[MiniArrayListTester.java]{Testing \ttt{MiniArrayList} \ttt{add} Method}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class MiniArrayListTester {

  @Test
  void testAdd() {
    MiniArrayList<Integer> list = new MiniArrayList<>();
    list.add(100);
    list.add(200);
    list.add(300);
    assertEquals(3, list.size());
    assertEquals(100, list.get(0));
    assertEquals(200, list.get(1));
    assertEquals(300, list.get(2));
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[MiniArrayList.java]{\ttt{MiniArrayList} Adding Elements}
\begin{lstlisting}[language=MyJava]
class MiniArrayList<T> {

  private static final int RESIZE_FACTOR = 2;

  // ... other details not shown.

  /**
   * Adds an element to the end of the list.
   * 
   * @param element the element to add.
   */
  public void add(T element) {
    if (this.size == this.capacity) { this.resize(); }
    this.elements[this.size] = element;
    this.size++;
  }

  /**
   * Resizes the backing array by a factor specified by the class.
   */
  private void resize() {
    this.capacity *= RESIZE_FACTOR;
    T[] newArray = (T[]) new Object[this.capacity];
    for (int i = 0; i < this.size; i++) {
      newArray[i] = this.elements[i];
    }
    this.elements = newArray;
  }

  public T get(int index) { return this.elements[index]; }

  public int size() { return this.size; }
}
\end{lstlisting}
\end{cl}

We will write two more methods: \ttt{insert}, which inserts an element $e$ at a given index, and \ttt{remove}, which removes an element at a given index. These two methods are similar in that they alter the backing array by adding/removing an element, and shifting right and left respectively. Accordingly, our implementation will contain the private helper methods \ttt{shiftRight} and \ttt{shiftLeft}. If we attempt to insert an element into a list that must be resized, we can call \ttt{resize}. Both \ttt{insert} and \ttt{remove} warrant test cases! Like the \ttt{get} counterpart, neither of these new methods will perform bounds checking, so testing out-of-bounds behavior, for the time being, is not pertinent.

\begin{cl}[MiniArrayListTester.java]{Testing \ttt{MiniArrayList} \ttt{insert} and \ttt{remove} Methods}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class MiniArrayListTester {

  @Test
  void testInsert() {
    MiniArrayList<Integer> list = new MiniArrayList<>();
    list.add(100);
    list.add(200);
    list.add(300);
    list.insert(1, 150);
    assertEquals(4, list.size());
    assertEquals(100, list.get(0));
    assertEquals(150, list.get(1));
    assertEquals(200, list.get(2));
    assertEquals(300, list.get(3));
  }

  @Test
  void testRemove() {
    MiniArrayList<Integer> list = new MiniArrayList<>();
    list.add(100);
    list.add(200);
    list.add(300);
    list.remove(1);
    assertEquals(2, list.size());
    assertEquals(100, list.get(0));
    assertEquals(300, list.get(1));
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[MiniArrayList.java]{\ttt{MiniArrayList} Inserting and Removing Elements}
\begin{lstlisting}[language=MyJava]
class MiniArrayList<T> {

  // ... other details not shown.

  /**
   * Inserts an element at the given index.
   *
   * @param e the element to insert.
   * @param idx the index to insert at.
   */
  public void insert(T e, int idx) {
    if (this.size == capacity) { this.resize(); }
    this.shiftRight();
    this.elements[idx] = e;
  }

  /**
   * Removes the element at the given index.
   *
   * @param idx the index to remove.
   * @return the element removed.
   */
  public T remove(int idx) {
    int e = this.get(idx);
    this.shiftLeft(idx);
    this.size--;
    return e;
  }

  /**
   * Shifts all elements to the left of the given index one position leftwards.
   * Note that this method overwrites the element at the given index.
   *
   * @param idx the index to shift left of.
   */
  private void shiftLeft(int idx) {
    for (int i = idx; i < this.size - 1; i++) {
      this.elements[i] = this.elements[i + 1];
    }
  }

  /**
   * Shifts all elements to the right of the given index one position rightwards.
   *
   * @param idx the index to shift right of.
   */
  private void shiftRight(int idx) {
    for (int i = size - 1; i > idx; i--) {
      this.elements[i] = this.elements[i - 1];
    }
  }
}
\end{lstlisting}
\end{cl}

\example Let's see a few more examples of object aliasing and mutation. These examples will not be meaningful in what they represent, but are great exercises in testing your understanding. We will create five classes: \ttt{A}, \ttt{B}, \ttt{C}, \ttt{D}, and \ttt{E}. Class \ttt{A} contains one mutable string instance variable; its constructor assigns the instance variable to the parameter thereof. Classes \ttt{B} and \ttt{C} are identical aside from the name: they contain an immutable object of type \ttt{A} as an instance variable. Class \ttt{D} stores an integer array of ten elements. Finally, class \ttt{E} stores a mutable integer as an instance variable. 

We present several test cases that assert different pieces of these classes. We will analyze each one and determine why it uses either \ttt{assertEquals} or \ttt{assertNotEquals} in its comparison. Our first series of tests only focuses on classes \ttt{A}, \ttt{B}, and \ttt{C} to keep things simple. We insert blanks in the assertion statements for you to fill in as exercise before checking your answers.

\begin{cl}[ClassTester.java]{Testing Object Mutation and Aliasing}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class ClassTester {

  @Test
  void testOne() {
    final A a = new A("Hello!");
    B b = new B(a);
    C c = new C(a);

    // What do each of these output?
    assert______(b.getA(), c.getA());
    assert______(b.getA().getS(), c.getA().getS());
    a.setS("Hi!");
    assert______(b.getA().getS(), c.getA().getS());
    b.getA().setS("howdy!");
    assert______(b.getA().getS(), c.getA().getS());

    B b2 = new B(a);
    assert______(a, b2.getA());
    assert______(b, b2);
    b = b2;
    assert______(a, b.getA());
    assert______(b, b2);
  }
}
\end{lstlisting}
\end{cl}

To set the scene, we first declare \ttt{a} as an immutable instance of \ttt{A} with the string literal \ttt{"Hello!"}. Then, we instantiate objects \ttt{b} and \ttt{c} of types \ttt{B} and \ttt{C} respectively, each receiving \ttt{a} as an argument to their constructors. 

Comparing \ttt{b.getA()} against \ttt{c.getA()} is a comparison of two references to the same object. Because \ttt{a} is immutable, we cannot change its value, so both \ttt{b} and \ttt{c} will always refer to the same object. Therefore, we use \ttt{assertEquals} to compare the two references. In particular, passing \ttt{a} to both constructors passes a reference to the same object.
%% Perhaps draw a diagram?

Comparing \ttt{b.getA().getS()} against \ttt{c.getA().getS()} is a comparison of two references to the same object, similar to the previous problem. The only difference is that we retrieve the string object encapsulated by the \ttt{A} class. Because both \ttt{b} and \ttt{c} point to the same reference of \ttt{a}, we know that the strings are identical references.

In the third line we change the value of the string inside \ttt{a} to be \ttt{"Hi!"}, which updates across all instances that point to \ttt{a}. Therefore, rerunning the same comparison as before still results in a true equality.

In the fifth line, we retrieve the \ttt{A} object instance pointed to by \ttt{B} and change its underlying string to be \ttt{"Howdy!"}. Rerunning the same test as before yet again results in a true equality. Because \ttt{b} points to the same \ttt{a} that \ttt{c} references, this change propagates across all references to \ttt{a}, even if we do not directly modify \ttt{a}.

We then declare a new instance of \ttt{B} named \ttt{b2}, which references the same \ttt{a} as before. If we check the value of \ttt{a} against the value of \ttt{a} inside \ttt{b2}, we of course get a true equality.

We immediately follow this comparison with one in which we compare \ttt{b} to \ttt{b2}. Because these are completely distinct object instantiations, the equality does not hold true.

Up next we reassign \ttt{b} to point to \ttt{b2}. This is a reassignment of a reference, not a reassignment of an object. Therefore if we check \ttt{b} against \ttt{b2} for equality, it is now trivially true.

Let's now test the \ttt{D} and \ttt{E} classes, which use arrays as instance variables.

\begin{cl}[ClassTester.java]{Testing Object Mutation and Aliasing}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class ClassTester {

  @Test
  void testTwo() {
    D d = new D();
    E e = new E(42);
    E[] arrOfE = new E[10];
    for (int i = 0; i < arrOfE.length; i++) { arrOfE[i] = new E(i); }
    assert______(arrOfE[2], arrOfE[5]);
    assert______(arrOfE[2].getNumber(), arrOfE[5].getNumber());

    for (int i = 0; i < arrOfE.length; i++) { arrOfE[i] = e; }
    assert______(arrOfE[0], arrOfE[2]);
    assert______(arrOfE[0].getNumber(), arrOfE[2].getNumber());
    arrOfE[7].setNumber(102);
    assert______(arrOfE[0].getNumber(), arrOfE[2].getNumber());
  }
}
\end{lstlisting}
\end{cl}

The objects \ttt{d} and \ttt{e} are instantiated to types \ttt{D} and \ttt{E} respectively, the latter of which receives the integer \ttt{42} as an argument to the constructor. We follow this up with an array of ten \ttt{E} objects. The loop after instantiates each element of the array to a new \ttt{E} object with the integer \ttt{i} as an argument to the constructor.

So, what happens if we compare any arbitrary element $e$ against any other arbitrary element $e'$ such that $e \neq e'$? Because they are all instantiated to distinct instances of \ttt{E}, any equality comparison is false. We can extend this to retrieving the number inside each \ttt{E} object and comparing them. Because they are all distinct objects, and each \ttt{E} instance receives a different number, the equality is false.

The second for loop assigns each element of the array to the \ttt{e} object. Then, we can compare any arbitrary element against any other arbitrary element, and they will always be equal, since every element is a reference to the same memory reference. 

Thus, if we set the number of one arbitrary element, this change propagates to every other element in the list, because again, all references point to the same object.
