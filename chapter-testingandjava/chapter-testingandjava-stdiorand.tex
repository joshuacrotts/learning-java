\section{Standard I/O}
Early on in a Java programmer's career, they encounter the issue of reading from the ``console'', or standard input, as well as the dubiously useful act of debugging by printing data to standard output. Many programmers are aptly familiar with these when coming from other programming languages.

First, we need to discuss the nature of the \textit{standard data streams}. Java (and the operating system in general), utilizes three standard data streams: standard input, standard output, and standard error. We can think of these as sources for reading data from and writing data to. The \textit{standard output stream} is often accessed using the \ttt{System.out} class, then through its various methods, e.g., \ttt{println}, \ttt{print}, and \ttt{printf}. To output a line to standard output, we invoke \ttt{System.out.println} with a string (or some other datatype that is coerced into a string). For relaying messages to the user in a terminal-based application or even when debugging a program, outputting information to standard output is a good idea. On the other hand, sometimes a program fails or the programmer wants to output an error message. While it is possible to output error messages to standard output, since they are otherwise indistinguishable, Java has a dedicated \textit{standard error stream} for outputting error messages and logs via \ttt{System.err}. We glossed over this method, but let's discuss \ttt{printf} in more detail due to its inherent power.

The \textit{standard input stream} allows us to ``read data from the console''.

\example Suppose we want to read an integer from the standard input stream. To do so, we first need to instantiate a \ttt{Scanner}, which declares a ``pipe'', so to speak, from which information is read. It is important to state that, while a \ttt{Scanner} may read from the standard input stream, it can read from other input streams, e.g., files or network connections. We will explore this further in subsequent chapters, but for now, let's declare a \ttt{Scanner} object to read from standard input.

\begin{verbatim}
clas
\end{verbatim}

The \ttt{Scanner} class has handy methods for retrieving data from the stream it is scanning (which we will dub the \textit{scannee}. As we said in the example prompt, to read an integer from the scannee, we use \ttt{nextInt}, which retrieves and removes the next-available integer from the scannee data stream. Note that the \ttt{Scanner} class is line-buffered, meaning that the data will not be processed by the ``accessors'', e.g., \ttt{nextInt}, until there is a new-line character in the input stream. To force a new-line, we press the ``Enter''/``Return'' key.

\begin{verbatim}
Scanner in = new Scanner(System.in);
int x = in.nextInt();
System.out.println(x);
\end{verbatim}

Running the program and typing in any 32-bit integer feeds it into standard input, then echos it to standard output. Entering any other non-integer value crashes the program with a XXXX exception. So, what if we want to read in a \ttt{String} from the scannee; would we use \ttt{nextString}? Unfortunately, this is not correct. We need to instead use \ttt{nextLine}. The \ttt{nextLine} method reads a ``line'' of text, as a string, from the scannee. We define a ``line'' as all characters until the first occurrence of a new-line. Invoking \ttt{nextLine} consumes these characters, including the newline, from the input stream, and stores them into a variable, if requested. It does not, however, store the newline in the variable. 

\begin{verbatim}
Scanner in = new Scanner(System.in);
String line = in.nextLine();
System.out.println(line);
\end{verbatim}

Typing in some characters, which may or may not be numbers, followed by a new-line, stores them in the \ttt{line} variable, excluding said new-line. Though, what happens if we prompt for an integer \textit{then} a string? The program does something quite strange. We type the integer, hit ``Return'', and the program terminates as if it did not prompt for a string. This is because of how both \ttt{nextInt} and \ttt{nextLine} behave: \ttt{nextInt} consumes all data up to but excluding an integer from the input stream; ignoring leading whitespaces. So, after consuming the integer, a new-line character remains in the input stream buffer. Then, \ttt{nextLine} intends to wait until a newline is in the buffer. Because the input stream buffer presently contains a new-line, it takes everything before the new-line, which comprises the empty string, and consumes both said empty string and the new-line from the buffer. To circumvent this issue, we can insert a call to \ttt{nextLine} in between the calls to \ttt{nextInt} and \ttt{nextLine}, thereby consuming the lone new-line character, clearing the buffer. Notice that we do not put a return value on the left-hand side of this intermediate \ttt{nextLine} invocation; this is because such a variable would hold the empty string, which for the purposes of this program is a worthless assignment.

\begin{verbatim}
Scanner in = new Scanner(System.in);
int x = in.nextInt();
in.nextLine();
String line = in.nextLine();
\end{verbatim}

\example Let's reimplement Python's \ttt{input} function, which receives a \ttt{String} serving as a prompt for the user to enter data. To make it a bit more user-friendly and elegant, we will add a colon and a space after the given prompt. Because we open a \ttt{Scanner} that reads from the standard input stream, there is no need to worry about, say, calling \ttt{nextInt} prior to invoking \ttt{input}. If, on the other hand, we declared a static global \ttt{Scanner} that reads standard input, and we use that to read an integer \textit{and} inside \ttt{input}, we would be in trouble. In our case, the possible scanners connected to the standard input stream differ, so this (the integer-input problem) never occurs.

\begin{verbatim}
static String input(String prompt) {
  Scanner in = new Scanner(System.in);
  System.out.printf("%s: ", prompt);
  return in.nextLine();
}
\end{verbatim}

\example Suppose we want to write a method that reads three Cartesian points, as integers, from standard input, and computes the area of the triangle that comprises these points. We can type all integers on the same line, as separated by spaces, because \ttt{nextInt} only parses the \textit{next} integer delimited by spaces. And, as we said before, \ttt{nextInt} skips over existing trailing spaces in the input stream buffer, so those spaces are omitted. From there, we use the formula for computing the area of the triangle from those points. 
\[
\dfrac{x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3 (y_1 - y_2)}{2}
\]
\begin{cl}[]{}
\begin{lstlisting}[language=MyJava]
class ThreePointArea {
  static double computeThreePointArea() {
    Scanner in = new Scanner(System.in);
    int x1 = in.nextInt();
    int y1 = in.nextInt();
    int x2 = in.nextInt();
    int y2 = in.nextInt();
    int x3 = in.nextInt();
    int y3 = in.nextInt();
    return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0;
  }
}
\end{lstlisting}
\end{cl}
We make a note that reading data from a scanner inside a static method that computes some value is not a very good idea; a better solution would be to read the data inside the \ttt{main} method, then call \ttt{computeThreePointArea} with the six arguments representing each point.
\begin{cl}[]{}
\begin{lstlisting}[language=MyJava]
class ThreePointArea {
  static double computeThreePointArea(double x1, double y1,
                                      double x2, double y2,
                                      double x3, double y3) {
    return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0;
  }

  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    int x1 = in.nextInt();
    int y1 = in.nextInt();
    ...
    System.out.println(computeThreePointArea(x1, y1, x2, y2, x3, y3));
  }
}
\end{lstlisting}
\end{cl}


\section{Randomness}
So-called ``true'' randomness is difficult to implement from a computing standpoint. Thus, for most intents and purposes (i.e., all of those described in this textbook), it is sufficient to use \textit{pseudorandomess} to generate random values. A pseudorandom number generator computes seemingly random values using a deterministic algorithm, which means that the output values from the generator are predictable. Although it might be incredibly difficult to predict values from a pseudorandom number generator, it is theoretically possible, making them insufficient and insecure for cryptographic schemata and algorithms. For writing, say, a word-guessing game that picks a word from a list at random, it is perfectly reasonable to use a pseudorandom number generator.

So, how do we generate pseudorandom numbers in Java? There are a few methods, and many textbooks opt to use \ttt{Math.random}, which we will explain, but we will take advantage of the \ttt{Random} class and its helper methods.