\section*{Chapter Exercises}
\addcontentsline{toc}{section}{Exercises}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{int[] operate(int[] A)} method that, when given an array of integers, returns a new array where the elements are the result of applying the following operation to each element: if the $i^{\text{th}}$ element is odd, multiply it by its index $i$ plus one. Otherwise, divide it by its index $i$ plus one.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{boolean containsOnlyPrime(int[] arr)} method that returns whether or not a given array of integers contains only prime integers. Hint: use the method you wrote in Chapter 2.}

\exercise{1}{chapter-arrays-collections}{This question has two parts.}

\begin{enumerate}[label=(\alph*)]
    \item Design the recursive \ttt{linearSearch} method that, when given a \ttt{String[]} $S$ and a \ttt{String} to search for $k$, returns the index of $k$ in $S$, and \ttt{-1} if $k$ is not in the array. Since this method is definitionally tail recursive, you should write a \ttt{private} helper method that actually performs the recursion.
    \item Design the \ttt{linearSearchLoop} method that solves the problem using a loop. 
\end{enumerate}

\exercise{2}{chapter-arrays-collections}{Write a method that receives an \ttt{int[]} and returns an \ttt{int[]} that corresponds to the accumulated sum between each integer. We present some examples below.}
\par{
\begin{verbatim}
accSum({1, 7, 2, 9})                => {1, 8, 10, 19}
accSum({1, 3, 3, 4, 5, 5, 6, 6, 2}) => {1, 4, 7, 11, 16, 21, 27, 33, 35}
accSum({5, 5, 5, 5, 5, 5, 5, 1, 5}) => {5, 10, 15, 20, 25, 30, 35, 36, 41}
\end{verbatim}
}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{String[] fizzBuzz(int min, int max)} method that iterates over the interval $[\textit{min}, \textit{max}]$ (you may assume $\textit{max} \geq \textit{min}$) and returns an array containing strings that meet the following criteria:}

    \begin{itemize}
        \item If $i$ is divisible by $3$, insert \ttt{"Fizz"}.
        \item If $i$ is divisible by $5$, insert \ttt{"Buzz"}.
        \item If $i$ is divisible by both $3$ and $5$, insert \ttt{"FizzBuzz"}.
        \item Otherwise, insert \ttt{"i"}, where \ttt{i} is the current number.
    \end{itemize}

    \par{
\begin{verbatim}
fizzBuzz(1, 12)  => {"1", "2", "Fizz", "4", "Buzz",
                     "Fizz", "7", "8", "Fizz", "Buzz",
                     "11", "Fizz"}
fizzBuzz(15, 18) => {"FizzBuzz", "16", "17", "Fizz"}
    \end{verbatim}
}

\exercise{2}{chapter-arrays-collections}{Using only arrays, design the \ttt{int[] findIntersection(int[] A, int[] B)} method that returns an array containing the \textit{intersection} of two arrays. The intersection of two arrays is the set of elements that are common to both arrays. For example, the intersection of $\{7, 4, 8, 0, 2, 1\}$ and $\{8, 6, 4, 9, 26, 4, 0\}$ is $\{7, 8, 0\}$. Do not assume that the arrays are sorted, and you cannot sort them yourself.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{double sumYucky(ArrayList<Integer> vals)} method that returns the average of the numbers in the list. Though, the number $9$ should not be counted towards the average, nor should the following number, should one exist.}
\par{
\begin{verbatim}
sumYucky({8, 7, 11, 9, 12, 10} => 9.0
sumYucky({120, 99, 9}          => 109.5
sumYucky({9})                  => 0.0
sumYucky({})                   => 0.0
\end{verbatim}
}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{int[] countEvenOdds(int[] vals)} method that returns a tuple (an array of two values) where index zero stores the amount of even values and index one stores the amount of odd values.}
\par{
\begin{verbatim}
countEvenOdds({11, 9, 2, 3, 7, 10, 12, 114}) => {4, 4}
countEvenOdds({11, 13, 15, 17})              => {0, 4}
\end{verbatim}
}

\exercise{2}{chapter-arrays-collections}{We can represent matrices as two-dimensional arrays. For example, the matrix}

\[
\begin{bmatrix}
    1 & 2 & 3\\
    4 & 5 & 6\\
    7 & 8 & 9
\end{bmatrix}
\]

\noindent can be represented as the two-dimensional array

\par{
\begin{verbatim}
int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
\end{verbatim}
}

\noindent Design the \ttt{int[][] transpose(int[][] matrix)} method that returns the transpose of a given matrix. The transpose of a matrix is the matrix where the rows and columns are swapped. For example, the transpose of the above matrix is

\[
\begin{bmatrix}
    1 & 4 & 7\\
    2 & 5 & 8\\
    3 & 6 & 9
\end{bmatrix}
\]

\exercise{2}{chapter-arrays-collections}{Design the \ttt{int[][] rotate(int[][] matrix)} method that returns the matrix rotated $90$ degrees clockwise. For example, the matrix}

\[
\begin{bmatrix}
    1 & 4 & 7\\
    2 & 5 & 8\\
    3 & 6 & 9
\end{bmatrix}
\]

\noindent is rotated to

\[
\begin{bmatrix}
    3 & 2 & 1\\
    6 & 5 & 4\\
    9 & 8 & 7
\end{bmatrix}
\]

To rotate a matrix, take its transposition, then reverse each row. You may assume that the input matrix is $N \times N$, i.e., a square matrix.

\exercise{2}{chapter-arrays-collections}{Design the \ttt{int[][] multiply(int[][] A, int[][] B)} method that returns the product of two matrices, where $A$ is $M \times N$ and $B$ is $P \times Q$. Not all matrices can be multiplied, so you should return \ttt{null} if the matrices cannot be multiplied. Two matrices can be multiplied if and only if $N = P$. The product of two matrices $A$ and $B$ is the matrix $C$ where $C_{i, j} = \sum_{k=1}^{N} A_{i, k}\cdot B_{k, j}$} for the indices $i$, $k$, and $j$.

\exercise{2}{chapter-arrays-collections}{Design the \ttt{boolean canSum(int[] A, int t)} method that, when given an array of integers $A$ and a target $t$, determines whether or not there exists a gruop of numbers in $A$ that sum to $t$. For example, if $A=\{2, 4, 10, 8\}$ and $t=9$, then \ttt{canSum} returns false because there is no possible selection of integers from $A$ that sum to $9$. On the other hand, if $A=\{3, 7, 4, 5, 9\}$ and $t=8$, then we return true because $3+5=8$. If $A=\{2, 4, 2, 11, 5, 4\}$ and $t=9$, then we return true because $1+4+4=9$, but also $4+5=9$ and $5+4=9$.}

There is a simple recursive algorithm to solve this problem: if you have searched through the entire array, return whether or not the target is zero. Otherwise, make two recursive calls: one for where you choose the current number and a second for where you do not. By ``choose'', we mean to say that the current number is subtracted from the target value. By ``current number'', we mean to suggest a design that resemble the tail recursive linear search algorithm. You'll need to design a helper method to solve this problem using this approach.

\exercise{2}{chapter-arrays-collections}{Design the \ttt{Set<List<Integer>> twoSum(int[] A, int t)} method that, when given an array of integers $A$ and a target $t$, returns all possible pairs of numbers in $A$ that sum to $t$. For example, if $A=\{2, 2, 4, 10, 6, -2\}$ and $t=4$, we return a set containing two two-element lists: $\{2, 2\}$ and $\{6, -2\}$. DO not add a pair that already exists in the set or a pair that, by reversing the pair, we get a pair in the existing set. E.g., $\{-2, 6\}$ should not be added to the set. 

There is a simple brute-force algorithm to solve this problem via two loops, but by incorporating a second set for lookups, we can do much better: for every number $n$ in $A$, add $n$ to a set $S$, and if $t-n=m$ for some $m\in{S}$, then we know that $m+n$ must equal $t$, therefore we add $\{n, m\}$ to the resulting set of integer arrays.}
Walking through this with the example from before, we get the following sequence of actions:

\begin{itemize}
    \item Initialize $S=\{\}$ and $L=\{\}$. We know that $t=4$.
    \item We add $2$ to $S$. $S=\{2\}$.
    \item Because $4-2\in{S}$, the two-element array $\{2, 2\}$ is added to $L$. $2$ is not re-added to $S$.
    \item Because $4-4\not\in{S}$, we only add $4$ to $S$. $S=\{2, 4\}$.
    \item Because $4-10\not\in{S}$, we only add $10$ to $S$. $S=\{2, 4, 10\}$.
    \item Because $4-6\not\in{S}$, we only add $6$ to $S$. $S=\{2, 4, 10, 6\}$.
    \item Because $4-(-2)\in{S}$, the two-element array $\{6, -2\}$ is added to $L$. We add $-2$ to $S$. $S=\{2, 4, 10, 6, -2\}$.
\end{itemize}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{ArrayList<String> shift(ArrayList<String> ls, int i)} method that, when given a list of strings $s$ and an index $i$, returns a new list where each element is shifted  by $i$ spots. Negative values correspond to left shifts, and positive values correspond to right shifts. If a shift is nonsensical, do not shift at all. A nonsensical shift is one of the following:}
\begin{itemize}
    \item If there are no elements in the list.
    \item If there is only one element in the list.
    \item If there are only two elements in the list, you only need to shift once. Do the math!
\end{itemize}
    
This method is harder than it may appear at first glance, so write plenty of tests!
\par{
\begin{verbatim}
shift({11, 12, 13, 14}, -1)          => {12, 13, 14, 11}
shift({120, 120, 140, 140}, 2)       => {140, 140, 120, 120}
shift({99999999}, 1000)              => {99999999}
shift({}, -9999999)                  => {}
shift({120, 80, 70, 50, 40, 20}, -3) => {50, 40, 20, 120, 80, 70}
\end{verbatim}
}

\exercise{2}{chapter-arrays-collections}{For this problem you are not allowed to use an \ttt{ArrayList} or any helper methods, e.g., \ttt{.contains}, or methods from the \ttt{Arrays} class. You \textit{may} (and should!) use a \ttt{HashSet<Integer>} to keep track of previously-seen peaks.}

Joe the mountain climber has come across a large mountain range. He wants to climb only the tallest mountains in the range. Design the \ttt{peakFinder} method that returns an array $H'$ of all the peaks in an \ttt{int[]} of mountain heights $H$. A peak $p$ is defined as an element of $h$ at index $i$ such that $p[i - 1] < p[i]$ and $p[i] > p[i + 1]$. If $i = 0$ or $i = |H| - 1$, Joe will not climb $p[i]$. Joe doesn't want to climb a mountain of the same height more than once, so you should not add any peaks that have already been added to $H'$. We present some test cases below. Hint: reuse the linear search algorithm from problem 1, except switch the \ttt{String} parameter for integers.

\par{
\begin{verbatim}
peakFinder({9, 13, 7, 2, 8})                        => {13}
peakFinder({8, 7, 8, 7, 8, 7, 8, 7})                => {8}
peakFinder({111, 27, 84, 31, 5, 9, 4, 3, 2, 1, 64}) => {84, 9}
peakFinder({})                                      => {}
peakFinder({1})                                     => {}
peakFinder({1, 2})                                  => {}
peakFinder({1, 2, 1})                               => {2}
peakFinder({1, 2, 3, 2, 1})                         => {3}
\end{verbatim}
}

\exercise{1}{chapter-arrays-collections}{A professor gives their students extra credit on an exam if they can guess the average within five percent of the actual average. Design the \ttt{isGivenExtraCredit} method that, when given an \ttt{ArrayList<Double>} $D$ and a guess $g$, returns whether a student is given extra credit.}

\exercise{1}{chapter-arrays-collections}{A village has members where each has a partner. These members are grouped in pairs inside an \ttt{ArrayList<Integer>} where each pair of indices represents a relationship of the village. I.e., \ttt{A.get($2i$)} and \ttt{A.get($2i + 1$)} are in a relationship. A couple is considered the wisest if they have the highest combined age. Write the \ttt{wisest} method that, when given an \ttt{ArrayList<Integer>} $A$, return a new \ttt{ArrayList<Integer>} containing the ages of the wisest pair. If there is a tie, return the pair that has the highest age overall. The order is not significant. We present a few test cases below. You can assume that there will always be an even number of village members.}

\par{
\begin{verbatim}
wisest({31, 42, 43, 35, 21, 27, 24, 44} => {43, 35} or {35, 43}
wisest({47, 51, 52, 48, 33, 67, 45, 35} => {33, 67} or {67, 33}
\end{verbatim}
}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{tokenize} method that, when given a \ttt{String} $s$ and a \ttt{char} delimiter $d$, returns an \ttt{ArrayList} of tokens split at the delimiter. You must do this by hand; you cannot call any \ttt{String} methods (except \ttt{.length} and \ttt{.charAt}).}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{wordCount} method that, when given a \ttt{String} $s$, counts the number of words in the list. Store the results in a \ttt{HashMap<String, Integer>}. Assume that $s$ is not cleaned. That is, you should first remove all punctuation (periods, commas, exclamation points, question marks, semi-colons, dashes, hashes, ampersands, asterisks, and parentheses) from $s$, producing a new string $s'$. Then, split the string based on spaces (remember \ttt{tokenize}?), and produce a map of the words to their respective counts. Do not factor case into your total; i.e., \ttt{"fAcToR"} and \ttt{"factor"} count as the same word. The ordering of the returned map is not significant.}

\par{
\begin{verbatim}
String s = "Hello world, the world is healthy, is 
            it not? I certainly agree that the world 
            is #1 and healthy."
wordCount(s) => [{"hello", 1}, {"world", 3}, {"the", 2}
                 {"is", 3}, {"healthy", 2}, {"it", 1},
                 {"i", 1}, {"certainly", 1} {"agree", 1}
                 {"that", 1}, {"1", 1}, {"and", 1}, {"not", 1}]
\end{verbatim}
}

\exercise{3}{chapter-arrays-collections}{Design the \ttt{largeToSmall} method that, when given a \ttt{HashMap<String, Integer>} $M$, returns a \ttt{LinkedHashSet} of \ttt{String} values where the words are inserted into the set in order of decreasing count. Words that have the same count do not need to be inserted in any particular order. E.g., \ttt{"is"} may come before \ttt{"world"}. You cannot sort $M$. Hint: create an array of size $c$ (where $c$ is the highest word count) where each element is a \ttt{LinkedHashSet<String>}. For every element $e$ in $M$, add $e$ to the set at index $M[i]$, where $i$ is the count of $e$ in $M$. Then, append these sets in reverse order according to their index. We provide some pseudocode below.}

\par{
\begin{verbatim}
largeToSmall(M):
  // |M| is M.size().
  c = Get Highest Count Word in M
  array = [0 .. c-1]
  for i in [0 .. c-1]:
    array[i] = new LinkedHashSet<String>();

  for every key k in M:
    i = M.get(k)
    array[i-1].add(k)

  // Append all linkedhashsets in reverse order.
  return array[c-1] appended to array[c-2] ... appended to array[0]
\end{verbatim}
}
    
\par{
\begin{verbatim}
largeToSmall(wordCount(s)) => {"world", "is", "the", "healthy", 
                               "hello", "it", "i", "certainly", 
                               "agree", "that", "1", "and", "not"}
\end{verbatim}
}

\exercise{1}{chapter-arrays-collections}{Design the static \ttt{addLast} method that, when given a \ttt{LinkedList<Integer>} $l$ and an \ttt{int} $v$, returns a \textit{new} \ttt{LinkedList<Integer>} with the same elements plus $v$ added to the end of $l$.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{set} method that, when given a \ttt{LinkedList<Integer>} $l$, an \ttt{int} $v$, and an index $i$, returns a \textit{new} \ttt{LinkedList<Integer>} with the same elements, except that the element at index $i$ is, instead, the value $v$. If $i$ is less than zero or exceeds the length of $l$, return \ttt{null}.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{toArray} method that, when given a \ttt{LinkedList<Integer>} $l$ of \ttt{Integer}, returns an array containing the values from $l$.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{reverse} method that, when given a \ttt{LinkedList<Integer>} $l$, returns a \textit{new} \ttt{LinkedList<Integer>} containing the elements of $l$, but reversed.}

\exercise{2}{chapter-arrays-collections}{Design the \texttt{moreThanThree} method that, when given an \texttt{int[]} $A$, returns a new \texttt{HashSet\-<Integer>} of values containing those values from $A$ that occur strictly more than three times.}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{collectComments} method that, when given a \ttt{String} containing a (valid) Java program, returns an \ttt{ArrayList<String>} containing all comments from the input program string. You cannot use any \ttt{String} helper methods (e.g., \ttt{strip}, \ttt{split}) to solve this problem nor can you use regular expressions.}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{postfixEvaluator} method that, when given an \ttt{ArrayList<String>} of binary operators and numeric operands, returns the result of evaluating the postfix-notation expression. You will need to write a few helper methods to solve this problem, and it is best to break it down into steps. First, write a method that determines if a given string is one of the four binary operators: \ttt{"+"}, \ttt{"-"}, \ttt{"*"}, or \ttt{"/"}. You may assume that any inputs that are not binary operators are operands, i.e., numbers. Then, write a method that applies a given binary operator to a list of operands, i.e., an \ttt{ArrayList<Double>}.}

\par{
\begin{verbatim}
postfixEvaluator({"5", "2", "*", "5", "+"}) => 17
postfixEvaluator({"1", "2", "3", "4", "+"}) => 10
\end{verbatim}
}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{substitute} method that, when given a \ttt{String} $\mathit{exp}$ and an environment $\mathit{env}$ \ttt{HashMap<String, Integer>}, substitutes each occurrence of an ``identifier'' for its value counterpart from the map.}

\par{
\begin{verbatim}
substitute("f(x) = 3 * a + b", {<"a" : 10>, <"b" : 13>})
           => "f(x) = 3 * 10 + 13"
substitute("g(h, f(x)) = y + x", {<"q" : 200>})          
           => "g(h, f(x)) = y + x" 
\end{verbatim}
}

\exercise{3}{chapter-arrays-collections}{Design the \ttt{unifiesAll} method, which receives a \ttt{HashMap<String, Integer>} $M$ of unification assignments and a list of goals \ttt{ArrayList<LinkedList<String>>}} $\mathcal{G}$. Each goal $G \in \mathcal{G}$ is a tuple represented as a \ttt{LinkedList}; goals consist of two values $x, y$, and if it is possible for these to be the same value, then we say we can unify $x$ with $y$. Any successful unifications that occur with variables not present in $M$ should be added to $M$. We present some examples below (assume all values are strings; we omit the quotes out of conciseness). Hint: you might want to write an \ttt{isVar} predicate, which determines if a value is a variable or not, i.e., a value that does not start with a number.

\par{
\begin{verbatim}
M1 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G1  = {{x, x}, {10, 10}, {z, 15}, {x, w}}
unifiesAll(M1, G1) => true

M2 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G2 = {{x, y}}
unifiesAll(M2, G2) => false

M3 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G3 = {{q, x}, {w, 5}, {q, 5}, {q, w}}
unifiesAll(M3, G3) => true

M4 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G4 = {{q, x}, {q, 10}}
unifiesAll(M4, G4) => false
\end{verbatim}
}

\exercise{3}{chapter-arrays-collections}{Two strings $s_1$ and $s_2$ are isomorphic if we can create a mapping from $s_1$ from $s_2$. For example, the strings \ttt{"DCBA"} and \ttt{"ZYXW"} are isomorphic because we can map $D$ to $Z$, $C$ to $Y$, and so forth. Another example is \ttt{"ABACAB"} and \ttt{"XYXZXY"} for similar reasons. A non-example is \ttt{"PROXY"} and \ttt{"ALPHA"}, because once we map \ttt{"A"} to \ttt{"P"}, we cannot create a map between \ttt{"A"} and \ttt{"Y"}. Write the \ttt{isIsomorphic} method, which determines whether or not two strings are isomorphic. }

\exercise{2}{chapter-arrays-collections}{Anagrams are strings that are formed by rearranging the letters of another string. For example, \ttt{"plea"} is an anagram for \ttt{"leap"}, but we consider an alphabetized anagram to be the alphabetized arrangement of letters for an anagram. As an example, \ttt{"aelrst"} is the alphabetized anagram for \ttt{"alerts"}, \ttt{"alters"}, \ttt{"slater"}, and \ttt{"staler"}. Write the \ttt{static Map<String, List<String>> alphaAnagramGroups(List<String> ls)} method, which maps all alphabetized anagrams to the strings in $\textit{ls}$ using the above criteria.}
    
\par{
\begin{verbatim}
ls = ["presorting", "plea", "introduces", "anger", "leap", "petals",
      "donate", "plates", "range", "reductions", "rediscount", 
      "tapers", "pale", "atoned", "staple", "repast", "reportings"]
      
alphaAnagramGroups(ls) 
  => {{"aegnr", ["anger", "range"]}, 
      {"aelp", ["plea", "leap", "pale"]}, 
      {"aelpst", ["petals", "plates", "staple"]}, 
      {"aeprst", ["tapers", "repast"]}
      {"cdeinorstu", ["introduces", "reductions", "rediscount"]}, 
      {"adenot", ["donate", "atoned"]}, 
      {"eginoprrst", ["presorting", "reportings"]}}
    
\end{verbatim}
}

\exercise{3}{chapter-arrays-collections}{A SLC (simplified lambda calculus) expression takes one of the two forms: $\mathit{varList}$ or $\lambda{\mathit{var}}.\mathit{expr}$, where $\mathit{var}$ is a lower-case letter from $u$ to $z$, $\mathit{varList}$ is a sequence of variables, and $\mathit{expr}$ is either a $\mathit{var}$ or another SLC expression. We provide some examples below.}

\begin{align*}
  & \lambda{}x.\lambda{y}.xyz\\
  & \lambda{x}.x\\
  & \lambda{y}.yzxw\\
  & \lambda{w}.\lambda{x}.\lambda{y}.\lambda{z}.z
\end{align*}

Your job is to determine which variables are bound, which are free, and which are neither.

A bound variable is a variable that is bound by a $\lambda$ and occurs in its expression. For example, in the expression $\lambda{x}.x$, $x$ is bound.

A free variable is a variable that is \textit{not} bound by a $\lambda$ but does occur in an expression. For example, in the expression $\lambda{y}.\lambda{x}.zwv$, $z$, $w$, and $v$ are free variables.

A variable that is neither free nor bound is a variable that is bound by a $\lambda$ but does not occur in its expression. For example, in the expression $\lambda{}x.\lambda{}y.yz$, $x$ is neither free nor bound.

Write the \ttt{static HashMap<String, String> classifyVars(String expr)} method, which returns a map of variables to their classification. We provide some examples below. You may assume that the input is a valid SLC expression and that no variables shadow one another. Use the values \ttt{V}, \ttt{B}, and \ttt{N} to represent free, bound, and neither, respectively.
\begin{alltt}
classifyVars("xyz")       => {<"x" : "F">, <"y" : "F">, <"z" : "F">}
classifyVars("\(\lambda\)x.\(\lambda\)y.xyz") => {<"x" : "B">, <"y" : "B">, <"z" : "F">}
classifyVars("\(\lambda\)x.\(\lambda\)y.x")   => {<"x" : "B">, <"y" : "N">}
\end{alltt}

\exercise{2}{chapter-arrays-collections}{The \textit{substitution cipher} is a text cipher that encodes an alphabet string $A$ (also called the \textit{plain-text alphabet}) with a key string $K$ (also called the \textit{cipher-text alphabet}). The $A$ string is defined as \ttt{"ABCDEFGHIJKLMNOPQRSTUVWXYZ"}, and $K$ is any permutation of $A$. We can encode a string $s$ using $K$ as a mapping from $A$. For example, if $K$ is the string \ttt{"ZEBRASCDFGHIJKLMNOPQTUVWXY"} and $s$ is \ttt{"FLEE AT ONCE. WE ARE DISCOVERED!"}, the result of encoding $s$ produces \ttt{"SIAA ZQ LKBA. VA ZOA RFPBLUAOAR!"}

Design the \ttt{subtitutionCipher} method, which receives a plain-text alphabet string $A$, a cipher-text string $K$, and a string $s$ to encode, \ttt{substitutionCipher} should return a string $s'$ using the aforementioned substitution cipher algorithm. You must follow the ``design recipe'' laid out in class. That is, you must write the method purpose statement comment, tests, and the implementation.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, write a method that takes a \ttt{List<Integer>} and filters out even numbers and then calculates the sum of the remaining odd numbers.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, write a method that, given a \ttt{List<String>}, concatenates all the strings together into a single string, separated by a comma.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, write a method that, given a \ttt{List<String>}, groups the words by their length and counts how many words are there for each length. This means that the return value should be a \ttt{Map<String, Integer>}. There are a couple of ways to do this, and any way that correctly utilizes the Stream API is fine.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, write a method that, given a \ttt{List<String>}, returns a list where each string has \ttt{"y"} added at its end, omitting any resulting strings that contain \ttt{"yy"} as a substring anywhere.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, write a method that, given a \ttt{List<Integer>}, returns a list of those numbers squared and adds ten to the result, omitting any of the resulting numbers that end in $5$ or $6$.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, design the \ttt{removeDups} method that removes all duplicate integers from a given \ttt{List<Integer>}. Return this result as a new list.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, design the \ttt{removeLongerThan} method that removes all strings that are longer than a given integer $n$, from a given \ttt{List<String>}. Return this result as a new list.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, design the \ttt{filterThenSquare} method that, when given a \ttt{List<Double>} $L$, removes all odd values, and squares the remaining values. Return this result as a new list.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, design the \ttt{filterDoubleAvg} method that, when given a \ttt{List\-<Integer>} $L$, removes all non-prime numbers, doubles each remaining value, and computes the average of said values. Return this result as a value.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, design the \ttt{min} method that, when given a \ttt{List<Integer>} $L$, returns the minimum value in the list. Return this result as an \ttt{Optional<Integer>}. If there are no values in $L$, return \ttt{Optional.empty()}.}

\exercise{1}{chapter-arrays-collections}{Design the generic \ttt{lookup} method that, when given an \ttt{Map<K, V>} $M$ and a value $k$ of type \ttt{K}, returns the corresponding value (of type \ttt{V}) associated with the key $k$. If the key does not exist, return \ttt{null}. You will need to use the \ttt{.equals} method.}

\exercise{1}{chapter-arrays-collections}{Design the generic \ttt{stringifyList} method that, when given an \ttt{ArrayList<T>} $L$, returns a \ttt{String} of comma-separated values where each value is an element of $L$, but converted into a \ttt{String}. You'll need to use the \ttt{.toString} method.}

\exercise{2}{chapter-arrays-collections}{Design the generic \ttt{min} method, which receives a list of integers and returns the minimum element in the list. It should return an \ttt{Optional} value of type \ttt{T}, where \ttt{T} is the type of the list. If the list is empty, return an empty \ttt{Optional}. Remember that \ttt{T} must be a type that implements the \ttt{Comparable} interface.}


%f(a, b) and f(3, 4) produces {<a : 3>, <b : 4>}
%f(a, a) and f(3, 4) produces {<>}