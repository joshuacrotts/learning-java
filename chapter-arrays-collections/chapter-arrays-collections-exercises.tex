\section*{Chapter Exercises}
\addcontentsline{toc}{section}{Exercises}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{int[] operate(int[] A)} method that, when given an array of integers, returns a new array where the elements are the result of applying the following operation to each element: if the $i^{\text{th}}$ element is odd, multiply it by its index $i$ plus one. Otherwise, divide it by its index $i$ plus one.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{boolean containsOnlyPrime(int[] arr)} method that returns whether or not a given array of integers contains only prime integers. Hint: use the method you wrote in Chapter~\ref{chapter-crl}.}

\exercise{1}{chapter-arrays-collections}{This question has two parts.}

\begin{enumerate}[label=(\alph*)]
    \item Design the recursive \ttt{linearSearch} method that, when given a \ttt{String[]} $S$ and a \ttt{String} to search for $k$, returns the index of $k$ in $S$, and \ttt{-1} if $k$ is not in the array. This method is definitionally tail recursive, you should write a \ttt{private} helper method that actually performs the recursion.\footnote{By ``definitionally tail recursive,'' we mean that, even though a standard recursive variant exists, it is strongly recommended to only use a tail recursive algorithm, given the recursive definition requirement.}
    \item Design the \ttt{linearSearchLoop} method that solves the problem using a loop. 
\end{enumerate}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{int[] accSum(int[] A)} method, which receives an array of integers and returns a new array of integers that corresponds to the accumulated sum between each integer. We present some examples below.}
\begin{verbnobox}[\small]
accSum({1, 7, 2, 9})                => {1, 8, 10, 19}
accSum({1, 3, 3, 4, 5, 5, 6, 6, 2}) => {1, 4, 7, 11, 16, 21, 27, 33, 35}
accSum({5, 5, 5, 5, 5, 5, 5, 1, 5}) => {5, 10, 15, 20, 25, 30, 35, 36, 41}
\end{verbnobox}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{String[] fizzBuzz(int min, int max)} method that iterates over the interval $[\textit{min}, \textit{max}]$ (you may assume $\textit{max} \geq \textit{min}$) and returns an array containing strings that meet the following criteria:}

    \begin{itemize}
        \item If $i$ is divisible by $3$, insert \ttt{"Fizz"}.
        \item If $i$ is divisible by $5$, insert \ttt{"Buzz"}.
        \item If $i$ is divisible by both $3$ and $5$, insert \ttt{"FizzBuzz"}.
        \item Otherwise, insert \ttt{"i"}, where \ttt{i} is the current number.
    \end{itemize}

    \begin{verbnobox}[\small]
fizzBuzz(1, 12)  => {"1", "2", "Fizz", "4", "Buzz",
                     "Fizz", "7", "8", "Fizz", "Buzz",
                     "11", "Fizz"}
fizzBuzz(15, 18) => {"FizzBuzz", "16", "17", "Fizz"}
    \end{verbnobox}

\exercise{2}{chapter-arrays-collections}{Using only arrays, design the \ttt{int[] findIntersection(int[] A, int[] B)} method that returns an array containing the \textit{intersection} of two arrays. The intersection of two arrays is the set of elements that are common to both arrays. For example, the intersection of $\{7, 4, 8, 0, 2, 1\}$ and $\{8, 6, 4, 9, 26, 4, 0\}$ is $\{7, 8, 0\}$. Do not assume that the arrays are sorted, and you cannot sort them yourself.}

\exercise{2}{chapter-arrays-collections}{Desing the \ttt{int median(int[] A, int[] B)} that, when given two sorted (in increasing order) arrays of integers $A$ and $B$, returns the median value of those two lists. You can use auxiliary data structures to help in solving the problem, but they are not necessary.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{double sumNasty(ArrayList<Integer> vals)} method that returns the average of the numbers in the list with the following caveat: The number $9$ should not be counted towards the average, nor should the following number, should one exist.}
\begin{verbnobox}[\small]
sumNasty({8, 7, 11, 9, 12, 10}) => 9.0
sumNasty({120, 99, 9})          => 109.5
sumNasty({9})                   => 0.0
sumNasty({})                    => 0.0
\end{verbnobox}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{int[] countEvenOdds(int[] vals)} method that returns a tuple (an array of two values) where index zero stores the amount of even values and index one stores the amount of odd values.}

\begin{verbnobox}[\small]
countEvenOdds({11, 9, 2, 3, 7, 10, 12, 114}) => {4, 4}
countEvenOdds({11, 13, 15, 17})              => {0, 4}
\end{verbnobox}

\exercise{2}{chapter-arrays-collections}{This question has two parts.}
\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{isAlmostStrictlyIncreasing} tail recursive method that, when given an array of integers, determines if it is strictly increasing. There is a catch to this: we also return true if the array can be made strictly increasing by removing exactly one element from the array. For instance, \ttt{isAlmostStrictlyIncreasing($\{1, 3, 2, 4\}$)} returns true because, by removing \ttt{3}, we get a list that is strictly increasing. Compare this with \ttt{2, 3, 2, 4}, which cannot be made strictly increasing.
    \item Design the \ttt{isAlmostStrictlyIncreasingLoop} method that solves the problem using a loop.
\end{enumerate}
If you write tests for one of these methods, you should be able to propagate it through the rest, so write plenty!

\exercise{2}{chapter-arrays-collections}{Design the \ttt{boolean isSubArray(int[] A, int[] B)} method, which receives two arrays of integers $A$ and $B$, and determines if $B$ is a ``sub-array'' of $A$. This means that all elements of $B$ are elements of $A$.}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{int[] twoDimToOneDim}(int[][] A) method that flattens a given two-dimensional array of integers into a one-dimensional array. Hint: figure out how many elements the resulting one-dimensional array should have, and only then figure out how to position elements.}

\exercise{3}{chapter-arrays-collections}{Design the \ttt{boolean canBalanceArray(int[] A)} method, which determines whether or not an array of integers $A$ can be split into a partition that balances each side. Use the following examples as motivation.}

\begin{verbnobox}[\small]
canBalanceArray(new int[]{1, 1, 1, 1, 5})    => false
canBalanceArray(new int[]{2, 3, 5})          => true
canBalanceArray(new int[]{-10, 2, -58, 50})  => true
canBalanceArray(new int[]{3, -1, -1, -1, 0}) => true
canBalanceArray(new int[]{3, 2, 1, 0})       => true
canBalanceArray(new int[]{10})               => false
\end{verbnobox}

\exercise{3}{chapter-arrays-collections}{A \textit{span} is the distance between a value and another, distinct occurrence of the same value. Design the \ttt{int largestSpan(int[] A)} method that, when given a non-empty array of integers $A$, returns the largest span. It may be beneficial to write the \ttt{firstIndexOf} and \ttt{lastIndexOf} methods to help in your design process. Use the following examples as motivation.}

\begin{verbnobox}[\small]
largestSpan(new int[]{4, 2, 3, 2, 5})             => 3
largestSpan(new int[]{1, 2, 3, 4, 5})             => 1
largestSpan(new int[]{5, 4, 4, 4, 3, 4, 1, 4, 1}) => 7
\end{verbnobox} 

\exercise{2}{chapter-arrays-collections}{Design the \ttt{String[][] computeBowlingScores(String[] S, int[][][] scores)} method that ocmputes the bowling score for each player name in $S$. The scores are separated by rows, where the $i^\text{th}$ row corresponds to the $i^\text{th}$ name in $S$. Each row contains ten arrays of 3-element arrays. These triples, as we will call them, correspond to a bowling frame. The first nine frames only use the first two slots of the triple, whereas the last may use all three.}

To compute the score of a player, there are a few rules. Note that, in bowling, the objective is to knock down all ten pins.

For frames 1 to 9:
\begin{itemize}
    \item If the player scores a strike, meaning they hit all ten pins with one throw, it is worth ten points plus the sum of the next two frames, if they exist.
    \item If the player scores a spare, meaning they hit all ten points with exactly two throws, it is worth ten points, plus the sum of the next frame, if it exists.
    \item If the player does not score a strike nor a spare, they earn as many points as pins knocked down.
\end{itemize}

For frame 10:
\begin{itemize}
    \item If the player scores a strike on the first throw, they get two more attempts.
    \item If the player scores a spare resulting from the first two throws, they get one more attempt.
    \item If the player does not score a strike nor a spare from the first two shots, they earn as many points as pins knocked down.
\end{itemize}

The resulting array contains $n$ rows to represent $n$ players, where the first element of a row is the player name alpabetized, and the second is their score.


\exercise{2}{chapter-arrays-collections}{We can represent matrices as two-dimensional arrays. For example, the matrix}

\[
\begin{bmatrix}
    1 & 2 & 3\\
    4 & 5 & 6\\
    7 & 8 & 9
\end{bmatrix}
\]

\noindent can be represented as the two-dimensional array

\begin{verbnobox}[\small]
int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
\end{verbnobox}

\noindent Design the \ttt{int[][] transpose(int[][] matrix)} method that returns the transpose of a given matrix. The transpose of a matrix is the matrix where the rows and columns are swapped. For example, the transpose of the above matrix is

\[
\begin{bmatrix}
    1 & 4 & 7\\
    2 & 5 & 8\\
    3 & 6 & 9
\end{bmatrix}
\]

\exercise{2}{chapter-arrays-collections}{Design the \ttt{int[][] rotate(int[][] matrix)} method that returns the matrix rotated $90$ degrees clockwise. For example, the matrix}

\[
\begin{bmatrix}
    1 & 4 & 7\\
    2 & 5 & 8\\
    3 & 6 & 9
\end{bmatrix}
\]

\noindent is rotated to

\[
\begin{bmatrix}
    3 & 2 & 1\\
    6 & 5 & 4\\
    9 & 8 & 7
\end{bmatrix}
\]

To rotate a matrix, take its transposition, then reverse each row. You may assume that the input matrix is $N \times N$, i.e., a square matrix.

\exercise{2}{chapter-arrays-collections}{Design the \ttt{int[][] multiply(int[][] A, int[][] B)} method that returns the product of two matrices, where $A$ is $M \times N$ and $B$ is $P \times Q$. Not all matrices can be multiplied, so you should return \ttt{null} if the matrices cannot be multiplied. Two matrices can be multiplied if and only if $N = P$. The product of two matrices $A$ and $B$ is the matrix $C$ where $C_{i, j} = \sum_{k=1}^{N} A_{i, k}\cdot B_{k, j}$} for the indices $i$, $k$, and $j$.

\exercise{2}{chapter-arrays-collections}{Design the \ttt{boolean canSum(int[] A, int t)} method that, when given an array of integers $A$ and a target $t$, determines whether or not there exists a gruop of numbers in $A$ that sum to $t$. For example, if $A=\{2, 4, 10, 8\}$ and $t=9$, then \ttt{canSum} returns false because there is no possible selection of integers from $A$ that sum to $9$. On the other hand, if $A=\{3, 7, 4, 5, 9\}$ and $t=8$, then we return true because $3+5=8$. If $A=\{2, 4, 2, 11, 5, 4\}$ and $t=9$, then we return true because $1+4+4=9$, but also $4+5=9$ and $5+4=9$.}

There is a simple recursive algorithm to solve this problem: if you have searched through the entire array, return whether or not the target is zero. Otherwise, make two recursive calls: one for where you choose the current number and a second for where you do not. By ``choose,'' we mean to say that the current number is subtracted from the target value. By ``current number,'' we mean to suggest a method that resembles the tail recursive linear search algorithm. You'll need to design a helper method to solve this problem using this approach.

\exercise{2}{chapter-arrays-collections}{Design the \ttt{List<Integer> sumEvenMultOdd(int[] A)} method that, when given an array of integers $A$, returns a \ttt{List<Integer>} whose first element is the sum of all elements at even indices of $A$, and whose second element is the product of all elements at odd indices of $A$. If you encounter a zero at an odd index, do not continue to multiply values (i.e., don't keep multiplying subsequent values and return the multiplied value before you encountered the zero, since the product will forever be zero from that point onward).}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{Set<List<Integer{>}{>} twoSum(int[] A, int t)} method that, when given an array of integers $A$ and a target $t$, returns all possible pairs of numbers in $A$ that sum to $t$. For example, if $A=\{2, 2, 4, 10, 6, -2\}$ and $t=4$, we return a set containing two two-element lists: $\{2, 2\}$ and $\{6, -2\}$. Do not add a pair that already exists in the set or a pair that, by reversing the pair, we get a pair in the existing set. E.g., $\{-2, 6\}$ should not be added to the set. 

There is a simple brute-force algorithm to solve this problem via two loops, but by incorporating a second set for lookups, we can do much better: for every number $n$ in $A$, add $n$ to a set $S$, and if $t-n=m$ for some $m\in{S}$, then we know that $m+n$ must equal $t$, therefore we add $\{n, m\}$ to the resulting set of integer arrays.}
Walking through this with the example from before, we get the following sequence of actions:

\begin{itemize}
    \item Initialize $S=\{\}$ and $L=\{\}$. We know that $t=4$.
    \item We add $2$ to $S$. $S=\{2\}$.
    \item Because $4-2\in{S}$, the two-element array $\{2, 2\}$ is added to $L$. $2$ is not re-added to $S$.
    \item Because $4-4\not\in{S}$, we only add $4$ to $S$. $S=\{2, 4\}$.
    \item Because $4-10\not\in{S}$, we only add $10$ to $S$. $S=\{2, 4, 10\}$.
    \item Because $4-6\not\in{S}$, we only add $6$ to $S$. $S=\{2, 4, 10, 6\}$.
    \item Because $4-(-2)\in{S}$, the two-element array $\{6, -2\}$ is added to $L$. We add $-2$ to $S$. $S=\{2, 4, 10, 6, -2\}$.
\end{itemize}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{ArrayList<String> shift(ArrayList<String> ls, int i)} method that, when given a list of strings $s$ and an index $i$, returns a new list where each element is shifted  by $i$ spots. Negative values correspond to left shifts, and positive values correspond to right shifts. If a shift is nonsensical, do not shift at all. A nonsensical shift is one of the following:}
\begin{itemize}
    \item If there are no elements in the list.
    \item If there is only one element in the list.
    \item If there are only two elements in the list, you only need to shift once. Do the math!
\end{itemize}
    
This method is harder than it may appear at first glance, so write plenty of tests!

\begin{verbnobox}[\small]
shift({11, 12, 13, 14}, -1)          => {12, 13, 14, 11}
shift({120, 120, 140, 140}, 2)       => {140, 140, 120, 120}
shift({99999999}, 1000)              => {99999999}
shift({}, -9999999)                  => {}
shift({120, 80, 70, 50, 40, 20}, -3) => {50, 40, 20, 120, 80, 70}
\end{verbnobox}

\exercise{2}{chapter-arrays-collections}{For this problem you are not allowed to use an \ttt{ArrayList} or any helper methods, e.g., \ttt{.contains}, or methods from the \ttt{Arrays} class. You \textit{may} (and should) use a \ttt{Set<Integer>} to keep track of previously-seen peaks.}

Joe the mountain climber has come across a large mountain range. He wants to climb only the tallest mountains in the range. Design the \ttt{int[] peakFinder(int[] H)} method that returns an array $H'$ of all the peaks in an \ttt{int[]} of mountain heights $H$. A peak $p$ is defined as an element of $h$ at index $i$ such that $p[i - 1] < p[i]$ and $p[i] > p[i + 1]$. If $i = 0$ or $i = |H| - 1$, Joe will not climb $p[i]$. Joe doesn't want to climb a mountain of the same height more than once, so you should not add any peaks that have already been added to $H'$. We present some test cases below.

\begin{verbnobox}[\small]
peakFinder({9, 13, 7, 2, 8})                        => {13}
peakFinder({8, 7, 8, 7, 8, 7, 8, 7})                => {8}
peakFinder({111, 27, 84, 31, 5, 9, 4, 3, 2, 1, 64}) => {84, 9}
peakFinder({})                                      => {}
peakFinder({1})                                     => {}
peakFinder({1, 2})                                  => {}
peakFinder({1, 2, 1})                               => {2}
peakFinder({1, 2, 3, 2, 1})                         => {3}
\end{verbnobox}

\exercise{1}{chapter-arrays-collections}{A professor gives their students extra credit on an exam if they can guess the average within five percent of the actual average. 

Design the \ttt{boolean earnsExtraCredit(List<Double> D, double g)} method that, when given a list of scores $D$ and a guess $g$, returns whether a student is given extra credit.}

\exercise{1}{chapter-arrays-collections}{A village has members where each has a partner. These members are grouped in pairs inside an \ttt{ArrayList<Integer>} where each pair of indices represents a relationship of the village. I.e., \ttt{A.get($2i$)} and \ttt{A.get($2i + 1$)} are in a relationship. A couple is considered the wisest if they have the highest combined age. Design the \ttt{ArrayList<Integer> wisest(ArrayList<Integer> A)} method that, when given a list of (integer) ages $A$, return a new \ttt{ArrayList<Integer>} containing the ages of the wisest pair. If there is a tie, return the pair that has the highest age overall. The order is not significant. We present a few test cases below. You can assume that there will always be an even number of village members.}

\begin{verbnobox}[\small]
wisest({31, 42, 43, 35, 21, 27, 24, 44}) => {43, 35} or {35, 43}
wisest({47, 51, 52, 48, 33, 67, 45, 35}) => {33, 67} or {67, 33}
\end{verbnobox}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{int missingNumber(Set<Integer> s)} method that, when given a set of integers whose values range from $1..n$ with one missing, return the number that is missing. }

\exercise{2}{chapter-arrays-collections}{Design the \ttt{ArrayList<String> tokenize(String s, char d)} method that, when given a string $s$ and a \ttt{char} delimiter $d$, returns an \ttt{ArrayList} of tokens split at the delimiter. You must do this by hand; you \textbf{cannot} call any \ttt{String} methods (except \ttt{.length} and \ttt{.charAt}).}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{HashMap<String, Integer> wordCount(String s)} method that, when given a string $s$, counts the number of words in the list, and stores the results in a \ttt{HashMap<String, Integer>}. Assume that $s$ is not cleaned. That is, you should first remove all punctuation (periods, commas, exclamation points, question marks, semi-colons, dashes, hashes, ampersands, asterisks, and parentheses) from $s$, producing a new string $s'$. Then, split the string based on spaces (remember \ttt{tokenize}?), and produce a map of the words to their respective counts. Do not factor case into your total; i.e., \ttt{"fAcToR"} and \ttt{"factor"} count as the same word. The ordering of the returned map is not significant.}

\begin{verbnobox}[\small]
String s = "Hello world, the world is healthy, is 
            it not? I certainly agree that the world 
            is #1 and healthy."
wordCount(s) => [{"hello", 1}, {"world", 3}, {"the", 2}
                 {"is", 3}, {"healthy", 2}, {"it", 1},
                 {"i", 1}, {"certainly", 1} {"agree", 1}
                 {"that", 1}, {"1", 1}, {"and", 1}, {"not", 1}]
\end{verbnobox}

\exercise{3}{chapter-arrays-collections}{Design the \ttt{LinkedHashSet<String>largeToSmall(HashMap<String, Integer> M)} method that, when given a \ttt{HashMap<String, Integer>} $M$, returns a \ttt{LinkedHashSet} of \ttt{String} values where the words are inserted into the set in order of decreasing count. Words that have the same count do not need to be inserted in any particular order. E.g., \ttt{"is"} may come before \ttt{"world"}. You cannot sort $M$. Hint: create an array of size $c$ (where $c$ is the highest word count) where each element is a \ttt{LinkedHashSet<String>}. For every element $e$ in $M$, add $e$ to the set at index $M[i]$, where $i$ is the count of $e$ in $M$. Then, append these sets in reverse order according to their index. We provide some pseudocode below.}

\begin{verbnobox}[\small]
largeToSmall(M):
  // |M| is M.size().
  c = Get Highest Count Word in M
  array = [0 .. c-1]
  for i in [0 .. c-1]:
    array[i] = new LinkedHashSet<String>();

  for every key k in M:
    i = M.get(k)
    array[i-1].add(k)

  // Append all linkedhashsets in reverse order.
  return array[c-1] appended to array[c-2] ... appended to array[0]
\end{verbnobox}
    
\begin{verbnobox}[\small]
largeToSmall(wordCount(s)) => {"world", "is", "the", "healthy", 
                               "hello", "it", "i", "certainly", 
                               "agree", "that", "1", "and", "not"}
\end{verbnobox}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{LinkedList<Integer> pushLast(LinkedList<Integer> lon, int v)} method that, when given a \ttt{LinkedList<Integer>} $l$ and an \ttt{int} $v$, returns a newly-instantiated \ttt{LinkedList<Integer>} with the same elements plus $v$ added to the end of $l$.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{LinkedList<Integer> set(LinkedList<Integer> l, int v, int i)} method that, when given a \ttt{LinkedList<Integer>} $l$, an \ttt{int} $v$, and an index $i$, returns a \textit{new} \ttt{LinkedList<Integer>} with the same elements, except that the element at index $i$ is, instead, the value $v$. If $i$ is less than zero or exceeds the length of $l$, return \ttt{null}.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{int[] toArray(LinkedList<Integer> l)} method, which receives a linked list of integers $l$, returns an array containing the values from $l$.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{LinkedList<Integer> reverse(LinkedList<Integer> l)} method that, when given a linked list of integers $l$, returns a \textit{new} linked list containing the elements of $l$, but reversed.}

\exercise{2}{chapter-arrays-collections}{Design the \texttt{HashSet<Integer> moreThanThree(int[] A)} method that, when given an \texttt{int[]} $A$, returns a new \texttt{HashSet\-<Integer>} of values containing those values from $A$ that occur strictly more than three times.}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{List<String> collectComments(String s)} method that, when given a string representing a (valid) Java program, returns an list containing all comments from the input program string. You cannot use any \ttt{String} helper methods (e.g., \ttt{strip}, \ttt{split}) to solve this problem nor can you use regular expressions.}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{List<String> removeSideBySideDups(List<String> ls)} that receives a list of strings, returns a new list where all side-by-side duplicates are removed.}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{boolean isPalindromeList(LinkedList<Integer> ls)} method, which receives a linked list of integers, determines if it is a palindrome list. You cannot use \ttt{.get} to solve the problem, nor can you use a \ttt{for} loop. Think about how you can use a \ttt{while} loop, an \ttt{Iterator}, and a \ttt{Stack} to do this.}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{double postfixEvaluator(List<String> l)} method that, when given a list of binary operators and numeric operands represents as strings, returns the result of evaluating the postfix-notation expression. You will need to write a few helper methods to solve this problem, and it is best to break it down into steps. First, write a method that determines if a given string is one of the four binary operators: \ttt{"+"}, \ttt{"-"}, \ttt{"*"}, or \ttt{"/"}. You may assume that any inputs that are not binary operators are operands, i.e., numbers. Then, write a method that applies a given binary operator to a list of operands, i.e., an \ttt{ArrayList<Double>}.}

\begin{verbnobox}[\small]
postfixEvaluator({"5", "2", "*", "5", "+", "2", "+"}) => 17
postfixEvaluator({"1", "2", "3", "4", "+", "+", "+"}) => 10
\end{verbnobox}

\exercise{3}{chapter-arrays-collections}{Design the \ttt{List<List<String>> displayOrders(List<List<String>> orderInfo)} method that, when given an array of orders, returns a series of order specifications by customer table.}

To be more specific, an order is a \ttt{List<String>} whose first element is the customer name, whose second element is the table number, and whose third element is the food that the customer is ordering. 

Return the data as a list of rows of information. The first row displays the table headers. The first table header should be \ttt{"Table"}, followed by the food in alphabetical order. Each successive row represents a table in increasing numerical order. Below is an input and output example.

\begin{verbnobox}[\small]
{{"John", "2", "Chicken"}, {"Samantha", "3", "Pasta"}, 
 {"Tim", "2", "BBQ Chicken"}, {"Christina", "8", "Grilled Cheese"}, 
 {"Tymberlyn", "2", "Chicken"}, {"TJ", "3", "Water"}}
=> 
{{"Table", "BBQ Chicken", "Chicken", "Grilled Cheese", "Pasta", "Water"},
 {"2", "1", "2", "0", "0", "0"},
 {"3", "0", "0", "0", "1", "1"},
 {"8", "0", "0", "1", "0", "0"}}
\end{verbnobox}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{substitute} method that, when given a \ttt{String} $\mathit{exp}$ and an environment $\mathit{env}$ \ttt{HashMap<String, Integer>}, substitutes each occurrence of an ``identifier'' for its value counterpart from the map.}

\begin{verbnobox}[\small]
substitute("f(x) = 3 * a + b", {<"a" : 10>, <"b" : 13>})
           => "f(x) = 3 * 10 + 13"
substitute("g(h, f(x)) = y + x", {<"q" : 200>})          
           => "g(h, f(x)) = y + x" 
\end{verbnobox}

\exercise{3}{chapter-arrays-collections}{Design the \ttt{unifiesAll} method, which receives a \ttt{HashMap<String, Integer>} $M$ of unification assignments and a list of goals \ttt{ArrayList<LinkedList<String>>}} $\mathcal{G}$. Each goal $G \in \mathcal{G}$ is a tuple represented as a \ttt{LinkedList}; goals consist of two values $x, y$, and if it is possible for these to be the same value, then we say we can unify $x$ with $y$. Any successful unifications that occur with variables not present in $M$ should be added to $M$. We present some examples below (assume all values are strings; we omit the quotes out of conciseness). Hint: you might want to write an \ttt{isVar} predicate, which determines if a value is a variable or not, i.e., a value that does not start with a number.

\begin{verbnobox}[\small]
M1 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G1  = {{x, x}, {10, 10}, {z, 15}, {x, w}}
unifiesAll(M1, G1) => true

M2 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G2 = {{x, y}}
unifiesAll(M2, G2) => false

M3 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G3 = {{q, x}, {w, 5}, {q, 5}, {q, w}}
unifiesAll(M3, G3) => true

M4 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G4 = {{q, x}, {q, 10}}
unifiesAll(M4, G4) => false
\end{verbnobox}

\exercise{3}{chapter-arrays-collections}{Two strings $s_1$ and $s_2$ are isomorphic if we can create a mapping from $s_1$ from $s_2$. For example, the strings \ttt{"DCBA"} and \ttt{"ZYXW"} are isomorphic because we can map $D$ to $Z$, $C$ to $Y$, and so forth. Another example is \ttt{"ABACAB"} and \ttt{"XYXZXY"} for similar reasons. A non-example is \ttt{"PROXY"} and \ttt{"ALPHA"}, because once we map \ttt{"A"} to \ttt{"P"}, we cannot create a map between \ttt{"A"} and \ttt{"Y"}. Design the \ttt{boolean isIsomorphic(String s1, String s2)} method, which determines whether or not two strings are isomorphic. }

\exercise{2}{chapter-arrays-collections}{Anagrams are strings that are formed by rearranging the letters of another string. For example, \ttt{"plea"} is an anagram for \ttt{"leap"}, but we consider an alphabetized anagram to be the alphabetized arrangement of letters for an anagram. As an example, \ttt{"aelrst"} is the alphabetized anagram for \ttt{"alerts"}, \ttt{"alters"}, \ttt{"slater"}, and \ttt{"staler"}. Design the \ttt{static Map<String, List<String>> alphaAnagramGroups(List<String> los)} method, which maps all alphabetized anagrams to the strings in $\textit{ls}$ using the above criteria.}
    
\begin{verbnobox}[\small]
los = ["presorting", "plea", "introduces", "anger", "leap", "petals",
       "donate", "plates", "range", "reductions", "rediscount", 
       "tapers", "pale", "atoned", "staple", "repast", "reportings"]
      
alphaAnagramGroups(los) 
  => {{"aegnr", ["anger", "range"]}, 
      {"aelp", ["plea", "leap", "pale"]}, 
      {"aelpst", ["petals", "plates", "staple"]}, 
      {"aeprst", ["tapers", "repast"]}
      {"cdeinorstu", ["introduces", "reductions", "rediscount"]}, 
      {"adenot", ["donate", "atoned"]}, 
      {"eginoprrst", ["presorting", "reportings"]}}
    
\end{verbnobox}

\exercise{2}{chapter-arrays-collections}{A SLC (simplified lambda calculus) expression takes one of the two forms: $\mathit{varList}$ or $\lambda{\mathit{var}}.\mathit{E}$, where $\mathit{var}$ is a lower-case letter from `$u$' to `$z$', $\mathit{varList}$ is a sequence of variables, and $\mathit{E}$ is either a $\mathit{var}$ or another SLC expression. We provide some examples below.}

\begin{align*}
  & \lambda{}x.\lambda{y}.xyz\\
  & \lambda{x}.x\\
  & \lambda{y}.yzxw\\
  & \lambda{w}.\lambda{x}.\lambda{y}.\lambda{z}.z
\end{align*}

Your job is to determine which variables are bound, which are free, and which are neither.

A bound variable is a variable that is bound by a $\lambda$ and occurs in its expression. For example, in the expression $\lambda{x}.x$, `$x$' is bound.

A free variable is a variable that is \textit{not} bound by a $\lambda$ but does occur in an expression. For example, in the expression $\lambda{y}.\lambda{x}.zwv$, `$z$', `$w$', and `$v$' are free variables.

A variable that is neither free nor bound is a variable that is bound by a $\lambda$ but does not occur in its expression. For example, in the expression $\lambda{}x.\lambda{}y.yz$, `$x$' is neither free nor bound.

Design the \ttt{static HashMap<String, String> classifyVars(String E)} method, which returns a map of variables to their classification. We provide some examples below. You may assume that the input is a valid SLC expression and that no variables shadow one another. Use the values \ttt{V}, \ttt{B}, and \ttt{N} to represent free, bound, and neither, respectively.
\begin{alltt}
classifyVars("xyz")       => {<"x" : "F">, <"y" : "F">, <"z" : "F">}
classifyVars("\(\lambda\)x.\(\lambda\)y.xyz") => {<"x" : "B">, <"y" : "B">, <"z" : "F">}
classifyVars("\(\lambda\)x.\(\lambda\)y.x")   => {<"x" : "B">, <"y" : "N">}
\end{alltt}

\exercise{2}{chapter-arrays-collections}{The \textit{substitution cipher} is a text cipher that encodes an alphabet string $A$ (also called the \textit{plain-text alphabet}) with a key string $K$ (also called the \textit{cipher-text alphabet}). The $A$ string is defined as \ttt{"ABCDEFGHIJKLMNOPQRSTUVWXYZ"}, and $K$ is any permutation of $A$. We can encode a string $s$ using $K$ as a mapping from $A$. For example, if $K$ is the string \ttt{"ZEBRASCDFGHIJKLMNOPQTUVWXY"} and $s$ is \ttt{"WE MIGHT AS WELL SURRENDER!"}, the result of encoding $s$ produces \ttt{"VN IDBCY JZ VNHH ZXRRNFMNR!"}

Design the \ttt{subtitutionCipher} method, which receives a plain-text alphabet string $A$, a cipher-text string $K$, and a string $s$ to encode, \ttt{substitutionCipher} should return a string $s'$ using the aforementioned substitution cipher algorithm. You must follow the ``design recipe'' laid out in class. That is, you must write the method purpose statement comment, tests, and the implementation.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{int sumOdd(List<Integer> l)} that, when given a  list of integers, filters out even numbers and then calculates the sum of the remaining odd numbers. You must use the Stream API.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{String conjoin(List<String> los)} method that, when given a list of strings, concatenates all the strings together into a single string, separated by a comma. You must use the Stream API.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{Map<String, Integer> groupLength(List<String> los)} that, when given a list of strings, groups the words by their length and counts how many words are there for each length. This means that the return value should be a \ttt{Map<String, Integer>}. There are a couple of ways to do this, and any way that correctly utilizes the Stream API is fine.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{List<String> addYRemoveYY(List<String> los)} that, when given a list of strings, returns a list where each string has \ttt{"y"} added at its end, omitting any resulting strings that contain \ttt{"yy"} as a substring anywhere. You must use the Stream API.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{List<Integer> sqAddFiveOmit(List<Integer> lon)} that, when given a list of numbers, returns a list of those numbers squared and adds five to the result, omitting any of the resulting numbers that end in $5$ or $6$. You must use the Stream API.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{List<Integer> remvDups(List<Integer> lon)} method, which receives a list of integers, removes all duplicate integers. Return this result as a new list. You must use the Stream API.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{List<String> removeLongerThan(List<String> los, int n)} method, which receives a list of strings, then removes all strings that contain more characters than a given integer~$n$. Return this result as a new list. You must use the Stream API.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{List<Double> filterThenSquare(List<Double> lon)} method, which receives a list of doubles, removes all odd values, and squares the remaining values. Return this result as a new list. You must use the Stream API.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{double filterDoubleAvg(List<Integer> lon)} method that, when given a list of integers, removes all non-prime numbers, doubles each remaining value, and computes the average of said values. Return this result as a \ttt{double} value. You must use the Stream API.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{Optional<Integer> min(List<Integer> lon)} method that, when given a list of integers, returns the minimum value in the list as an \ttt{Optional<Integer>}. If there are no values in the given list, return \ttt{Optional.empty()}. You must use the Stream API.}

\exercise{1}{chapter-arrays-collections}{Design the generic \ttt{<K, V> V lookup(Map<K, V> m)} method that, when given an \ttt{Map<K, V>} $m$ and a value $k$ of type \ttt{K}, returns the corresponding value (of type \ttt{V}) associated with the key $k$. If the key does not exist, return \ttt{null}. You will need to use the \ttt{.equals} method.}

\exercise{1}{chapter-arrays-collections}{Design the generic \ttt{<T> String stringifyList(List<T> l)} method that, when given an list of values $l$, returns a \ttt{String} of comma-separated values where each value is an element of $l$, but converted into a \ttt{String}. You'll need to use the \ttt{.toString} method implementation of the generic type \ttt{T}.}

\exercise{2}{chapter-arrays-collections}{Design the generic \ttt{<T extends Comparable<T>> Optional<T> min(List<T> ls)} method, which receives a list of comparable elements and returns the minimum element in the list. It should return an \ttt{Optional} value of type \ttt{T}, where \ttt{T} is the type of the list. If the list is empty, return an empty \ttt{Optional}. Remember that \ttt{T} must be a type that implements the \ttt{Comparable} interface.}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{<T extends List<Integer>> boolean areParallelLists(T t, T u)} method that, when given two types of lists $t$ and $u$ that store integer values, determines whether or not they are ``parallel.'' In this context, Two integer lists are parallel if they differ by a single constant factor. For example, where $t=\{5, 10, 15, 20\}$ and $u=\{20, 40, 60, 80\}$, $t$ and $u$ are parallel because every element in $t$ multiplied by four gets us a parallel element in $u$. This factorization is bidirectional, meaning that $t$ could be $\{100, 200, 300, 200\}$ and $u$ could be $\{10, 20, 30, 20\}$.}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{<T extends Set<U>, U extends Comparable<U>> boolean areEqualSets(T t, T u)} m\-ethod that, when given two types of sets $t$ and $u$ that store comparable elements, returns whether they are equal to one another. Two sets are equivalent if they are subsets of each other. You must traverse over the sets; you \textbf{cannot} use the built-in \ttt{.equals} method provided by the \ttt{Set} implementations.}
