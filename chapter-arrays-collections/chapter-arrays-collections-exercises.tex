\section*{Chapter Exercises}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{boolean containsOnlyPrime(int[] arr)} method that returns whether or not a given array of integers contains only prime integers. Hint: use the method you wrote in Chapter 2.}

\exercise{1}{chapter-arrays-collections}{This question has two parts.}

\begin{enumerate}[label=(\alph*)]
    \item Design the recursive \ttt{linearSearch} method that, when given a \ttt{String[]} $S$ and a \ttt{String} to search for $k$, returns the index of $k$ in $S$, and \ttt{-1} if $k$ is not in the array. Since this method is definitionally tail recursive, you should write a \ttt{private} helper method that actually performs the recursion.
    \item Design the \ttt{linearSearchLoop} method that solves the problem using a loop. 
\end{enumerate}

\exercise{2}{chapter-arrays-collections}{Write a method that receives an \ttt{int[]} and returns an \ttt{int[]} that corresponds to the accumulated sum between each integer. We present some examples below.}
\begin{verbatim}
accSum({1, 7, 2, 9})                => {1, 8, 10, 19}
accSum({1, 3, 3, 4, 5, 5, 6, 6, 2}) => {1, 4, 7, 11, 16, 21, 27, 33, 35}
accSum({5, 5, 5, 5, 5, 5, 5, 1, 5}) => {5, 10, 15, 20, 25, 30, 35, 36, 41}
\end{verbatim}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{String[] fizzBuzz(int min, int max)} method that iterates over the interval $[min, max]$ (you may assume $max \geq min$) and returns an array containing strings that meet the following criteria:}

    \begin{itemize}
        \item If $i$ is divisible by $3$, insert \ttt{"Fizz"}.
        \item If $i$ is divisible by $5$, insert \ttt{"Buzz"}.
        \item If $i$ is divisible by both $3$ and $5$, insert \ttt{"FizzBuzz"}.
        \item Otherwise, insert \ttt{"i"}, where \ttt{i} is the current number.
    \end{itemize}

    \begin{verbatim}
fizzBuzz(1, 12)  => {"1", "2", "Fizz", "4", "Buzz",
                     "Fizz", "7", "8", "Fizz", "Buzz",
                     "11", "Fizz"}
fizzBuzz(15, 18) => {"FizzBuzz", "16", "17", "Fizz"}
    \end{verbatim}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{double sumYucky(ArrayList<Integer> vals)} method that returns the average of the numbers in the list. Though, the number $9$ should not be counted towards the average, nor should the following number, should one exist.}
\begin{verbatim}
sumYucky({8, 7, 11, 9, 12, 10} => 9.0
sumYucky({120, 99, 9}          => 109.5
sumYucky({9})                  => 0.0
sumYucky({})                   => 0.0
\end{verbatim}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{int[] countEvenOdds(int[] vals)} method that returns a tuple (an array of two values) where index zero stores the amount of even values and index one stores the amount of odd values.}
\begin{verbatim}
countEvenOdds({11, 9, 2, 3, 7, 10, 12, 114} => {4, 4}
countEvenOdds({11, 13, 15, 17})             => {0, 4}
\end{verbatim}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{ArrayList<String> shift(ArrayList<String> ls, int i)} method that, when given a list of strings $s$ and an index $i$, returns a new list where each element is shifted  by $i$ spots. Negative values correspond to left shifts, and positive values correspond to right shifts. If a shift is nonsensical, do not shift at all. A nonsensical shift is one of the following:}
\begin{itemize}
    \item If there are no elements in the list.
    \item If there is only one element in the list.
    \item If there are only two elements in the list, you only need to shift once. Do the math!
\end{itemize}
    
This method is harder than it may appear at first glance, so write plenty of tests!
\begin{verbatim}
shift({11, 12, 13, 14}, -1)          => {12, 13, 14, 11}
shift({120, 120, 140, 140}, 2)       => {140, 140, 120, 120}
shift({99999999}, 1000)              => {99999999}
shift({}, -9999999)                  => {}
shift({120, 80, 70, 50, 40, 20}, -3) => {50, 40, 20, 120, 80, 70}
\end{verbatim}

\exercise{2}{chapter-arrays-collections}{For this problem you are not allowed to use an \ttt{ArrayList} or any helper methods, e.g., \ttt{.contains}, or methods from the \ttt{Arrays} class. You \textit{may} (and should!) use a \ttt{HashSet<Integer>} to keep track of previously-seen peaks.}

Joe the mountain climber has come across a large mountain range. He wants to climb only the tallest mountains in the range. Design the \ttt{peakFinder} method that returns an array $H'$ of all the peaks in an \ttt{int[]} of mountain heights $H$. A peak $p$ is defined as an element of $h$ at index $i$ such that $p[i - 1] < p[i]$ and $p[i] > p[i + 1]$. If $i = 0$ or $i = |H| - 1$, Joe will not climb $p[i]$. Joe doesn't want to climb a mountain of the same height more than once, so you should not add any peaks that have already been added to $H'$. We present some test cases below. Hint: reuse the linear search algorithm from problem 1, except switch the \ttt{String} parameter for integers.

\begin{verbatim}
peakFinder({9, 13, 7, 2, 8})                        => {13}
peakFinder({8, 7, 8, 7, 8, 7, 8, 7})                => {8}
peakFinder({111, 27, 84, 31, 5, 9, 4, 3, 2, 1, 64}) => {84, 9}
peakFinder({})                                      => {}
peakFinder({1})                                     => {}
peakFinder({1, 2})                                  => {}
peakFinder({1, 2, 1})                               => {2}
peakFinder({1, 2, 3, 2, 1})                         => {3}
\end{verbatim}

\exercise{1}{chapter-arrays-collections}{A professor gives their students extra credit on an exam if they can guess the average within five percent of the actual average. Design the \ttt{isGivenExtraCredit} method that, when given an \ttt{ArrayList<Double>} $D$ and a guess $g$, returns whether a student is given extra credit.}

\exercise{1}{chapter-arrays-collections}{A village has members where each has a partner. These members are grouped in pairs inside an \ttt{ArrayList<Integer>} where each pair of indices represents a relationship of the village. I.e., \ttt{A.get($2i$)} and \ttt{A.get($2i + 1$)} are in a relationship. A couple is considered the wisest if they have the highest combined age. Write the \ttt{wisest} method that, when given an \ttt{ArrayList<Integer>} $A$, return a new \ttt{ArrayList<Integer>} containing the ages of the wisest pair. If there is a tie, return the pair that has the highest age overall. The order is not significant. We present a few test cases below. You can assume that there will always be an even number of village members.}

\begin{verbatim}
wisest({31, 42, 43, 35, 21, 27, 24, 44} => {43, 35} or {35, 43}
wisest({47, 51, 52, 48, 33, 67, 45, 35} => {33, 67} or {67, 33}
\end{verbatim}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{tokenize} method that, when given a \ttt{String} $s$ and a \ttt{char} delimiter $d$, returns an \ttt{ArrayList} of tokens split at the delimiter. You must do this by hand; you cannot call any \ttt{String} methods (except \ttt{.length} and \ttt{.charAt}).}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{wordCount} method that, when given a \ttt{String} $s$, counts the number of words in the list. Store the results in a \ttt{HashMap<String, Integer>}. Assume that $s$ is not cleaned. That is, you should first remove all punctuation (periods, commas, exclamation points, question marks, semi-colons, dashes, hashes, ampersands, asterisks, and parentheses) from $s$, producing a new string $s'$. Then, split the string based on spaces (remember \ttt{tokenize}?), and produce a map of the words to their respective counts. Do not factor case into your total; i.e., \ttt{"fAcToR"} and \ttt{"factor"} count as the same word. The ordering of the returned map is not significant.}

\begin{verbatim}
String s = "Hello world, the world is healthy, is 
            it not? I certainly agree that the world 
            is #1 and healthy."
wordCount(s) => [{"hello", 1}, {"world", 3}, {"the", 2}
                 {"is", 3}, {"healthy", 2}, {"it", 1},
                 {"i", 1}, {"certainly", 1} {"agree", 1}
                 {"that", 1}, {"1", 1}, {"and", 1}, {"not", 1}]
\end{verbatim}

\exercise{3}{chapter-arrays-collections}{Design the \ttt{largeToSmall} method that, when given a \ttt{HashMap<String, Integer>} $M$, returns a \ttt{LinkedHashSet} of \ttt{String} values where the words are inserted into the set in order of decreasing count. Words that have the same count do not need to be inserted in any particular order. E.g., \ttt{"is"} may come before \ttt{"world"}. You cannot sort $M$. Hint: create an array of size $c$ (where $c$ is the highest word count) where each element is a \ttt{LinkedHashSet<String>}. For every element $e$ in $M$, add $e$ to the set at index $M[i]$, where $i$ is the count of $e$ in $M$. Then, append these sets in reverse order according to their index. We provide some pseudocode below.}

\begin{verbatim}
largeToSmall(M):
  // |M| is M.size().
  c = Get Highest Count Word in M
  array = [0 .. c-1]
  for i in [0 .. c-1]:
    array[i] = new LinkedHashSet<String>();

  for every key k in M:
    i = M.get(k)
    array[i-1].add(k)

  // Append all linkedhashsets in reverse order.
  return array[c-1] appended to array[c-2] ... appended to array[0]
\end{verbatim}
    
\begin{verbatim}
largeToSmall(wordCount(s)) => {"world", "is", "the", "healthy", 
                               "hello", "it", "i", "certainly", 
                               "agree", "that", "1", "and", "not"}
\end{verbatim}

\exercise{1}{chapter-arrays-collections}{Design the static \ttt{addLast} method that, when given a \ttt{LinkedList<Integer>} $l$ and an \ttt{int} $v$, returns a \textit{new} \ttt{LinkedList<Integer>} with the same elements plus $v$ added to the end of $l$.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{set} method that, when given a \ttt{LinkedList<Integer>} $l$, an \ttt{int} $v$, and an index $i$, returns a \textit{new} \ttt{LinkedList<Integer>} with the same elements, except that the element at index $i$ is, instead, the value $v$. If $i$ is less than zero or exceeds the length of $l$, return \ttt{null}.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{toArray} method that, when given a \ttt{LinkedList<Integer>} $l$ of \ttt{Integer}, returns an array containing the values from $l$.}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{reverse} method that, when given a \ttt{LinkedList<Integer>} $l$, returns a \textit{new} \ttt{LinkedList<Integer>} containing the elements of $l$, but reversed.}

\exercise{2}{chapter-arrays-collections}{Design the \texttt{moreThanThree} method that, when given an \texttt{int[]} $A$, returns a new \texttt{HashSet<Integer>} of values containing those values from $A$ that occur strictly more than three times.}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{collectComments} method that, when given a \ttt{String} containing a (valid) Java program, returns an \ttt{ArrayList<String>} containing all comments from the input program string. You cannot use any \ttt{String} helper methods (e.g., \ttt{strip}, \ttt{split}) to solve this problem nor can you use regular expressions.}

\exercise{2}{chapter-arrays-collections}{Design the \ttt{postfixEvaluator} method that, when given an \ttt{ArrayList<String>} of binary operators and numeric operands, returns the result of evaluating the postfix-notation expression. You will need to write a few helper methods to solve this problem, and it is best to break it down into steps. First, write a method that determines if a given string is one of the four binary operators: \ttt{"+"}, \ttt{"-"}, \ttt{"*"}, or \ttt{"/"}. You may assume that any inputs that are not binary operators are operands, i.e., numbers. Then, write a method that applies a given binary operator to a list of operands, i.e., an \ttt{ArrayList<Double>}.}

\begin{verbatim}
postfixEvaluator({"5", "2", "*", "5", "+"}) => 17
postfixEvaluator({"1", "2", "3", "4", "+"}) => 10
\end{verbatim}

\exercise{1}{chapter-arrays-collections}{Design the \ttt{substitute} method that, when given a \ttt{String} $exp$ and an environment $env$ \ttt{HashMap<String, Integer>}, substitutes each occurrence of an ``identifier'' for its value counterpart from the map.}

\begin{verbatim}
substitute("f(x) = 3 * a + b", {<"a" : 10>, <"b" : 13>})
           => "f(x) = 3 * 10 + 13"
substitute("g(h, f(x)) = y + x", {<"q" : 200>})          
           => "g(h, f(x)) = y + x" 
\end{verbatim}

\exercise{3}{chapter-arrays-collections}{Design the \ttt{unifiesAll} method, which receives a \ttt{HashMap<String, Integer>} $M$ of unification assignments and a list of goals \ttt{ArrayList<LinkedList<String>>}} $\mathcal{G}$. Each goal $G \in \mathcal{G}$ is a tuple represented as a \ttt{LinkedList}; goals consist of two values $x, y$, and if it is possible for these to be the same value, then we say we can unify $x$ with $y$. Any successful unifications that occur with variables not present in $M$ should be added to $M$. We present some examples below (assume all values are strings; we omit the quotes out of conciseness). Hint: you might want to write an \ttt{isVar} predicate, which determines if a value is a variable or not, i.e., a value that does not start with a number.

\begin{verbatim}
M1 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G1  = {{x, x}, {10, 10}, {z, 15}, {x, w}}
unifiesAll(M1, G1) => true

M2 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G2 = {{x, y}}
unifiesAll(M2, G2) => false

M3 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G3 = {{q, x}, {w, 5}, {q, 5}, {q, w}}
unifiesAll(M3, G3) => true

M4 = {<x : 5>, <y : 10>, <z : 15>, <w : 5>}
G4 = {{q, x}, {q, 10}}
unifiesAll(M4, G4) => false
\end{verbatim}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, write a method that takes a \ttt{List<Integer>} and filters out even numbers and then calculates the sum of the remaining odd numbers.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, write a method that, given a \ttt{List<String>}, concatenates all the strings together into a single string, separated by a comma.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, write a method that, given a \ttt{List<String>}, groups the words by their length and counts how many words are there for each length. This means that the return value should be a \ttt{Map<String, Integer>}. There are a couple of ways to do this, and any way that correctly utilizes the Stream API is fine.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, write a method that, given a \ttt{List<String>}, returns a list where each string has \ttt{"y"} added at its end, omitting any resulting strings that contain \ttt{"yy"} as a substring anywhere.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, write a method that, given a \ttt{List<Integer>}, returns a list of those numbers squared and adds ten to the result, omitting any of the resulting numbers that end in $5$ or $6$.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, design the \ttt{removeDups} method that removes all duplicate integers from a given \ttt{ArrayList<Integer>}. Return this result as a new list.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, design the \ttt{removeLongerThan} method that removes all strings that are longer than a given integer $n$, from a given \ttt{ArrayList<String>}. Return this result as a new list.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, design the \ttt{filterThenSquare} method that, when given an \ttt{ArrayList<Double>} $L$, removes all odd values, and squares the remaining values. Return this result as a new list.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, design the \ttt{filterDoubleAvg} method that, when given an \ttt{ArrayList<Integer>} $L$, removes all non-prime numbers, doubles each remaining value, and computes the average of said values. Return this result as a value.}

\exercise{1}{chapter-arrays-collections}{Using the Stream API, design the \ttt{min} method that, when given an \ttt{ArrayList<Integer>} $L$, returns the minimum value in the list. Return this result as an \ttt{Optional<Integer>}. If there are no values in $L$, return \ttt{Optional.empty()}.}


%f(a, b) and f(3, 4) produces {<a : 3>, <b : 4>}
%f(a, a) and f(3, 4) produces {<>}