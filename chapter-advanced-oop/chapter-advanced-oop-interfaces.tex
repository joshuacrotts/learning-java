\section{Interfaces}

Interfaces are a way of grouping classes together by a ubiquitous behavior. We have worked with interfaces before without acknowledging their properties as an interface. For example, the \ttt{Comparable} interface is implemented by classes that can be compared against each other. In particular, there is a single method that must be implemented by any class that implements the \ttt{Comparable} interface: the \ttt{compareTo} method. The \ttt{compareTo} method takes in a single argument of the same type as the class that implements the \ttt{Comparable} interface and returns an integer. Said integer is negative if the object instance is less than the argument, zero if the object instance is equal to the argument, and positive if the object instance is greater than the argument.

So, by having a class implement the \ttt{Comparable} interface, we group it into that subset of classes that are, indeed, comparable. Doing so implies that these classes have an ordering and are sortable in, for example, a Java collection. 

In addition to the \ttt{Comparable} interface, we have worked with the \ttt{List}, \ttt{Queue}, and \ttt{Map} interfaces, which all have a set of methods that must be implemented by any class that implements the interface. Recall that \ttt{ArrayList} and \ttt{LinkedList} are both types of \ttt{List} objects, and this interface describes several methods that all lists, by definition, must override. To \textit{override} a method means that we provide a new implementation of the method that is different from the default implementation provided by the interface.

\subsection*{Defining an Interface}

\example{Imagine that we want to design an interface that describes a shape. All (two-dimensional) shapes have an area and a perimeter, so we can define an interface that, when implemented by a class, requires that the class provide an implementation of the \ttt{area} and \ttt{perimeter} methods. A common convention for user-defined interfaces is to prefix the names with \ttt{I} to distinguish them from classes. Moreover, the names of interfaces are either nouns or, more traditionally, verbs, since they describe behaviors or characteristics of a class.}\footnote{We do not add the \ttt{public} keyword to the interface definition because all interface methods are implicitly public.}

\begin{cl}[IShape.java]{Shape Interface}
\begin{lstlisting}[language=MyJava]
interface IShape {

  double area();

  double perimeter();
}
\end{lstlisting}
\end{cl}

We cannot write any tests for the \ttt{IShape} interface directly, since it is impossible to instantiate an interface. We can, however, write two different classes that implement \ttt{IShape}, and test those. To demonstrate, we will write and test the \ttt{Pentagon} and \ttt{Octagon} classes whose constructors receive (and then store as instance variables) the side length of the shape. Fortunately, the definitions thereof are trivial because they are nothing more than regurgitations of the mathematical formulae. Notice that, when testing, we initialize the object instance to be of type \ttt{IShape}, not \ttt{Pentagon} or \ttt{Octagon}. This is because we want to be able to categorize these classes as types of \ttt{IShape} instances rather than solely instances of \ttt{Pentagon} or \ttt{Octagon} respectively. This is a common practice in object-oriented programming, and it is called \textit{polymorphism}. Polymorphism is the ability of an object to take on many forms. In this case, the \ttt{IShape} interface is the form that the \ttt{Pentagon} and \ttt{Octagon} classes use to take on the form of a shape as we described.

\begin{cl}[IShapeTester.java]{Shape Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class IShapeTester {

  private static final DELTA = 0.01;
  
  @Test
  void testPentagon() {
    IShape p1 = new Pentagon(1);
    IShape p2 = new Pentagon(7.25);
    assertAll(
      () -> assertEquals(1.72, p1.area(), DELTA),
      () -> assertEquals(90.43, p2.area(), DELTA),
      () -> assertEquals(5, p1.perimeter(), DELTA),
      () -> assertEquals(36.25, p2.perimeter(), DELTA), 
    );
  }

  @Test
  void testOctagon() {
    IShape o1 = new Octagon(1);
    IShape o2 = new Octagon(7.25);
    assertAll(
      () -> assertEquals(4.83, o1.area(), DELTA),
      () -> assertEquals(253.79, o2.area(), DELTA),
      () -> assertEquals(8, o1.perimeter(), DELTA),
      () -> assertEquals(58, o2.perimeter(), DELTA), 
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Pentagon.java]{Pentagon Class}
\begin{lstlisting}[language=MyJava]
class Pentagon implements IShape {
  
  private final double SIDE_LENGTH;

  public Pentagon(double sideLength) { this.SIDE_LENGTH = sideLength; }

  @Override
  public double area() {
    return 0.25 * Math.sqrt(5 * (5 + 2 * Math.sqrt(5))) 
                * Math.pow(this.SIDE_LENGTH, 2);
  }

  @Override
  public double perimeter() {
    return 5 * this.SIDE_LENGTH;
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Octagon.java]{Octagon Class}
\begin{lstlisting}[language=MyJava]
class Octagon implements IShape {

  private final double SIDE_LENGTH;

  public Octagon(double sideLength) { this.SIDE_LENGTH = sideLength; }

  @Override
  public double area() {
    return 2 * (1 + Math.sqrt(2)) * Math.pow(this.SIDE_LENGTH, 2);
  }

  @Override
  public double perimeter() {
    return 8 * this.SIDE_LENGTH;
  }
}
\end{lstlisting}
\end{cl}

\example{Recall from the previous chapter our ``Twenty-one'' card game example. In that, we designed the \ttt{Suit} class, which contained four public and static instances of \ttt{Suit}, where each represented one of the four valid card suits. While this works as intended, it fails to be elegant and demonstrate how the suits are all the same, but differ only in their string representation. Let's design the \ttt{ISuit} interface, which requires any implementing class to override the \ttt{stringify} method.}

\begin{cl}[ISuit.java]{Suit Interface Example}
\begin{lstlisting}[language=MyJava]
interface ISuit {

  /**
   * Returns the string representation of the suit.
   */
  String stringify();
}
\end{lstlisting}
\end{cl}

From here, we can define four separate classes, all of which implement \ttt{ISuit} and override the \ttt{stringify} method. These classes are incredibly simple, and as such, we will show only the \ttt{Diamond} and \ttt{Heart} classes.

\begin{cl}[Diamond.java]{Diamond Suit Class}
\begin{lstlisting}[language=MyJava]
class Diamond implements ISuit {
  
  public Diamond() {}

  @Override
  public String stringify() { return "(*;$\diamondsuit$;*)"; }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Heart.java]{Heart Suit Class}
\begin{lstlisting}[language=MyJava]
class Heart implements ISuit {
    
  public Heart() {}

  @Override
  public String stringify() { return "(*;$\heartsuit$;*)"; }
}
\end{lstlisting}
\end{cl}

As we see, both \ttt{Diamond} and \ttt{Heart} implement \ttt{ISuit} and handle ``stringification'' differently. We can test these definitions by storing a list of \ttt{ISuit} instances and ensuring that the correct character is returned.

\begin{cl}[ISuitTester.java]{Suit Interface Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class ISuitTester {

  @Test
  void suitTester() {
    List<ISuit> suit = new ArrayList<>();
    // Add diamonds at even indices, hearts at odd indices.
    for (int i = 0; i < 100; i++) {
      if (i % 2 == 0) { suit.add(new Diamond()); }
      else { suit.add(new Heart()); }
    }

    // Now check to verify that the stringification works.
    for (int i = 0; i < suit.size(); i++) {
      if (i % 2 == 0) { assertEquals("(*;$\diamondsuit$;*)", suit.get(i).stringify()); }
      else { assertEquals("(*;$\heartsuit$;*)", suit.get(i).stringify()); }
    }
  }
}
\end{lstlisting}
\end{cl}

One extra piece of information that we should share is that we can instantiate objects in different ways. To demonstrate why this matters, suppose we initialize an object $s_1$ to type \ttt{ISuit}, but instantiate it as type \ttt{Diamond}. Then, we initialize another object $s_2$ to type \ttt{Diamond} and instantiate it as type \ttt{Diamond}. We would expect that $s_1$ and $s_2$ are equivalent, but this is not the case. Suppose \ttt{Diamond} contains a method \ttt{diamondCount} that does something irrelevant, but belongs solely to the \ttt{Diamond} class. Because $s_1$ is of type \ttt{ISuit}, we cannot invoke the \ttt{diamondCount} method, since \ttt{ISuit} knows nothing about said method. On the contrary, $s_2$ can certainly invoke \ttt{diamondCount}, but it is not polymorphic, since it is not of type \ttt{ISuit}. Should we want to be able to invoke \ttt{diamondCount} on $s_1$, we need to cast $s_1$ to type \ttt{Diamond}. This is called \textit{downcasting}, and it is a common practice in object-oriented programming.

\par{
\begin{verbatim}
ISuit s1 = new Diamond();
s1.diamondCount();             // Compile-time error!
Diamond s2 = new Diamond();
s2.diamondCount();             // Works but not polymorphic.
((Diamond) s1).diamondCount(); // Works but downcasts.
\end{verbatim}
}

\example{Animals are a common example of an interface. Imagine that, in our domain of animals, every animal can speak one way or another. Speaking involves returning a string representing the sound that the animal makes. By designing the \ttt{IAnimal} interface, we can group all animals that can speak together. We can then design classes that implement the \ttt{IAnimal} interface and provide an implementation of the \ttt{speak} method. When testing the latter, we can write tests that instantiate a collection of \ttt{IAnimal} instances, and invoke \ttt{speak} on each of them polymorphically. In doing so we get a refresher of the Java stream API.}

\begin{cl}[IAnimal.java]{Animal Interface}
\begin{lstlisting}[language=MyJava]
interface IAnimal {

  /**
   * Returns the sound that the animal makes.
   */
  String speak();
}
\end{lstlisting}
\end{cl}

\begin{cl}[IAnimalTester.java]{Animal Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class IAnimalTester {
  
  @Test
  void testCat() {
    IAnimal cat = new Cat();
    assertEquals("Meow!", cat.speak());
  }

  @Test
  void testDog() {
    IAnimal dog = new Dog();
    assertEquals("Woof!", dog.speak());
  }

  @Test
  void testListOfAnimals() {
    List<IAnimal> animals = new ArrayList<>();
    animals.add(new Cat());
    animals.add(new Dog());
    animals.add(new Cat());
    assertEquals("[Meow!, Wolf! Meow!]", 
                 animals.stream()
                        .map(IAnimal::speak)
                        .collect(Collectors.toList()));
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Cat.java]{Cat Class}
\begin{lstlisting}[language=MyJava]
class Cat implements IAnimal {

  @Override
  public String speak() {
    return "Meow!";
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Dog.java]{Dog Class}
\begin{lstlisting}[language=MyJava]
class Dog implements IAnimal {

  @Override
  public String speak() {
    return "Woof!";
  }
}
\end{lstlisting}
\end{cl}

% \example{Suppose we want an interface that acts as a CRUD operation. In web-based applications and database systems, CRUD refers to ``create, read, update, and destroy''. In other words, we want to be able to create a new object, read the contents of an object, update the contents of an object, and destroy an object. We can define an interface that requires that any class that implements it provide an implementation of these four methods.}
% \begin{cl}[ICrud.java]{CRUD Interface}
% \begin{lstlisting}[language=MyJava]
% interface ICrud<T> {

%   /**
%     * Creates a new object of type T.
%     */
%   T create();

%   /**
%     * Reads the contents of an object of type T.
%     */
%   void read(T t);

%   /**
%     * Updates the contents of an object of type T.
%     */
%   void update(T t);

%   /**
%     * Destroys an object of type T.
%     */
%   void destroy(T t);
% }
% \end{lstlisting}
% \end{cl}

% What are some examples of classes that we might design that implement the \ttt{ICrud} interface? A coupled example might come from a database system. Suppose we have a database that stores information about students. We might design a \ttt{Student} class that stores the name, ID, and GPA of a student. We can then design a \ttt{Student} class that implements the \ttt{ICrud} interface and provides an implementation of the four methods. The \ttt{Student} class would then be responsible for creating, reading, updating, and destroying \ttt{Student} objects in the database. Along those lines, if we wanted to be able to perform operations on an administrator role, we might design the \ttt{Admin} class that implements \ttt{ICrud}. What these operations do in our toy example is unimportant since we are only concerned with the interface definition. Moreover, we created \ttt{ICrud} as a generic interface, meaning that when we substitute the type into the interface, we propagate the type through the class definition.

% \begin{cl}[Student.java]{Student Class}
% \begin{lstlisting}[language=MyJava]
% class Student implements ICrud<Student> {
  
%   // Instance variables not shown.
  
%   private Student(...) {
%     // Implementation not shown.
%   }
  
%   @Override
%   public Student create() {
%     return new Student(...);
%   }
  
%   @Override
%   public void read(Student s) {
%     System.out.println(s);
%   }
  
%   @Override
%   public void update(Student s) {
%     this.name = s.name;
%     this.id = s.id;
%     this.gpa = s.gpa;
%   }
  
%   @Override
%   public void destroy(Student s) {  s = null;
%   }
  
%   @Override
%   public String toString() {
%     return String.format("Name: %s\nID: %d\nGPA: %.2f", 
%                           this.name, this.id, this.gpa);
%   }
% }
% \end{lstlisting}
% \end{cl}

\example{Suppose we want to design an interface that boxes an arbitrary value. We have seen this idea through autoboxing and autounboxing of the primitive datatypes and the wrapper classes, but our interface extends the concept to any type. We can define an interface that requires that any class that implements it provide an implementation of the \ttt{box}, \ttt{get}, and \ttt{set} methods. Boxing a value means that we can pass it around as a reference rather than as a raw value. Recall that passing primitives to methods is by value and, therefore, the method cannot change the value of the primitive. If, however, we box the primitive, then we can pass the boxed value to a method and change the value of the boxed value. We will first design the generic \ttt{IBox} interface, and then we will design a class that implements the methods.} 

Interestingly, interfaces may have static methods. Our \ttt{IBox} interface has a static \ttt{box} method that returns a box of the type passed in as an argument. This is useful because we can call the \ttt{box} method without having to instantiate a class that implements the \ttt{IBox} interface. We can then use the \ttt{get} and \ttt{set} methods to retrieve and change the value of the box.

\begin{cl}[IBox.java]{Box Interface}
\begin{lstlisting}[language=MyJava]
class IBox<T> {
  
  /**
    * Boxes the value of type T.
    */
  static IBox<T> box(T t);

  /**
    * Returns the boxed value of type T.
    */
  T get();

  /**
    * Sets the boxed value of type T.
    */
  void set(T t);
}
\end{lstlisting}
\end{cl}

\begin{cl}[IBoxTester.java]{Box Tester} 
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class IBoxTester {

  private static <T> void modifyBox(IBox<T> box, T t) {
    box.set(t);
  }
  
  @Test
  void testIntegerBox() {
    IBox<Integer> box = IntegerBox.box(5);
    assertAll(
      () -> assertEquals(5, box.get()),
      () -> modifyBox(box, 10),
      () -> assertEquals(10, box.get())
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[IntegerBox.java]{Integer Box Class}
\begin{lstlisting}[language=MyJava]
class IntegerBox implements IBox<Integer> {
  
  private Integer value;
  
  private IntegerBox(Integer value) { 
    this.value = value; 
  }
  
  @Override
  public static IBox<Integer> box(Integer value) { 
    return new IntegerBox(value); 
  }
  
  @Override
  public Integer get() { 
    return this.value; 
  }
  
  @Override
  public void set(Integer value) { 
    this.value = value; 
  }
}
\end{lstlisting}
\end{cl}

The Java Swing API is a graphics framework for designing graphical interfaces and drawing shapes/images. In addition to these capabilities, it also supports user input through the keyboard, mouse, and other means. Compared to a class like \ttt{Scanner}, which waits for the user to press ``Enter'' when they are finished typing input, the Swing API allows for dynamic input and is constantly monitored by the program. We call the part of the program that listens and processes events an \textit{event listener}. A popular example is the \ttt{ActionListener} interface, which is used to listen for a broad classification of events. The \ttt{ActionListener} interface has a single method, \ttt{actionPerformed}, that is invoked when an event occurs. The \ttt{actionPerformed} method receives an \ttt{ActionEvent} object that contains information about the event that occurred, which is then usable by the method to determine what to do in response to the event. Because graphical interface design goes beyond the scope of this textbook, we will omit a code example, but we mention action listeners to demonstrate that interfaces are not limited to the examples we have seen thus far. Moreover, the Swing API provides more specific listeners for processing keyboard and mouse events, e.g., \ttt{KeyListener}, \ttt{MouseListener}, \ttt{MouseMotionListener}, and so forth. We could, for instance, design a class that implements the \ttt{MouseListener} interface and provides an overriding implementation of the \ttt{mouseClicked} method. Then, inside a Java Swing graphical component, we might hook the class as a mouse listener and, when the user clicks the mouse, the \ttt{mouseClicked} method is invoked.

\example{An amazing insight into the power of interfaces is already present in Java, but deriving it ourselves is useful. Consider the notion of first-class functions: the concept in which functions and data are equivalent, and we can pass functions around as arguments and return them from other functions. In Java, we can pass functions around as arguments, mimicing first-class functions, by designing a \textit{functional interface}.}

Let's design the generic \ttt{Function<T, V>} interface, which quantifies over two types \ttt{T}, representing the input type, and \ttt{V}, representing the output type. The \ttt{Function<T, V>} interface has a single static method, \ttt{apply}, that receives an argument of type \ttt{T} and returns a value of type \ttt{V}. We can then design a class that implements the \ttt{Function<T, V>} interface and provides an implementation of the \ttt{apply} method. We can then pass the class around as an argument to other methods, and invoke the \ttt{apply} method on the class to get the result of the function. An incredibly simple example is \ttt{AddOne}, which implements the \ttt{Function<Integer, Integer>} interface and adds one to its input. We make the constructor of the implementing class private to prevent any unnecessary instantiations; we only want to use the class as a first-class function rather than an object.

\begin{cl}[Function.java]{Functional Interface}
\begin{lstlisting}[language=MyJava]
interface Function<T, V> {

  static V apply(T t); 
}
\end{lstlisting}
\end{cl}

\begin{cl}[AddOneTester.java]{Add One Functional Interface Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class AddOneTester {

  @Test
  void addOneTester() {
    assertAll(
      () -> assertEquals(0, AddOne.apply(1)),
      () -> assertEquals(3, AddOne.apply(2)),
      () -> assertEquals(30001, AddOne.apply(30000)),
    );
  }
}
\end{lstlisting}
\end{cl}
\begin{cl}[AddOne.java]{Add One Functional Interface Implementation}
\begin{lstlisting}[language=MyJava]
class AddOne implements Function<Integer, Integer> {

  private AddOne() {}

  @Override
  public static Integer apply(Integer i) { return i + 1; }
}
\end{lstlisting}
\end{cl}

So far, we have not demonstrated the potential of first-class functions in Java with our design. Suppose we have a list of \ttt{Integer} values $l=v_1, v_2, ..., v_n$ and a function $f$, and we want to apply $f$ to each element thereof. That is, we will create a new list $l'=f(v_1), f(v_2), ..., f(v_n)$. Normally, we would need to write a specific function for each function $f$, but by passing a functional interface, we can write a single method that receives this list and a function $f$ and applies $f$ to each element of the list. This operation, in general, is called \ttt{map}, which we saw during our discussion on streams!\footnote{Do not confuse this with the concept of a map/dictionary from our data structures/collections discussion.}

\begin{cl}[MapTester.java]{Map Function Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class FunctionMapTester {

  @Test
  void testMap() {
    List<Integer> l = List.of(1, 2, 3, 4, 5);
    Function<Integer, Integer> addOne = new AddOne();
    assertAll(
      () -> assertEquals(List.of(2, 3, 4, 5, 6), FunctionMap.map(l, addOne)),
      () -> assertEquals(List.of(), FunctionMap.map(List.of(), addOne))
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[FunctionMap.java]{Map Function Implementation}
\begin{lstlisting}[language=MyJava]
class FunctionMap {

  /**
   * Applies the function f to each element of the list l.
   * 
   * @param l the list of elements.
   * @param f the function to apply to each element.
   * @return the list of elements after applying f to each element.
   */
  public static <T, V> List<V> map(List<T> l, Function<T, V> f) {
    List<V> result = new ArrayList<>();
    for (T t : l) { result.add(f.apply(t)); }
    return result;
  }
}
\end{lstlisting}
\end{cl}

\example{Java 8 introduced the \ttt{Function} interface, so we do not have to design our own version. Using it, we do not need to design a separate \ttt{AddOne} class to implement the interface; we can make use of method referencing via the \ttt{::} operator. Let's rewrite the \ttt{addOne} example doing so. We will also show off the fact that Java will auto-box and unbox an integer primitive into its \ttt{Integer} counterpart, meaning that our \ttt{addOne} method does not need to receive and return objects, but rather primitives instead, which are easier to work with. Moreover, lambda expressions are passable to methods that receive \ttt{Function} arguments, because Java automatically converts them into \ttt{Function} objects, mimicing the autoboxing treatment of primitive datatypes.\footnote{In the tester code snippet below, we could omit the \ttt{FunctionMapTester::} type qualification because the method is defined inside the same class that it is used.}}

\begin{cl}[FunctionMapTester.java]{Map Function Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;
import static FunctionMap.map;

class FunctionMapTester {

  static int addOne(int i) { return i + 1; }

  @Test
  void testMap() {
    List<Integer> l = List.of(1, 2, 3, 4, 5);
    assertAll(
      () -> assertEquals(List.of(2, 3, 4, 5, 6), map(l, FunctionMapTester::addOne)),
      () -> assertEquals(List.of(), map(List.of(), FunctionMapTester::addOne)),
      () -> assertEquals(List.of(2, 3, 4, 5, 6), map(l, i -> i + 1))
      () -> assertEquals(List.of(2, 3, 4, 5, 6), map(List.of(), i -> i + 1))
    );
  }
}
\end{lstlisting}
\end{cl}

\example{Now that we have interfaces, we can write a very simple expression tree interpreter! What do we mean by this? Consider the arithmatic expression $5 + (3 + 4)$. According to the standard order-of-operations, we evaluate the parenthesized sub-expressions first, then reduce outer expressions. So, in our case, we add $3$ and $4$ to get $7$, followed by an addition of $5$. We can represent this idea as an evaluation tree, where we travel from bottom-up, evaluating sub-expressions as they are encountered. How does this relate to interfaces? Suppose we create the \ttt{IExpr} interface, which contains a single method: \ttt{int value}, which returns the value of an expression.}

\begin{cl}[IExpr.java]{Expression Interface}
\begin{lstlisting}[language=MyJava]
interface IExpr {

  /**
   * Returns the value of the expression.
   */
  int value();
}
\end{lstlisting}
\end{cl}

The simplest (atomic) values in our language are numbers, or literals as they are called. A \ttt{Lit} stores a single integer as an instance variable, and returns this instance variable upon a \ttt{value} invocation, which means \ttt{Lit} must implement the \ttt{IExpr} interface. Testing this class is trivial, so we will only write two tests.

\begin{cl}[LitTester.java]{Literal Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class LitTester {

  @Test
  void testLit() {
    assertAll(
      () -> assertEquals(0, new Lit(0).value()),      
      () -> assertEquals(42, new Lit(42).value())
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Lit.java]{Lit Class Implementation}
\begin{lstlisting}[language=MyJava]
class Lit implements IExpr {

  private final int N;

  public Lit(int n) { 
    this.N = n; 
  }

  public int value() { 
    return this.N; 
  }
}
\end{lstlisting}
\end{cl}

How do we add two numbers? Or, rather, how do we represent the addition of two numbers? This question comes through the answer to our question of representing literal values. Addition expressions store two \ttt{IExpr} expressions as instance variables, and (mutually) recursively calls their \ttt{value} methods, followed by a summation. Note the parallelism to how we do this when evaluating expressions either on paper or in our heads.

\begin{cl}[AddTester.java]{Addition Expression Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class AddTester {

  @Test
  void testAdd() {
    assertAll(
      () -> assertEquals(12, new Add(new Lit(5), new Add(new Lit(3), new Lit(4)))),
      () -> assertEquals(42, new Add(new Lit(41), new Lit(1))),
      () -> assertEquals(101, new Add(new Add(new Lit(123), new Lit(-43)),
                                      new Add(new Lit(2), new Lit(19))))
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Add.java]{Addition Expression Implementation}
\begin{lstlisting}[language=MyJava]
class Add implements IExpr {

  private final IExpr LHS;
  private final IExpr RHS;

  public Add(IExpr lhs, IExpr rhs) {
    this.LHS = lhs;
    this.RHS = rhs;
  }

  @Override
  public int value() { return this.LHS.value() + this.RHS.value(); }
}
\end{lstlisting}
\end{cl}

Thus we have a programming language that interprets numbers and addition expressions! We could add more elements/operators to this language, and we encourage the readers to get creative.
  
\example{Recall the \ttt{LinkedList} class from Chapter~\ref{chapter-arrays-collections}. If you have ever wondered how it works under the hood, now is the time to find out! We will design a \textit{doubly-linked list} data structure that stores arbitrarily-typed elements.}

First, remember the structure of a linked list: they are comprised of nodes, which hold the data and a pointer to the next element in the chain/sequence. These types of linked lists are \textit{singly-linked}, because nodes only refer to the successive element. In contrast, our class models a doubly-linked list, since its nodes point to their predecessor and their successor. 

We need a generic class that stores references to the first and last elements of the list. Let's create the \ttt{DoublyLinkedList} class to receive a type parameter \ttt{T} and store the first and last nodes as instance variables. It's important to realize that, whoever uses this class will not be exposed to the innards of the class, i.e., how the links are established/constructed/altered/removed. We wish to preserve the idea of encapsulation, after all.

We run into an eminent problem when declaring the types of the instance variables: what should they be? We need to design a class that encapsulates the value of the node, and holds references to its previous and successor nodes. Some programmers may consider designing a separate \ttt{.java} file for this class, but remember the encapsulation methodology: nobody outside of this class should even be aware that nodes exist in the first place. So, we can create a private and static \ttt{Node<T>} class, which is local to the definition of \ttt{DoublyLinkedList}. A privatized class can only ever be static, because it does not make sense to say that a private class definition belongs to an arbitrary instance of the class in which it resides. We also override the \ttt{toString} to output the underlying stringified data of the node.

\begin{cl}[DoublyLinkedList.java]{Doubly-Linked List Class}
\begin{lstlisting}[language=MyJava]
class DoublyLinkedList<T> {

  private static class Node<T> {

    private T value;
    private Node<T> prev;
    private Node<T> next;

    private Node(T value) { 
      this.value = value; 
    }

    @Override
    public String toString() {
      return this.value.toString();
    }
  }

  private Node<T> head;
  private Node<T> tail;

  public DoublyLinkedList() {
    this.last = this.first = null;
  }
}
\end{lstlisting}
\end{cl}

Notice that, in the constructor of \ttt{DoublyLinkedList}, we assign the first and last references to each other, which both point to \ttt{null}. This is because, when the list is empty, there is no first or last element.

To test the methods that we are about to design, we will override the \ttt{toString} method (of \ttt{DoublyLinkedList}) to print the elements inside brackets, separated by commas and a space. To traverse over the list, however, we should use a custom-defined \ttt{Iterator}, which will be its own localized class definition. We have seen iterators before, but until now we have not implemented one on our own. The idea is, fortunately, very simple: we keep track of the current node, and upon calling \ttt{hasNext}, we return whether or not the node is \ttt{null}. Similarly, invoking \ttt{next} returns the value of the stored node and moves the pointer forward via the ``next'' instance. Finally, we create the \ttt{.iterator} method, which returns an instance of the iterator superclass. We do not want to expose how this particular iterator works, because the caller does not need to be aware of this logic; they are only concerned with iterating over the structure, in this case, a doubly-linked list.

\begin{cl}[DoublyLinkedList.java]{Doubly-Linked List Iterator}
\begin{lstlisting}[language=MyJava]
class DoublyLinkedList<T> {
  // ... previous code omitted ...

  public Iterator<T> iterator() {
    return new DoublyLinkedListIterator<>(this.first);
  }

  private static class DoublyLinkedListIterator<T> implements Iterator<T> {
    
    private Node<T> current;

    private DoublyLinkedListIterator(Node<T> first) {
      this.current = first;
    }

    @Override
    public boolean hasNext() { 
      return this.current != null; 
    }

    @Override
    public T next() {
      T value = this.current.value;
      this.current = this.current.next;
      return value;
    }
  }
}
\end{lstlisting}
\end{cl}

Using the iterator in \ttt{toString} is straightforward: we have a while loop that continues until no more elements are present. We complete two tasks at the same time by having an iterator, which then makes subsequent traversals over the list easier.

Now we can write methods to add, retrieve, and remove elements from the list. To add an elemenet, we need to take the links of \ttt{first} and \ttt{last}, and reassign them accordingly to remain consistent with our doubly-linked list property. If the list is empty, then we just have to assign the new node $n$ to both the \ttt{first} and \ttt{last} references. Otherwise, we set the ``next'' pointer of \ttt{last} to $n$, and set the ``previous'' pointer of $n$ to \ttt{last}. 

\begin{cl}[DoublyLinkedListTester.java]{Testing the Doubly-Linked List Add Method}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class DoublyLinkedListTester {

  @Test
  void testAdd() {
    DoublyLinkedList<Integer> list = new DoublyLinkedList<>();
    assertAll(
      () -> assertEquals("[]", list.toString()),
      () -> list.add(1),
      () -> list.add(2),
      () -> list.add(3),
      () -> assertEquals("[1, 2, 3]", list.toString()),
      () -> list.add(4),
      () -> list.add(1),
      () -> list.add(5),
      () -> assertEquals("[1, 2, 3, 4, 1, 5]", list.toString())
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[DoublyLinkedList.java]{Doubly-Linked List Add Method}
\begin{lstlisting}[language=MyJava]
class DoublyLinkedList<T> {
  // ... previous code omitted ...

  /**
  * Adds a new node to the end of the list.
  *
  * @param data The data to be stored in the new node.
  */
  public void add(T data) {
    Node<T> newNode = new Node<>(data);

    // If the list is empty, make the new node the first and last node.
    if (this.first == null) {
      this.first = newNode;
    } else {
      // Otherwise, add the new node to the end of the list.
      newNode.prev = this.last;
      this.last.next = newNode;
    }
    this.last = newNode;
  }
}
\end{lstlisting}
\end{cl}

Retrieving an element is trivial, as it's just a matter of traversing over the list and returning the data at the index of a node. If the index is out of bounds, we return an empty \ttt{Optional}.\footnote{It is, in general, a better idea to use exceptions, but we have not covered them yet.}

\begin{cl}[DoublyLinkedListTester.java]{Testing the Doubly-Linked List Get Method}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class DoublyLinkedListTester {

  @Test
  void testGet() {
    DoublyLinkedList<Integer> list = new DoublyLinkedList<>();
    assertAll(
      () -> assertEquals(Optional.empty(), list.get(0)),
      () -> list.add(50),
      () -> list.add(25),
      () -> list.add(100),
      () -> assertEquals(Optional.of(50), list.get(0)),
      () -> assertEquals(Optional.of(25), list.get(1)),
      () -> assertEquals(Optional.of(100), list.get(2)),
      () -> assertEquals(Optional.empty(), list.get(3)),
      () -> list.add(1000),
      () -> list.add(10000),
      () -> list.add(50),
      () -> assertEquals(Optional.of(1000), list.get(3)),
      () -> assertEquals(Optional.of(10000), list.get(4)),
      () -> assertEquals(Optional.of(50), list.get(5)),
      () -> assertEquals(Optional.empty(), list.get(6))
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[DoublyLinkedList.java]{Doubly-Linked List Get Method}
\begin{lstlisting}[language=MyJava]
class DoublyLinkedList<T> {
  // ... previous code omitted ...

  /**
   * Returns the element at a given index as an Optional.
    * 
    * @param idx index to retrieve.
    * @return Optional.empty() if the index is out of bounds,
    *         the data at that node's index otherwise.
    */
  public Optional<T> get(int idx) {
    Node<T> curr = this.first;
    int i = 0;
    while (curr != null && i < idx) {
      curr = curr.next;
      i++;
    }
    return idx >= 0 && curr != null
            ? Optional.of(curr.data)
            : Optional.empty();
  }
}
\end{lstlisting}
\end{cl}

Finally we arrive at element removal, which is not as cut-and-dry. We want to pass the element-to-remove (compared via \ttt{equals}), but we need to adjust the pointers accordingly. In particular, there are four cases to consider:

\begin{enumerate}[label=(\alph*)]
  \item If the element-to-remove $e$ is the first of the list, then its successor is now the first. Its previous pointer is adjusted to now point to \ttt{null}.
  \item If the element-to-remove $e$ is the last of the list, then its predecessor is now the last. Its next pointer is adjusted to now point to \ttt{null}.
  \item If the element to remove $e$ is neither the first nor the last, we retrieve its previous node $p$, its next node $n$, and assign $p_\textit{next} = n$, and $n_\textit{prev} = p$. This, in effect, ``delinks'' $e$ from the list, which gets consumed by the garbage collector.
  \item If the element-to-remove $e$ is not in the list, do nothing.
\end{enumerate}

\begin{cl}[DoublyLinkedListTester.java]{Testing the Doubly-Linked List Remove Method}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class DoublyLinkedListTester {

  @Test
  void testRemove() {
    DoublyLinkedList<Integer> list = new DoublyLinkedList<>();
    assertAll(
      () -> list.add(50),
      () -> list.add(25),
      () -> list.add(100),
      () -> list.remove(50),
      () -> assertEquals("[25, 100]", list.toString()),
      () -> list.remove(100),
      () -> assertEquals("[25]", list.toString()),
      () -> list.remove(25),
      () -> assertEquals("[]", list.toString()),
      () -> list.remove(25),
      () -> assertEquals("[]", list.toString())
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[DoublyLinkedList.java]{Doubly-Linked List Remove Method}
\begin{lstlisting}[language=MyJava]
class DoublyLinkedList<T> {
  // ... previous code omitted ...

  /**
   * Removes an element from the linked list, if it exists.
   * @param data value to be removed, compared via .equals.
   */
  public void remove(T data) {
    Node<T> curr = this.first;
    while (curr != null) {
      if (curr.data.equals(data)) {
        // Case 1: if it's the first.
        if (curr == this.first) {
          curr.next = this.first.next;
          this.first = curr.next;
        }
        // Case 2: if it's the last.
        else if (curr == this.last) {
          curr.prev.next = null;
          this.last = curr.prev;
        }
        // Case 3: if it's anything else.
        else {
          curr.prev.next = curr.next;
          curr.next.prev = curr.prev;
        }
        break;
      } else {
        curr = curr.next;
      }
    }
  }
}
\end{lstlisting}
\end{cl}

And that completes the example.

\example{Some programming languages do not come standard with data structures such as \ttt{Map} or, if they do, they are cumbersome to utilize. A substitute for the common mapping data structure is called an \textit{association list}, originating with the Lisp programming language. Its desired purpose is nearly identical to that of a map, but with worse performance implications. In this example we will design such a structure, as if \ttt{Map} did not exist in Java.}

Associations lists, as their name implies, associate values to other values, just like a map. In dynamically-typed languages, e.g., Scheme, association lists accept any type as their key and any type as their value. Therefore, we could have an association list that maps a string to an integer, or an integer to a list of strings, and so on. Should we want to use truly arbitrary types in the list, we can assign \ttt{Object} to both key and value types.

Our association list will support several methods that are related to their functional programming eqiuvalents. In particular, we want a \ttt{lookup} method to retrieve the associated value of some element and an an \ttt{extend} method to add a new association. Note that the \ttt{extend} method will, rather than modifying the current association list, return a new association list with the new association added. This is because we want to preserve the idea of immutability, which is a common theme in functoinal programming. Association lists, therefore, need to have a ``parent'' pointer to keep track of those associations in the list that we extend from.\footnote{In the next section on abstract classes and interpreters, we will revisit this idea in greater detail.} We will also override the \ttt{toString} method to print the associations in a readable format. 

\begin{cl}[AssociationListTester.java]{Association List Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class AssociationListTester {

  @Test
  void testAssociationList() {
    AssociationList<String, Integer> list = new AssociationList<>();
    assertAll(
      () -> assertEquals("[]", list.toString()),
      () -> list = list.extend("a", 1),
      () -> assertEquals("[(a, 1)]", list.toString()),
      () -> list = list.extend("b", 2),
      () -> assertEquals("[(b, 2), (a, 1)]", list.toString()),
      () -> list = list.extend("c", 3),
      () -> assertEquals("[(c, 3), (b, 2), (a, 1)]", list.toString()),
      () -> assertEquals(Optional.of(3), list.lookup("c")),
      () -> assertEquals(Optional.of(2), list.lookup("b")),
      () -> assertEquals(Optional.of(1), list.lookup("a")),
      () -> assertEquals(Optional.empty(), list.lookup("d"))
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[AssociationList.java]{Association List Class}
\begin{lstlisting}[language=MyJava]
class AssociationList<K, V> {
  
  private final K key;
  private final V value;
  private final AssociationList<K, V> parent;
  
  public AssociationList() {
    this.key = null;
    this.value = null;
    this.parent = null;
  }

  private AssociationList(K key, V value, AssociationList<K, V> parent) {
    this.key = key;
    this.value = value;
    this.parent = parent;
  }
  
  /**
   * Returns the value associated with a given key.
   * 
   * @param key the key to lookup.
   * @return the value associated with the key, if it exists.
   */
  public Optional<V> lookup(K key) {
    AssociationList<K, V> curr = this;
    while (curr != null) {
      if (curr.key.equals(key)) {
        return Optional.of(curr.value);
      } else {
        curr = curr.parent;
      }
    }
    return Optional.empty();
  }
  
  /**
   * Adds a new association to the list.
   * 
   * @param key the key to associate.
   * @param value the value to associate.
   * @return a new association list with the new association.
   */
   public AssociationList<K, V> extend(K key, V value) {
    return new AssociationList<>(key, value, this);
   }
  
  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("[");
    AssociationList<K, V> curr = this;
    while (curr != null) {
      sb.append(String.format("(%s, %s)", curr.key, curr.value));
      curr = curr.parent;
      if (curr != null) { sb.append(", "); }
    }
    sb.append("]");
    return sb.toString();
  }
}
\end{lstlisting}
\end{cl}

Each association list in our representation stores exactly one association. Each time we extend the association, we create a new list that points to the previous list. This is a very inefficient way to store associations, but it is a common functional way of extending bindings in a programming language, most often in simple interpreted languages.