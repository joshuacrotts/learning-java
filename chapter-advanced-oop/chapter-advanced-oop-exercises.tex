\section*{Chapter Exercises}
\addcontentsline{toc}{section}{Exercises}

\exercise{2}{chapter-advanced-oop}{Design the generic static method \ttt{T validateInput(String prompt, String errResp, U extends Predicate<T> p)} that receives a prompt, an error response, and an object that implements the \ttt{Predicate} interface to test whether or not the received value, received through standard input, is valid. If the value is invalid according to the predicate, print the error response and re-prompt the user. Otherwise, return the entered value.}

\exercise{3}{chapter-advanced-oop}{A \textit{lazy list} is one that, in theory, produces infinite results! Consider the \ttt{ILazyList} interface below:}
\begin{cl}[ILazyList.java]{}
\begin{lstlisting}[language=MyJava]
public interface ILazyList {
  double next();
}
\end{lstlisting}
\end{cl}

When calling \ttt{next} on a lazy list, we update the contents of the lazy list and return the next result. For instance, below is a lazy list that produces factorial values:\footnote{We will ignore the intricacies that come with Java's implementation of the \ttt{int} datatype. To make this truly infinite, we could use \ttt{BigInteger}.}
\begin{cl}[FactorialLazyList.java]{}
\begin{lstlisting}[language=MyJava]
class FactorialLazyList implements ILazyList {

  private int n;
  private int fact;
 
  public FactorialLazyList() {
    this.n = 1;
    this.fact = 1;
  }

  @Override
  public double next() {
    this.fact *= this.n;
    this.n++;
    return this.fact;
  }
}
\end{lstlisting}
\end{cl}

Testing it with ten calls to \ttt{next} yields predictable results.

\begin{cl}[FactorialLazyListTester.java]{Testing Fact Lazy List}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class FactorialLazyListTester {

  private final ILazyList FS = new FactorialLazyList();

  @Test
  void testFactorialLazyList() {
    assertAll(
      () -> assertEquals(1.0, FS.next()),
      () -> assertEquals(2.0, FS.next()),
      () -> assertEquals(6.0, FS.next()),
      () -> assertEquals(24.0, FS.next()),
      () -> assertEquals(120.0, FS.next()),
      () -> assertEquals(720.0, FS.next()),
      () -> assertEquals(5040.0, FS.next()),
      () -> assertEquals(40320.0, FS.next()),
      () -> assertEquals(362880.0, FS.next()),
      () -> assertEquals(3628800.0, FS.next()));
  }
}
\end{lstlisting}
\end{cl}

Design the \ttt{FibonacciLazyList} class, which implements \ttt{ILazyList} and correctly overrides \ttt{next} to produce Fibonacci sequence values. You code should \textit{not} use any loops or recursion. Recall that the Fibonacci sequence is defined as $f(n) = f(n - 1) + f(n - 2)$ for all $n\geq{2}$. The base cases are $f(0) = 0$ and $f(1) = 1$.

\begin{cl}[FibonacciLazyListTester.java]{Testing Fib Lazy List}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class FibonacciLazyListTester {

  private final ILazyList FS = new FibonacciLazyList();

  @Test
  void testFibonacciLazyList() {
    assertAll(
      () -> assertEquals(0.0, FS.next()),
      () -> assertEquals(1.0, FS.next()),
      () -> assertEquals(1.0, FS.next()),
      () -> assertEquals(2.0, FS.next()),
      () -> assertEquals(3.0, FS.next()),
      () -> assertEquals(5.0, FS.next()),
      () -> assertEquals(8.0, FS.next()),
      () -> assertEquals(13.0, FS.next()),
      () -> assertEquals(21.0, FS.next()),
      () -> assertEquals(34.0, FS.next()));
  }
}
\end{lstlisting}
\end{cl}

\exercise{1}{chapter-advanced-oop}{This exercise involves the doubly-linked list we wrote in the chapter.}
Design the \ttt{public int size()} method, which returns the number of elements in the list. You can do this either recursively or with a loop. For better practice, try (and thoroughly test) both implementations.

\exercise{2}{chapter-advanced-oop}{This exercise involves the doubly-linked list we wrote in the chapter.}
Design the \ttt{public void set(int i, T v)} method, which overwrites/assigns, at index $i$, the value $v$. If the provided index is out-of-bounds, do nothing.

\exercise{2}{chapter-advanced-oop}{This exercise involves the doubly-linked list we wrote in the chapter.}
Design the \ttt{public void insert(int i, T v)} method, which inserts the value $v$ at index $i$. As an example, if we insert $4$ into the list $[20, 5, 100, 25]$ at index $2$, the list then becomes $[20, 5, 4, 100, 25]$. If the provided index is out-of-bounds, do nothing.

\exercise{1}{chapter-advanced-oop}{This exercise involves the interpreter we wrote in the chapter.}
Add the \ttt{"read-number"} and \ttt{"print"} primitive operations to the language. The latter is polymorphic, meaning it can print both numbers and booleans.

\exercise{2}{chapter-advanced-oop}{This exercise involves the interpreter we wrote in the chapter.}
Functional programming languages, in general, are a composition of expressions, wherein statements are more of an afterthought. To this end, design the \ttt{BeginNode} abstract syntax tree node, which receives a list of abstract syntax trees. At the interpreter level, the \ttt{BeginNode} should evaluate each of the abstract syntax trees in the list, and return the result of the last one.

\exercise{2}{chapter-advanced-oop}{This exercise involves the interpreter we wrote in the chapter.}
Variables, in our language, are defined and bound exactly once, namely when they are defined within a let node. Though, in imperative programming, it is often crucial to allow variable reassignments. Design the \ttt{SetNode} class, which receives a variable and an abstract syntax tree, and reassigns the variable to the result of the abstract syntax tree. At the interpreter level, the \ttt{SetNode} should evaluate the abstract syntax tree, and reassign the variable to the result in the current environment (and only the current environment). This means that you'll need to modify the \ttt{Environment} class to allow for variable reassignments. Hint: create a \ttt{set} method in the \ttt{Environment} class.

\exercise{2}{chapter-advanced-oop}{This exercise involves the interpreter we wrote in the chapter.} Recursion is nice and intuitive, for the most part. Unfortunately, it is not always the most efficient way to solve a problem. For example, the Fibonacci sequence, as we saw in Chapter~\ref{chapter-crl}, is often defined recursively, but it is much more efficient to define it iteratively (or even with tail recursion). Design the \ttt{WhileNode} class, which receives a condition and an abstract syntax tree, and evaluates the abstract syntax tree until the condition is false. At the interpreter level, the \ttt{WhileNode} should evaluate the condition, and if it is true, evaluate the abstract syntax tree, and repeat until the condition is false. To test your implementation, you will need to combine the \ttt{WhileNode} with both the \ttt{SetNode} and \ttt{BeginNode} classes.

\exercise{3}{chapter-advanced-oop}{This exercise involves the interpreter we wrote in the chapter.} Having to manually update our case analysis on the primitive operator type is cumbersome and prone to mistakes. A better solution would be to store the operator and its corresponding ``handler'' method, i.e., the method that receives the operands and does the logic of the operator. We can do this via a map where the keys are the string operators and the values are functional references to the handlers. Unfortunately, Java does not directly support passing methods as parameters, meaning they are not first-class. Conversely, we can make use of Java's functional interfaces to achieve our goal. Namely, the interface will contain one method: \ttt{Lvalue apply(List<Lvalue> args, Environment env)}, where \ttt{args} is the list of evaluated arguments. We will call the interface \ttt{IFunction} and make it generic, with the first type quantified to a list of \ttt{Lvalue} instances, and the second type quantified to \ttt{Lvalue}. Hopefully, the connection between these quantified types and the signature of \ttt{apply} is apparent. Using the below definition of \ttt{IFunction}, update \ttt{PrimNode} to no longer perform a case analysis in favor of the map. We provide an example of populating the map with the initial operators in a \ttt{static} block.

\begin{cl}[]{Functional Interface for Primitive Operators}
\begin{lstlisting}[language=MyJava]
@FunctionalInterface
interface IFunction<T, R> {
  
  R apply(T t);
}
\end{lstlisting}
\end{cl}

\begin{cl}[PrimNode.java]{Primitive Node Class with Function Map}
\begin{lstlisting}[language=MyJava]
import java.util.Map;
import java.util.HashMap;

class PrimNode extends AstNode {
  
  private static final Map<String, IFunction<List<Lvalue>, Lvalue>> OPERATORS;
  
  static {
    OPERATORS = new HashMap<>();
    // Store the primPlus operator in the map.
    OPERATORS.put("+", this.primPlus);
  }

  // Other details omitted.

  @Override
  public Lvalue eval(Environment env) {
    // TODO.
  }

  /**
   * Evaluates a plus operator.
   */
  private Lvalue primPlus(List<Lvalue> args, Environment env) {
    int result = 0;
    for (Lvalue lv : args) {
      result += lv.getNumberValue();
    }
    return result;
  }
}
\end{lstlisting}
\end{cl}

\exercise{3}{chapter-advanced-oop}{This exercise is multi-part and involves the interpreter we wrote in the chapter.}
\begin{enumerate}[label=(\alph*)]
  \item First, design the \ttt{ProgramNode} class, which allows the user to define a program as a sequence of statements rather than a single expression.
  \item Design the \ttt{DefNode} class, which allows the user to create a global definition. Because we're now working with definitions that do not extend the environment, we should use the set method in environment. When creating a global definition via \ttt{DefNode}, we're expressing the idea that, from that point forward, the (root) environment should contain a binding from the identifier to whatever value it binds.
  \item Design the \ttt{FuncNode} node. We will consider a function definition as an abstract tree node that begins with \ttt{FuncNode}. This node has two parameters to its constructor: a list of parameter (string) identifiers, and a single abstract syntax tree node representing the body of the function. We will only consider functions that return values; void functions do not exist in this language.

  \item Design the \ttt{ApplyNode} class, which applies a function to its arguments. You do not need to consider applications in which the first argument is a non-function. 

  Calling/Invoking a function is perhaps the hardest part of this exercise. Here's the idea, which is synonymous and shared with almost all programming languages: 

  \begin{enumerate}[label=(\roman*)] 
  \item First, evaluate each argument of the function call. This will result in several l-values, which should be stored in a list. 
  \item Convert these to their AST counterparts. 
  \item We then want to create an environment in which the formal parameters are bound to their arguments. Overload the extend method in \ttt{Environment} to now receive a list of string identifiers and a list of (evaluated) AST arguments. Bind each formal to its corresponding AST, and return the extended environment. 
  \item Evaluate the function identifier to get its function definition and convert it to an AST.
  \item Call \ttt{eval} on the function body and pass the new (extended) environment.
  \end{enumerate}
  This seems like a lot of work (because it is), but it means you can write really cool programs, including those that use recursion!
  \par{
\begin{verbatim}
new ProgramNode(
  new DefNode("!", 
    new FuncNode(
      List.of("n"),
      new IfNode(
        new PrimNode("eq?", 
          new VarNode("n"), 
          new NumberNode(0)),
        new NumberNode(1),
        new PrimNode("*", 
          new VarNode("n"), 
          new ApplyNode("!", 
            new PrimNode("-", 
            new VarNode("n"), 
            new NumberNode(1))))
      )
    )),
  new PrimNode("print", new ApplyNode("!", new NumberNode(5)))
)
\end{verbatim}
}
\end{enumerate}

\exercise{3}{chapter-advanced-oop}{This exercise involves the interpreter we wrote in the chapter.}
Data structures are a core and fundamental feature of programming languages. A language without them, or at least one to build others on top of, suffers severely in terms of usability. We will implement a \textit{cons}-like data structure for our interpreter. In functional programming, we often use three operations to act on data structures akin to linked lists: \textit{cons}, \textit{first}, and \textit{rest}, to construct a new list, retrieve the first element, and retrieve the rest of the list respectively. We can inductively define a cons list as follows:

\par{
\begin{verbatim}
A ConsList is one of:
 - new ConsList()
 - new ConsList(x, ConsList)
\end{verbatim}
}

Implement the cons data structure into your interpreter. This should involve designing the \ttt{ConsNode} class that conforms to the aforementioned data definition. Moreover, you will need to update \ttt{PrimNode} to account for the \ttt{first} and \ttt{rest} primitive operations, as well as an \ttt{empty?} predicate, which returns whether or not the cons list is empty. Finally, update the \ttt{Lvalue} class to print a stringified representation of a \ttt{ConsNode}, which amounts to printing each element, separated by spaces, inside of brackets, e.g., \ttt{[$l_0, l_1, ..., l_{n-1}]$}.

\exercise{2}{chapter-advanced-oop}{This exercise involves the interpreter we wrote in the chapter.}
Having to manually type out the abstract syntax tree constructors when writing tests is extremely tedious. Design a \textit{lexer} for the language described by the interpreter. That is, the text is broken up into tokens that are then categorized. For example, \ttt{'('} might become \ttt{OPEN\_PAREN}, \ttt{"lambda"} might become \ttt{SYMBOL}, \ttt{"variable-name"} might become \ttt{SYMBOL}, and \ttt{123.45} might become \ttt{NUMBER}. The output of the lexer is a list of tokens. Part of the trick is to ensure that after reading an open parenthesis, the next token is not grabbed as part of the open parenthesis.

\exercise{3}{chapter-advanced-oop}{This exercise involves the interpreter we wrote in the chapter.}
Design a parser for the language described by the interpreter. The idea is to tokenize a raw string, then parse the tokens to create an abstract syntax tree that represents the program. A good starting point would be to parse \textit{all} parenthesized expressions into what we will call \ttt{SExprNode}, then traverse over the tree to ``correct'' them into their true nodes, e.g., whether they are \ttt{IfNode}, \ttt{LetNode}, and so forth. Realistically, all programs in our language are, at their core, either primitive values or s-expressions.

\exercise{2}{chapter-advanced-oop}{This exercise involves the interpreter we wrote in the chapter.}
The Scheme programming language and its derivatives support \textit{code quotation}, i.e., the ability to convert an evaluable expression into data. As an example, if we evaluate \ttt{new QuoteNode(new VarNode("x"))}, we receive a symbol as the output, rather than the evaluated symbol via environment lookup. Add the \ttt{QuoteNode} class to your interpreter.

\exercise{3}{chapter-advanced-oop}{In this series of exercises, you will design several methods that act on very large natural numbers resembling the \ttt{BigInteger} class. You cannot use any methods from the class, or the class itself.}
In this problem you will design several methods that act on very large \textit{natural numbers} resembling the \ttt{BigInteger} class. You \textit{\textbf{cannot}} use any methods from this class, or the class itself. 

\begin{enumerate}[label=(\alph*)]
    \item Design the \ttt{BigNat} class, which has a constructor that receives a string. The \ttt{BigNat} class stores an \ttt{ArrayList<Integer>} as an instance variable. You will need to convert the given string into said list. Store the digits in reverse order, i.e., the least-significant digit (the ones digit) of the number is the first element of the list.
    \item Override the \ttt{public String toString} method to return a string representation of the \ttt{BigNat} object. 
    % In particular, place commas between the digits where necessary, e.g., \ttt{"1,000"} and \ttt{"12,345,678"}.
    \item Override the \ttt{public BigNat clone} method that returns a new \ttt{BigNat} instance that contains the same number.
    \item Override the \ttt{public boolean equals} method to compare two \ttt{BigNat} values for equality. 
    \item Implement the \ttt{Comparable<BigNat>} interface, and override the \ttt{public int compareTo} method to return the sign of the result of comparing the given \ttt{BigNat} (which we will call $b$) to \ttt{this} \ttt{BigNat} (which we will call $a$). Namely, if $a < b$, return $-1$, if $a > b$, return $1$, otherwise return $0$.
    \item Design the \ttt{public void add} method, which adds a \ttt{BigNat} to \ttt{this} \ttt{BigNat}. The method should not return anything. Note: this problem is harder than it may look at first glance!
    \item Design the \ttt{public void sub} method, which subtracts a \ttt{BigNat} from \ttt{this} \ttt{BigNat}. If the subtrahend (the right-hand side of the subtraction) is greater than the minuend, the result is zero. Over natural numbers, this is called the \textit{monus} operator.
    \item Design the \ttt{public void mul} method, which multiplies a \ttt{BigNat} with \ttt{this} \ttt{BigNat}. Note: remember how we implement multiplication recursively? You shouldn't use recursion for this problem, but what \textit{is} multiplication? Think about the performance implications of this approach. As we will discuss later, it is $\Theta(n^2)$.
    \item Design the \ttt{public void div} method, which divides a \ttt{BigNat} with \ttt{this} \ttt{BigNat}. If the divisor is greater than the dividend, assign the dividend to be zero. If the divisor is zero, do nothing at all. Otherwise, perform integer division. Note: we can implement division recursively. You shouldn't use recursion for this problem, but what \textit{is} division? Think about the performance implications of this approach. As we will discuss later, it is $\Theta(n^2)$.
\end{enumerate}