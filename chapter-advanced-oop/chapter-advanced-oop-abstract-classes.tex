\section{Abstract Classes}

We consider a class to be abstract if it is not representable by any instance. That is, we cannot create an instance of an abstract class. Abstract classes are useful when we want to define a class that is a generalization of other classes, but we do not want to create instances of the generalization.

\example Consider, once again, a hierarchy of animals. There is no such thing as an ``animal'', or something that is solely called an animal. On the other hand, everything that we would categorize as an animal \textit{is} an animal. Therefore it makes sense to say that animals are a generalization of other types of ``sub''-animals. Imagine we want to write an \ttt{Animal} class, where we will say that any animal can speak. The abstract class contains a superfluous constructor as well as an abstract \ttt{speak} method. We define \ttt{speak} as abstract to denote that an animal can speak, but it is nonsensical for \ttt{Animal} to speak. Because it is impossible to instantiate an instance of \ttt{Animal}, it is similarly impossible to reasonably define \ttt{speak}.

\begin{cl}[Animal.java]{Animal Class}
\begin{lstlisting}[language=MyJava]
abstract class Animal {

  public Animal() {} 

  public abstract String speak();
}
\end{lstlisting}
\end{cl}

Let's declare two subclasses: \ttt{Dog} and \ttt{Cat}, representing dogs and cats respectively. A cat can meow via the string \ttt{"Meow!"}, whereas a dog woofs via the string \ttt{"Woof!"}. 

\begin{cl}[Dog.java]{Dog Class}
\begin{lstlisting}[language=MyJava]
class Dog extends Animal {

  public Dog() { super(); }

  @Override
  public String speak() { return "Woof!"; }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Cat.java]{Cat Class}
\begin{lstlisting}[language=MyJava]
class Cat extends Animal {

  public Cat() { super(); }

  @Override
  public String speak() { return "Meow!"; }
}
\end{lstlisting}
\end{cl}

It might seem strange to use an abstract class, since we could write a \ttt{Speakable} interface to do the same logic. The differences between abstract classes and interfaces is a blurry line to beginning Java programmers (and even to some who have been programming for years), but in essence, we use abstract classes when we want to enforce a class hierarchy of ``is-a'' relationships, e.g., a \ttt{Cat} is-a \ttt{Animal}, and a \ttt{Dog} is-a \ttt{Animal}. Moreover, abstract classes can contain non-abstract methods, meaning that a subclass needs not to override such methods. Interfaces, on the other hand, contain only methods that the implementing class must override. In addition to the method distinction, abstract classes may contain instance variables, whereas interfaces may not.\footnote{Both abstract classes and interfaces can contain static methods and variables.}

\example Inheritance is a truly powerful programming language construct, and we will now attempt to describe its beauty through the design of a mini-project. Said mini-project will encompass writing a small programming language. Programming language syntax and semantics, collectively, require a lot of knowledge outside the domain and scope of this text, but we will see that, even with our somewhat limited arsenal of tools, we can construct a fairly powerful programming language. Our language will start off as a recreation of the interpreter from our section on interfaces, but contains modifications to make it more flexible.

Programming language syntax is often broken up into the nodes of an \textit{abstract syntax tree}, which at a quick glance is nothing more than a description of the operations of a language. To begin, we need to describe our programming language capabilities. To keep things simple, our language will contain integers, variables, a few arithmetic operators, and conditionals. It's important to note that, because we are glossing over the innards of lexing and  parsing, all of our tests will exist in the form of abstract syntax trees. We want an abstract AST node class from which every other AST node inherits. Then, we can design purpose-specific nodes that do what we wish. Every abstract syntax tree has a list of children node. We will also define a \texttt{toString} method that will print out the abstract syntax tree in a readable format. Our abstract syntax tree class uses two constructors: one that receives a list of abstract syntax tree nodes, and another that is variadic over the \ttt{AstNode} type. We implement two different constructors for convenience purposes during testing.

Additionally, we want our abstract syntax trees to be evaluable. Because ``evaluable'' describes a behavior of a class, we should throw this into an interface. We want its method, namely \ttt{eval}, to return something of type \ttt{Lvalue} and receive an environment. For the time being, since we do not know what either an \ttt{Lvalue} or an \ttt{Environment} is, we will omit the definition of the interface, but include the overridden method inside \ttt{AstNode}. Notice, however, that we mark \ttt{eval} as \ttt{abstract} inside \ttt{AstNode}. We do so because it is impossible to evaluate an \ttt{AstNode}, since evaluation behavior is dependent on the subclasses and how they interact.

An \ttt{Lvalue} is the left-hand side of the evaluation of an abstract syntax tree. That is, it is the value that a node resolves to after evaluation. As an example, consider an abstract syntax tree that represents a conditional expression. After evaluating the tree, we expect the resulting value to be either the evaluated consequent or the alternative, neither of which are abstract syntax trees themselves. So, we will design a class that encapsulates an abstract syntax tree, and returns the underlying value when prompted. For our programming language, an abstract syntax tree can only resolve to a number or a boolean, since they are the most primitive forms. Because we may need to retrieve the abstract syntax tree of an l-value, we will provide the relevant accessor method. For simplicity, will compare l-values based on their abstract syntax tree string representations.

\begin{cl}[AstNode.java]{Abstract Syntax Tree Class}
\begin{lstlisting}[language=MyJava]
public abstract class AstNode implements Evaluable {

  private final List<AstNode> CHILDREN;  
 
  public AstNode(List<AstNode> children) { this.CHILDREN = children; }

  public AstNode(AstNode... children) { this(List.of(children)); }

  @Override
  public abstract Lvalue eval(Environment env);

  public List<AstNode> getChildren() { return this.CHILDREN; }

  public abstract String toString();
}
\end{lstlisting}
\end{cl}

\begin{cl}[Lvalue.java]{L-value Class}
\begin{lstlisting}[language=MyJava]
class Lvalue {

  private final AstNode VALUE;

  public Lvalue(AstNode value) { this.VALUE = value; }

  public AstNode getAst() { return this.VALUE; }

  public double getNumberValue() { return ((NumberNode) this.VALUE).getValue(); }

  public boolean getBoolValue() { return ((BoolNode) this.VALUE).getValue(); }

  @Override
  public boolean equals(Object o) {
    if (o instanceof Lvalue) { return this.toString().equals(o.toString()); } 
    else { return false; }
  }
}
\end{lstlisting}
\end{cl}

From here, the simplest three abstract syntax tree nodes are \ttt{VarNode}, \ttt{NumberNode}, and \ttt{BoolNode}, corresponding to variables, numbers, and booleans, respectively. Each of these nodes will have a single value, that being the variable name, number, or boolean. The \ttt{eval} methods of the latter two classes return an l-value that wraps themselves, since these values resolve to themselves. The former, that being \ttt{VarNode}, is a little trickier. We must consider what happens when we evaluate a variable in any other programming language. The language looks up the variable identifier in the list of accessible bindings and returns whatever is the corresponding value. This location of bindings is called an environment in the programming languages nomenclature, and generally takes the form of a \ttt{HashMap} data structure. Therefore we can extend the \ttt{HashMap} class in our design of the \ttt{Environment} class. The question now is of what type are the keys and values in our map. Fortunately this is simple to determine; the keys are string identifiers, and the values are their corresponding abstract syntax trees. Our environment representation/class is extremely simple and almost seems superfluous, but in due time we will add more functionality to justify its existence over a simple \ttt{HashMap} instance.

\begin{cl}[Environment.java]{Environment Class Implementation}
\begin{lstlisting}[language=MyJava]
import java.util.HashMap;

class Environment extends HashMap<String, AstNode> {
  
  public Environment() { super(); }
}
\end{lstlisting}
\end{cl}

\begin{cl}[AstTest.java]{Testing Abstract Syntax Tree Tests}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;
import static Assertions.assertAll;

class AstTest {

  @Test
  void testVarNode() {
    assertEquals("x", new VarNode("x").toString());
  }

  @Test
  void testNumberNode() {
    assertEquals("42", new NumberNode("42").toString());
  }

  @Test
  void testBoolNode() {
    assertEquals("true", new BoolNode("true").toString());
    assertEquals("false", new BoolNode("false").toString());
  }  
}
\end{lstlisting}
\end{cl}

\begin{cl}[VarNode.java]{Variable Node}
\begin{lstlisting}[language=MyJava]
class VarNode extends AstNode {

  private final String NAME;

  public VarNode(String name) {
    super();
    this.NAME = name;
  }

  /**
  * Interpret a variable. We look up the variable in the environment and
  * return the value associated with it.
  *
  * @param env The environment in which to interpret the variable.
  * @return The result of the variable lookup after interpretation.
  */
  @Override
  public Lvalue eval(Environment env) {
    String var = this.NAME;
    AstNode res = env.get(var);
    return res.eval(env);
  }

  @Override
  public String toString() { return this.NAME; }
}
\end{lstlisting}
\end{cl}

\begin{cl}[NumberNode.java]{Number Node}
\begin{lstlisting}[language=MyJava]
class NumberNode extends AstNode {

  private final double VALUE;

  public NumberNode(String value) {
    super();
    this.VALUE = Double.parseDouble(value);
  }

  public NumberNode(double value) { this(Double.toString(value)); }

  @Override
  public Lvalue eval(Environment env) { return new Lvalue(this); }

  @Override
  public String toString() { return Double.toString(this.VALUE); }
}
\end{lstlisting}
\end{cl}

\begin{cl}[BoolNode.java]{Boolean Node}
\begin{lstlisting}[language=MyJava]
class BoolNode extends AstNode {

  private final boolean VALUE;

  public BoolNode(String value) {
    super();
    this.VALUE = Boolean.parseBoolean(value);
  }

  public BoolNode(boolean value) { this(Boolean.toString(value)); }

  @Override
  public Lvalue eval(Environment env) { return new Lvalue(this); }

  @Override
  public String toString() { return Boolean.toString(this.VALUE); }
}
\end{lstlisting}
\end{cl}

From here, we arrive at primitive operators via \ttt{PrimNode}. A primitive operator is one akin to addition, subtraction, and so forth. Two additional primitives that we will support are reading an integer from standard input, and printing one to standard output. Primitive operators receive any number of arguments and whose behavior is handled as a case analysis of the \ttt{eval} method. 

\begin{cl}[PrimNode.java]{Primitive Operator Node}
\begin{lstlisting}[language=MyJava]
class PrimNode extends AstNode {

  private final String OP;

  public PrimNode(String op, AstNode... children) {
    super(children);
    this.OP = op;
  }

  /**
   * Interpret a primitive operation.
   *
   * @param env The environment in which to interpret the operation.
   * @return The result of the primitive operation.
   */
  @Override
  public Lvalue eval(Environment env) {
    String op = this.OP;
    // Evaluate each argument before applying the primitive.
    List<Lvalue> operands = this.getChildren().stream()
                                              .map(n -> n.eval(env))
                                              .toList();
    // Each primitive operator is handled differently.
    // For basic things like addition and subtraction, we can simply
    // map the values to their unwrapped types and collect the result.
    return new Lvalue(
      switch (op) {
        case "+" -> new NumberNode(operands.stream()
                .map(Lvalue::getNumberValue)
                .reduce(0.0, Double::sum));
        case "-" -> new NumberNode(primSub(operands));
        case "*" -> new NumberNode(operands.stream()
                .map(Lvalue::getNumberValue)
                .reduce(1.0, (acc, c) -> acc * c));
        case "eq?" ->
                new BoolNode(operands.get(0).equals(operands.get(1)));
        default -> null;
      });
  }

  @Override
  public String toString() {
    return String.format("(%s %s)", this.OP, this.getChildren().toString());
  }
}
\end{lstlisting}
\end{cl}

We need a way of binding variables, so we shall take a hint from functional programming languages via the \ttt{LetNode} class. The \ttt{LetNode} class has three children: a variable name, a value, and a body. The variable name will be a string, with the value and body both being abstract syntax tree nodes. The \ttt{LetNode} class will have a \ttt{toString} method that will return a string in the form of \ttt{(let ([<var> <exp>]) <body>)}. The \ttt{eval} method will evaluate the value, extend the environment with the new binding, and then evaluate the body with the extended environment. To do this, we need to understand what environment extension entails. Reconsidering our \ttt{Environment} class, we know that it extends the \ttt{HashMap} class to designate that environments \textit{are} maps by design. We may be tempted to override the \ttt{set} method in our \ttt{Environment} class to add an identifier binding to the current environment. While this works (and will be a necessity in due time), it means that we can only \textit{modify}, or \textit{change}, the environment, which isn't desired. The alternative approach would be to utilize \textit{environment extension}. That is, create a new environment with the old bindings, followed by an insertion of the new binding. Environment extension brings up the issue of variable scope, because different variables are live at different locations in the program. Consider the following program described by the abstract syntax tree:

\begin{verbatim}
  new LetNode("x", new NumberNode(5), 
   new LetNode("y", new PrimNode("+", new NumberNode(6), new VarNode("x")), 
    new VarNode("y")))
  \end{verbatim}
  
Within the inner-most \ttt{PrimNode} expression, $x$ does not exist in its environment, but it does exist in an environment defined above its scope. So, each environment is itself a store a map of identifiers to abstract syntax trees, but they also contain another \ttt{Environment}. If we are at the ``root level'' of the program, this environment is set to \ttt{null}. Correspondingly, Environment contains two constructors: one that receives a parent environment and another without. As such, we also must override the \ttt{get} method, which looks up a variable in the current list of bindings and, if it does not exist, recursively looks it up in the parent environment. If we reach the root level environment and the variable does not exist, we return a \ttt{null} value. We also override the \ttt{toString} method to print out the environment in a readable format.

\begin{cl}[EnvironmentTester.java]{Environment Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;
import static Assertions.assertAll;

class EnvironmentTester {
  
  @Test
  void testEnvironment() {
    Environment root = new Environment();
    Environment e1 = env.extend("x", new NumberNode(5));
    Environment e2 = env.extend("y", new NumberNode(6));
    assertAll(
      () -> assertEquals(new NumberNode(5), env.get("x")),
      () -> assertEquals(new NumberNode(6), env.get("y")),
      () -> assertEquals(null, env.get("z")),
      () -> assertEquals(null, env.get("x"))
    );
  }
}
\end{lstlisting}
\end{cl}
  
\begin{cl}[Environment.java]{Environment Class}
\begin{lstlisting}[language=MyJava]
import java.util.HashMap;

class Environment extends HashMap<String, AstNode> {

  private final Environment PARENT;

  public Environment() { this(null); }

  public Environment(Environment parent) { this.PARENT = parent; }

  /**
    * Looks up a variable in the current environment.
    * 
    * @param var the variable name.
    * @return the value bound to the variable, or null if it does not exist.
    */
  @Override
  public AstNode get(String var) {
    if (this.containsKey(var)) { return this.get(var); }
    else if (this.PARENT != null) { return this.PARENT.get(var); }
    else { return null; }
  }

  /**
    * Extends the current environment to contain a new variable binding.
    * 
    * @param var the variable name.
    * @param value the value to bind to the variable.
    * @return a new environment with the new binding.
    */
  public Environment extend(String var, AstNode value) {
    Environment env = new Environment(this);
    env.put(var, value);
    return env;
  }
}
\end{lstlisting}
\end{cl} 

Our modified version of the environment allows us to implement local/let bindings in a way that respects parent environments. As one of the exercises of this chapter demonstrate, environment extension helps us when adding user-defined functions.

\begin{cl}[LetNode.java]{Let Node}
\begin{lstlisting}[language=MyJava]
class LetNode extends AstNode {

  private final String VAR;

  public LetNode(String var, AstNode exp, AstNode body) {
    super(exp, body);
    this.VAR = var;
  }

  /**
   * Interpret a let statement. A new environment is introduced in which the
   * let body is evaluated.
   *
   * @param env The environment in which to interpret the let binding.
   * @return The result of the let statement.
   */
  @Override
  public Lvalue eval(Environment env) {
    String var = this.VAR;
    AstNode exp = this.getChildren().get(0);
    AstNode body = return this.getChildren().get(1);

    // Interpret the expression and convert it into its AST.
    AstNode newExp = exp.eval(env).getAst();
    Environment e1 = env.extend(var, newExp);
    return body.eval(e1);
  }

  @Override
  public String toString() {
    AstNode exp = this.getChildren().get(0);
    AstNode body = this.getChildren().get(1);
    return String.format("(let ([%s %s]) %s"), this.VAR, exp.toString(), body.toString());
  }
}
\end{lstlisting}
\end{cl}

Finally we arrive at decision-based nodes. The \ttt{IfNode} class represents a conditional expression rather than a statement. Recall the ternary operator; it resolves to a value, unlike Java's \ttt{if} statement. The \ttt{IfNode} class has three children: a predicate, a consequent, and an alternative. The predicate is an abstract syntax tree that represents a boolean expression, and the consequent and alternative are arbitrary abstract syntax tree nodes. The \ttt{IfNode} class will have a \ttt{toString} method that will return a string of the form \ttt{(if <pred> <conseq> <alt>)}. Its evaluator will evaluate the predicate, and then evaluate either the consequent or alternative depending on the result of the predicate.

\begin{cl}[IfNode.java]{If Node}
\begin{lstlisting}[language=MyJava]
class IfNode extends AstNode {
  
  public IfNode(AstNode predicate, AstNode consequent, AstNode alternative) {
    super(predicate, consequent, alternative);
  }

  /**
  * Interpret an if statement.
  *
  * @param env The environment in which to interpret the if statement.
  * @return The result of the if statement.
  */
  @Override
  public Lvalue eval(Environment env) {
    AstNode pred = this.getChildren().get(0);
    AstNode cons = this.getChildren().get(1);
    AstNode alt = this.getChildren().get(2);

    // Evaluate the predicate, then interpret one way or the other.
    if (pred.eval(env).getBooleanValue()) { return cons.eval(env); } 
    else { return alt.eval(env); }
  }
  
  @Override
  public String toString() {
    AstNode pred = this.getChildren().get(0);
    AstNode cons = this.getChildren().get(1);
    AstNode alt = this.getChildren().get(2);
    return String.format("(if %s %s %s"), pred.toString(), cons.toString(), alt.toString());
  }
}
\end{lstlisting}
\end{cl}

Finally, at long last, we can write some tests! We will store each test in a class called \ttt{InterpTester}, which polymorphically tests the evaluation method of the abstract syntax tree methods. These tests all receive a blank environment representing the global environment. Unfortunately we still have to write the programs as an abstract syntax tree rather than as a program, but the problems of lexing and parsing are reserved for some other time (or perhaps a separate course altogether).

\begin{cl}[InterpTester.java]{Interpreter Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;
  
class InterpTest {
  
  @Test
  void interpret() {
    assertAll(
      () -> assertEquals(new Lvalue(new NumberNode("42")),
                         new NumberNode("42").eval(new Environment())),
      () -> assertEquals(new Lvalue(new NumberNode("42")),
                         new LetNode("x", new NumberNode("42"), new VarNode("x"))
                         .eval(new Environment())),
      () -> assertEquals(new Lvalue(new NumberNode("42")),
                         new PrimNode("+", new NumberNode("1"), new NumberNode("41"))
                         .eval(new Environment())),
      () -> assertEquals(new Lvalue(new NumberNode("42")),
                         new LetNode("x",
                          new NumberNode("1"),
                           new LetNode("y",
                            new NumberNode("41"),
                             new PrimNode("+", new VarNode("x"), new VarNode("y"))))
                         .eval(new Environment())),
      () -> assertEquals(new Lvalue(new NumberNode("42")),
                         new ProgramNode(new DefNode("x", new NumberNode("42")),
                                         new VarNode("x")).eval(new Environment())),
      () -> assertEquals(new Lvalue(new NumberNode("42")),
                         new ProgramNode(new DefNode("x", new NumberNode("1")),
                          new DefNode("y", new NumberNode("41")),
                           new PrimNode("+", new VarNode("x"),
                                             new VarNode("y"))).eval(new Environment())),
      () -> assertEquals(new Lvalue(new NumberNode("42")),
                         new ProgramNode(new DefNode("add1",
                          new FuncNode(List.of("n"),
                           new PrimNode("+",
                            new VarNode("n"),
                            new NumberNode("1")))),
                           new ApplyNode(new VarNode("add1"),
                            new NumberNode("41")))
                         .eval(new Environment())),
      () -> assertEquals(new Lvalue(new NumberNode("42")),
                         new ProgramNode(new DefNode("sub1",
                          new FuncNode(List.of("n"),
                           new PrimNode("-",
                            new VarNode("n"),
                            new NumberNode("1")))),
                           new ApplyNode(new VarNode("sub1"),
                            new NumberNode("43")))
                         .eval(new Environment())),
      () -> assertEquals(new Lvalue(new NumberNode("42")),
                         new ProgramNode(new LetNode("x",
                          new BoolNode(true),
                           new IfNode(new VarNode("x"),
                                      new NumberNode("42"),
                                      new NumberNode("0"))))
                         .eval(new Environment())),
      () -> assertEquals(new Lvalue(new NumberNode("120")),
                         new ProgramNode(
                          new DefNode("!",
                           new FuncNode(List.of("n"),
                            new IfNode(new PrimNode("eq?", new VarNode("n"), 
                                                           new NumberNode("0")),
                             new NumberNode("1"),
                             new PrimNode("*", new VarNode("n"),
                             new ApplyNode(new VarNode("!"),
                              (new PrimNode("-",
                                new VarNode("n"),
                                new NumberNode("1")))))))),
                             new ApplyNode(new VarNode("!"),
                              new NumberNode("5")))
                         .eval(new Environment()))
      );
  }
}
\end{lstlisting}
\end{cl}