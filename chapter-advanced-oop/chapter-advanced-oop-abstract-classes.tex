\section{Abstract Classes}

\example Inheritance is a truly powerful programming language construct, and we will now attempt to describe its beauty through the design of a mini-project. Said mini-project will encompass writing a small programming language. Programming language syntax and semantics, collectively, require a lot of knowledge outside the domain and scope of this text, but we will see that, even with our somewhat limited arsenal of tools, we can construct a fairly powerful programming language. Our language will start off as a recreation of the interpreter from our section on interfaces, but contains modifications to make it more flexible.

Programming language syntax is often broken up into the nodes of an \textit{abstract syntax tree}, which at a quick glance is nothing more than a description of the operations of a language. To begin, we need to describe our programming language capabilities. To keep things simple, our language will contain integers, variables, a few arithmetic operators, and conditionals. It's important to note that, because we are glossing over the innards of lexing and  parsing, all of our tests will exist in the form of abstract syntax trees. We want an abstract AST node class from which every other AST node inherits. Then, we can design purpose-specific nodes that do what we wish. Every abstract syntax tree has two values: a tag and a list of children. The tag is an enumeration that describes the type of node, and the list of children is a list of other abstract syntax tree nodes. We will use the \texttt{enum} construct to define our tags, and we will use a list to store our children. We will also define a \texttt{toString} method that will print out the abstract syntax tree in a readable format. Our abstract syntax tree class uses two constructors: one that receives a list of abstract syntax tree nodes, and another that is variadic over the \ttt{AstNode} type. We implement two different constructors for convenience purposes during testing.

\begin{cl}[AstNode.java]{Abstract Syntax Tree Class}
\begin{lstlisting}[language=MyJava]
public abstract class AstNode {
  public enum Tag {
    VAR, NUMBER, BOOL, PRIM, LET, IF
  }

  private final List<AstNode> CHILDREN;  
  private final Tag TAG;
 
  public AstNode(Tag tag, List<AstNode> children) {
    this.TAG = tag;
    this.CHILDREN = children;
  }

  public AstNode(Tag tag, AstNode... children) {
    this(tag, List.of(children));
  }

  public Tag getTag() { return this.TAG; }

  public List<AstNode> getChildren() { return this.CHILDREN; }

  public abstract String toString();
}
\end{lstlisting}
\end{cl}

From here, the simplest three abstract syntax tree nodes are \ttt{VarNode}, \ttt{NumberNode}, and \ttt{BoolNode}, corresponding to variables, numbers, and booleans, respectively. Each of these nodes will have a single value, that being the variable name, number, or boolean. The \ttt{toString} method for the \ttt{VarNode} will simply return the variable name. The \ttt{toString} method for the \ttt{NumberNode} will return the number. The \ttt{toString} method for the \ttt{BoolNode} will return the boolean value. Testing each method will be as simple as creating a new node and calling the \ttt{toString} method on it, for the time being. In addition to having the constructors that receive strings, we will also write constructors for each of these classes that receive the primitive types themselves, those being \ttt{NumberNode} and \ttt{BoolNode}.

\begin{cl}[AstTest.java]{Testing Abstract Syntax Tree Tests}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;
import static Assertions.assertAll;

class AstTest {

  @Test
  void testVarNode() {
    assertEquals("x", new VarNode("x").toString());
  }

  @Test
  void testNumberNode() {
    assertEquals("42", new NumberNode("42").toString());
  }

  @Test
  void testBoolNode() {
    assertEquals("true", new BoolNode("true").toString());
    assertEquals("false", new BoolNode("false").toString());
  }  
}
\end{lstlisting}
\end{cl}

\begin{cl}[VarNode.java]{Variable Node}
\begin{lstlisting}[language=MyJava]
class VarNode extends AstNode {

  private final String NAME;

  public VarNode(String name) {
    super(Tag.VAR, List.of());
    this.NAME = name;
  }

  public String getName() { return this.NAME; }

  @Override
  public String toString() { return this.NAME; }
}
\end{lstlisting}
\end{cl}

\begin{cl}[NumberNode.java]{Number Node}
\begin{lstlisting}[language=MyJava]
class NumberNode extends AstNode {

  private final double VALUE;

  public NumberNode(String value) {
    super(Tag.NUMBER);
    this.VALUE = Double.parseDouble(value);
  }

  public NumberNode(double value) { this(Double.toString(value)); }

  public double getValue() { return this.VALUE; }

  @Override
  public String toString() { return Double.toString(this.VALUE); }
}
\end{lstlisting}
\end{cl}

\begin{cl}[BoolNode.java]{Boolean Node}
\begin{lstlisting}[language=MyJava]
class BoolNode extends AstNode {

  private final boolean VALUE;

  public BoolNode(String value) {
    super(Tag.BOOL);
    this.VALUE = Boolean.parseBoolean(value);
  }

  public BoolNode(boolean value) { this(Boolean.toString(value)); }

  public boolean getValue() { return this.VALUE; }

  @Override
  public String toString() { return Boolean.toString(this.VALUE); }
}
\end{lstlisting}
\end{cl}

From here, we arrive at primitive operators via \ttt{PrimNode}. A primitive operator is one akin to addition, subtraction, and so forth. Two additional primitives that we will support are reading an integer from standard input, and printing one to standard output. Primitive operators receive any number of arguments and whose behavior is handled by an outside source, e.g., an interpreter. For now, because primitive operations have no semantic significance, we will omit a tester.

\begin{cl}[PrimNode.java]{Primitive Operator Node}
\begin{lstlisting}[language=MyJava]
class PrimNode extends AstNode {

  private final String OP;

  public PrimNode(String op, AstNode... children) {
    super(Tag.PRIM, children);
    this.OP = op;
  }

  public String getOp() { return this.OP; }

  @Override
  public String toString() {
    return "(" + this.OP + " " + this.getChildren().toString() + ")";
  }
}
\end{lstlisting}
\end{cl}

We need a way of binding variables, so we shall take a hint from functional programming languages via the \ttt{LetNode} class. The \ttt{LetNode} class has three children: a variable name, a value, and a body. The variable name will be a string, with the value and body both being abstract syntax tree nodes. The \ttt{LetNode} class will have a \ttt{toString} method that will return a string in the form of \ttt{(let ([<var> <exp>]) <body>)}. Again, because variable assignments have no significance without an interpreter, we will omit a tester.

\begin{cl}[LetNode.java]{Let Node}
\begin{lstlisting}[language=MyJava]
class LetNode extends AstNode {

  private final String VAR;

  public LetNode(String var, AstNode exp, AstNode body) {
    super(Tag.LET, exp, body);
    this.VAR = var;
  }

  public String getVar() { return var; }

  public AstNode getExp() { return this.getChildren().get(1); }

  public AstNode getBody() { return this.getChildren().get(2); }

  @Override
  public String toString() {
    return "(let ([" + this.VAR + " " + this.getExp().toString() + "]) " 
            + this.getBody().toString() + ")";
  }
}
\end{lstlisting}
\end{cl}

Finally we arrive at decision-based nodes. The \ttt{IfNode} class represents a conditional expression rather than a statement. Recall the ternary operator; it resolves to a value, unlike Java's \ttt{if} statement. The \ttt{IfNode} class has three children: a predicate, a consequent, and an alternative. The predicate is an abstract syntax tree that represents a boolean expression, and the consequent and alternative are arbitrary abstract syntax tree nodes. The \ttt{IfNode} class will have a \ttt{toString} method that will return a string of the form \ttt{(if <pred> <conseq> <alt>)}.

\begin{cl}[IfNode.java]{If Node}
\begin{lstlisting}[language=MyJava]
class IfNode extends AstNode {
  
  public IfNode(AstNode predicate, AstNode consequent, AstNode alternative) {
    super(Tag.IF, predicate, consequent, alternative);
  }
  
  public AstNode getPredicate() { return this.getChildren().get(0); }
  
  public AstNode getConsequent() { return this.getChildren().get(1); }
  
  public AstNode getAlternative() { return this.getChildren().get(2); }
  
  @Override
  public String toString() {
    return String.format("(if %s %s %s"), this.getPredicate().toString(),
                                          this.getConsequent().toString(),
                                          this.getAlternative().toString());
  }
}
\end{lstlisting}
\end{cl}

We can, of course, test each and every one of these classes and instances thereof, as well as bundling them together to create a coherent program represented as an abstract syntax tree. What would be cooler, though, is to write an interpreter for the abstract syntax tree! Let's design the \ttt{Interp} class, which stores an abstract syntax tree to interpret, as well as an environment for bindings. What is an environment, you might ask? Environments bind variable identifiers to their values. For example, if we declare a variable $x$ to be $5$, then whenever we reference $x$ in the program in an expression, we want it to resolve to the literal $5$. A perfect data structure for an environment is a \ttt{HashMap}, which maps string identifiers to their abstract syntax tree values. Accordingly, our \ttt{Environment} class will extend the \ttt{HashMap} class to designate that environments \textit{are} maps by design. We may be tempted to override the \ttt{set} method in our \ttt{Environment} class to add an identifier binding to the current environment. While this works (and will be a necessity in due time), it means that we can only modify the environment, which isn't desired. The alternative approach would be to utilize \textit{environment extension}. That is, create a new environment with the old bindings, followed by an insertion of the new binding. Environment extension brings up the issue of variable scope, because different variables are live at different locations in the program. Consider the following program described by the abstract syntax tree:

\begin{verbatim}
new LetNode("x", new NumberNode(5), 
 new LetNode("y", new PrimNode("+", new NumberNode(6), new VarNode("x")), 
  new VarNode("y")))
\end{verbatim}

Within the inner-most \ttt{PrimNode} expression, $x$ does not exist in its environment, but it does exist in an environment defined above its scope. So, each environment is itself a store a map of identifiers to abstract syntax trees, but they also contain another \ttt{Environment}. If we are at the ``root level'' of the program, this environment is set to \ttt{null}. Correspondingly, Environment contains two constructors: one that receives a parent environment and another without. As such, we also must override the \ttt{get} method, which looks up a variable in the current list of bindings and, if it does not exist, recursively looks it up in the parent environment. If we reach the root level environment and the variable does not exist, we return a \ttt{null} value. We also override the \ttt{toString} method to print out the environment in a readable format.

\begin{cl}[EnvironmentTester.java]{Environment Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;
import static Assertions.assertAll;

class EnvironmentTester {
  
  @Test
  void testEnvironment() {
    Environment root = new Environment();
    Environment e1 = env.extend("x", new NumberNode(5));
    Environment e2 = env.extend("y", new NumberNode(6));
    assertAll(
      () -> assertEquals(new NumberNode(5), env.get("x")),
      () -> assertEquals(new NumberNode(6), env.get("y")),
      () -> assertEquals(null, env.get("z")),
      () -> assertEquals(null, env.get("x"))
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Environment.java]{Environment Class}
\begin{lstlisting}[language=MyJava]
import java.util.HashMap;

class Environment extends HashMap<String, AstNode> {
  private final Environment PARENT;

  public Environment() { this(null); }

  public Environment(Environment parent) { this.PARENT = parent; }

  /**
   * Looks up a variable in the current environment.
   * 
   * @param var the variable name.
   * @return the value bound to the variable, or null if it does not exist.
   */
  @Override
  public AstNode get(String var) {
    if (this.containsKey(var)) { return this.get(var); }
    else if (this.PARENT != null) { return this.PARENT.get(var); }
    else { return null; }
  }

  /**
   * Extends the current environment to contain a new variable binding.
   * 
   * @param var the variable name.
   * @param value the value to bind to the variable.
   * @return a new environment with the new binding.
   */
  public Environment extend(String var, AstNode value) {
    Environment env = new Environment(this);
    env.put(var, value);
    return env;
  }
}
\end{lstlisting}
\end{cl}

Now that we have the environments completed, we need to consider what happens after evaluating an abstract syntax tree; i.e., what value is returned. It does not make sense to return an abstract syntax tree, so we must design something different. We will consider any value that returns from an interpretation an \textit{l-value}, which stands for ``left-hand value'', or the value on the left-hand side of an interpretation call. L-values are wrappers for an abstract syntax tree, and can unwrap them as needed by casting the tree into the differing types to extract the various values. For example, if we know that some interpretation results in a number, and we want to use that number, we can write a method that returns the \ttt{double} from inside a \ttt{NumberNode}. This logic also applies to \ttt{BoolNode} values. Of course, there are many times when we want the abstract syntax tree from an l-value rather than its evaluated form (i.e., the l-value in and of itself). For example, consider an \texttt{if} expression inside the conditional of another \texttt{if} expression. 
\begin{verbatim}
new IfNode(new IfNode(new BoolNode(true), 
                      new BoolNode(false), 
                      new BoolNode(true)), 
           new NumberNode(0), 
           new NumberNode(42));
\end{verbatim}
The inner \ttt{if} expression resolves to some l-value that wraps a BoolNode. The outer \ttt{if} expression expects an abstract syntax tree, since that is what our interpretation method requires. Therefore we should write a method that returns the abstract syntax tree associated with the l-value. Finally, l-values need to be comparable, so to simplify our design, we will say that l-values are equal if the string representation of l-values are equal.
\begin{cl}[LvalueTester.java]{L-value Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;
import static Assertions.assertAll;

class LvalueTester {
  
  @Test
  void testLvalue() {
    Lvalue numLval1 = new Lvalue(new NumberNode(5));
    Lvalue numLval2 = new Lvalue(new NumberNode(5));
    Lvalue boolLval = new Lvalue(new BoolNode(true));
    assertAll(
      () -> assertEquals(5, numLval1.getNumberValue()),
      () -> assertEquals(new NumberNode(5), numLval1.getAst()),
      () -> assertTrue(numLval1.equals(numLval2)),
      () -> assertEquals(true, boolLval.getBoolValue()),
      () -> assertEquals(new BoolNode(true), boolLval.getAst()),
      () -> assertFalse(numLval1.equals(boolLval))
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Lvalue.java]{L-value Class}
\begin{lstlisting}[language=MyJava]
class Lvalue {
  private final AstNode VALUE;

  public Lvalue(AstNode value) { this.VALUE = value; }

  public AstNode getAst() { return this.VALUE; }

  public double getNumberValue() { return ((NumberNode) this.VALUE).getValue(); }

  public boolean getBoolValue() { return ((BoolNode) this.VALUE).getValue(); }

  @Override
  public boolean equals(Object o) {
    if (o instanceof Lvalue) {
      return this.toString().equals(o.toString());
    } else {
      return false;
    }
  }
}
\end{lstlisting}
\end{cl}

With everything in-place, we can now design the interpreter itself. Tests are absolutely required and are easy but tedious to design. Regarding the interpreter, we need semantic definitions for every potential node. 

Firstly, numbers and booleans resolve to themselves. Variables are looked up in the environment, and the corresponding value is interpreted and returned. Primitive operations are interpreted by interpreting each of their children, and then performing the operation on the resulting values. Let expressions evaluate the right-hand side of the binding, extend the environment with the new binding, and then interpret the body with the extended environment. If expressions evaluate the conditional, and then interpret the appropriate branch based on the result of the conditional.

Regarding primitive operators, there are dozens upon dozens of primitive operators that our language could support. For now, we will support only four: addition (\ttt{+}), subtraction (\ttt{-}), multiplication \ttt{(*)}, and equality comparisons (\ttt{eq?}).  

\begin{cl}[InterpTester.java]{Interpreter Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertEquals;
import static Assertions.assertAll;

class InterpTester {
  
  @Test
  void testInterpretNumber() {
    assertEquals(new Lvalue(new NumberNode(5)), 
                 new Interp(new NumberNode(5)).interpret());
  }

  @Test
  void testInterpretBool() {
    assertEquals(new Lvalue(new BoolNode(true)), 
                 new Interp(new BoolNode(true)).interpret());
  }

  @Test
  void testInterpretLetBinding() { 
    assertEquals(new Lvalue(new NumberNode(5)), 
                 new Interp(new LetNode("x", new NumberNode(5), 
                                       new VarNode("x"))).interpret());
  }

  @Test 
  void testInterpretPrimitives() {
    assertEquals(new Lvalue(new NumberNode(5)), 
                 new Interp(new PrimNode("+", new NumberNode(2), 
                                              new NumberNode(3))).interpret());
    assertEquals(new Lvalue(new NumberNode(2)), 
                 new Interp(new PrimNode("-", new NumberNode(5), 
                                              new NumberNode(3))).interpret());
    assertEquals(new Lvalue(new NumberNode(6)), 
                 new Interp(new PrimNode("*", new NumberNode(2), 
                                              new NumberNode(3))).interpret());
    assertEquals(new Lvalue(new BoolNode(true)), 
                 new Interp(new PrimNode("eq?", new NumberNode(5), 
                                                new NumberNode(5))).interpret());
    assertEquals(new Lvalue(new BoolNode(false)), 
                 new Interp(new PrimNode("eq?", new NumberNode(5), 
                                                new NumberNode(3))).interpret());
  }

  @Test
  void testInterpretIf() {
    assertEquals(new Lvalue(new NumberNode(0)), 
                 new Interp(new IfNode(new BoolNode(true), 
                                       new NumberNode(0), 
                                       new NumberNode(42))).interpret());
    assertEquals(new Lvalue(new NumberNode(42)), 
                 new Interp(new IfNode(new BoolNode(false), 
                                       new NumberNode(0), 
                                       new NumberNode(42))).interpret());
  }
}
\end{lstlisting}
\end{cl}

Our \ttt{Interp} class constructor receives one value: an abstract syntax tree to interpret. We then instantiate the empty root environment. We will write the \ttt{interpret} method, which calls a \ttt{private} method of the same name, but instead receives an abstract syntax tree and environment. This private method acts as a dispatch on the type of abstract syntax tree, interpreting the node using the semantics described previously.

\begin{cl}[Interp.java]{Interpreter Class}
\begin{lstlisting}[language=MyJava]
class Interp {

  private final AstNode AST;

  private final Environment ENV;

  public Interp(AstNode ast) {
    this.AST = ast;
    this.ENV = new Environment();
  }

  public Lvalue interpret() {
    return this.interpret(this.AST, this.ENV);
  }

  private Lvalue interpret(AstNode ast, Environment env) {
    switch (ast.getTag()) {
      case NUMBER: return new Lvalue(ast);
      case BOOL: return new Lvalue(ast);
      case VAR: return this.interpretVar((VarNode) ast, env); 
      case LET: return this.interpretLet((LetNode) ast, env);
      case IF: return this.interpretIf((IfNode) ast, env);
      case PRIM: return this.interpretPrim((PrimNode) ast, env);
    }
  }
}
\end{lstlisting}
\end{cl}
As we stated, numbers and booleans are simple and resolve to themselves. Variables are looked up in the current environment, and for the time being we will only consider semantically-valid programs, i.e., looking up an undefined variable is not tested. Primitive operations depend on the supplied operator, but is otherwise a reduction/fold over the (evaluated) operands. 
\begin{cl}[Interp.java]{Interpreter Variable, Let, and If Evaluations}
\begin{lstlisting}[language=MyJava]
class Interp {
  // ... other code.

  /**
   * Interprets a variable definition. We perform a lookup on the 
   * variable identifier in the current map.
   * 
   * @param ast the variable node.
   * @param env the current environment. 
   * @return the value bound to the variable.
   */
  private Lvalue interpretVar(VarNode ast, Environment env) {
    return new Lvalue(env.get(ast.getName()));
  }

  /**
  * Interprets a LetNode. We evaluate the right-hand side of the binding,
  * extend the environment with the new binding, and then interpret the body
  * with the extended environment.
  * 
  * @param ast the LetNode.
  * @param env the current environment. 
  * @return the value bound to the variable.
  */
  private Lvalue interpretLet(LetNode ast, Environment env) {
    Lvalue value = this.interpret(ast.getExp(), env);
    Environment newEnv = env.extend(ast.getVar(), value.getAst());
    return this.interpret(ast.getBody(), newEnv);
  }

  /**
  * Interprets an IfNode. We evaluate the predicate and, if it is true,
  * we interpret the consequent. Otherwise, we interpret the alternative.
  * 
  * @param ast the if node.
  * @param env the current environment. 
  * @return the value of the consequent or alternative.
  */
  private Lvalue interpretIf(IfNode ast, Environment env) {
    Lvalue cond = this.interpret(ast.getPredicate(), env);
    if (cond.getBoolValue()) { 
      return this.interpret(ast.getConsequent(), env); 
    } else { 
      return this.interpret(ast.getAlternative(), env); 
    }
  }
}
\end{lstlisting}
\end{cl}

Because primitive operations differ wildly, we use a separate code listing for each primitive operation. Addition, subtraction, and multiplication are all the same: interpret each operand, and then perform the operation on the resulting values. Equality comparisons are fortunately even simpler: we invoke \ttt{.equals} on each l-value and, if one is not equal to the rest, we return a false value. 

\begin{cl}[Interp.java]{Interpreting Primitive Evaluations}
\begin{lstlisting}[language=MyJava]
class Interp {
  // ... other code.

  /**
   * Interprets a primitive operation. A primitive operation is one that
   * is handled by a separate method, e.g., addition, subtraction, eq?, and so forth.
   * 
   * @param ast the primitive node.
   * @param env the current environment.
   * @return the result of the primitive operation.
   */
  private Lvalue interpretPrim(PrimNode ast, Environment env) {
    List<Lvalue> operands = ast.getOperands().stream()
                                             .map(op -> this.interpret(op, env))
                                             .collect(Collectors.toList());
    switch (ast.getOp()) {
      case "+": return this.interpretAdd(operands, env);
      case "-": return this.interpretSub(operands, env);
      case "*": return this.interpretMul(operands, env);
      case "eq?": return this.interpretEq(operands, env);
    }
  }

  private Lvalue interpretAdd(List<Lvalue> operands, Environment env) {
    double sum = 0;
    for (Lvalue d : operands) { sum += d.getNumberValue(); }
    return new Lvalue(new NumberNode(sum));
  }

  private Lvalue interpretSub(List<Lvalue> operands, Environment env) {
    double diff = operands.get(0);
    for (int i = 1; i < operands.size(); i++) { 
      diff -= operands.get(i).getNumberValue(); 
    }
    return new Lvalue(new NumberNode(diff));
  }

  private Lvalue interpretMul(List<Lvalue> operands, Environment env) {
    double prod = 1;
    for (Lvalue d : operands) { prod *= d.getNumberValue(); }
    return new Lvalue(new NumberNode(prod));
  }

  private Lvalue interpretEq(List<Lvalue> operands, Environment env) {
    boolean eq = operands.stream()
                         .allMatch(op -> op.equals(operands.get(0)));
    return new Lvalue(new BoolNode(eq));
  }
}
\end{lstlisting}
\end{cl}
Voil\`a! We have a functioning interpreter for our mini-language. Unfortunately we still have to write the programs as an abstract syntax tree rather than as a program, but the problems of lexing and parsing are reserved for some other time.