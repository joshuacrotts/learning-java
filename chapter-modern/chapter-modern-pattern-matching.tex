\section{Pattern Matching}

Pattern matching is a powerful tool for working with data. It allows the programmer to create temporary bindings for identifiers that match a given pattern. This is useful for extracting data from a data structure, or for testing whether a data structure matches a given pattern. Java added support for pattern matching inside \ttt{switch} expressions in Java 21. Prior to this version, the best that could be done was to use \ttt{instanceof} to test whether an object was an instance of a given class or interface, and then cast the object to that type. Pattern matching is significantly more concise.

\example{Suppose we want to write a method that uses pattern matching to compute the perimeter of an \ttt{IShape}. We can do this by matching on the shape and then computing the perimeter for each type of shape.}

\begin{cl}[PatternMatchingTester.java]{Example of Pattern Matching}
\begin{lstlisting}[language=MyJava]
class PatternMatchingTester {

  @Test
  void patternMatchingTest() {
    IShape circle = new Circle(5);
    IShape rectangle = new Rectangle(5, 10);
    IShape triangle = new Triangle(5);

    assertAll() {
      () -> assertEquals(31.41592653589793, perimeter(circle)),
      () -> assertEquals(30, perimeter(rectangle)),
      () -> assertEquals(15, perimeter(triangle))
    }
  }
}
\end{lstlisting}
\end{cl}

The definitions of \ttt{Rectangle}, \ttt{Circle}, \ttt{Triangle}, and \ttt{IShape} are trivial and have been shown in previous chapters. The \ttt{perimeter} method, which is static inside \ttt{PatternMatching}, is shown below. We return the result of a \ttt{switch} expression, which matches against the possible subtypes of \ttt{IShape}. We create a temporary binding for the identifier \ttt{shape} that is bound to the \ttt{IShape} object passed into the method. This, in effect, casts the \ttt{IShape} to the subtype that is pattern matched, and we can then access the respective public methods and fields of the specific subtype rather than being restricted to only members of the \ttt{IShape} interface.

\begin{cl}[PatternMatching.java]{Pattern Matching}
\begin{lstlisting}[language=MyJava]
class PatternMatching {

  public static double perimeter(IShape shape) {
    return switch (shape) {
      case Rectangle r -> 2 * r.getWidth() + 2 * r.getHeight();
      case Circle c    -> 2 * Math.PI * c.getRadius();
      case Triangle t  -> 3 * t.getSideLength();
      default -> throw new IllegalArgumentException("perimeter: unknown shape " + shape);
    };
  }
}
\end{lstlisting}
\end{cl}

We can also use ``guard expressions'' when constructing patterns to only match a pattern if a condition holds for that pattern.

\example{Suppose that we want to write a factorial method using pattern matching. We can do this by matching on the argument to the factorial method. If the argument is zero, we return one. Otherwise, we return the argument multiplied by the factorial of the argument minus one. We can use a guard expression to ensure that the argument is non-negative.}

\begin{cl}[FactorialTester.java]{Example of Guard Expressions} 
\begin{lstlisting}[language=MyJava]
class FactorialTester {

  @Test
  void factorialTest() {
    assertAll(
      () -> assertEquals(1, factorial(0)),
      () -> assertEquals(1, factorial(1)),
      () -> assertEquals(2, factorial(2)),
      () -> assertEquals(6, factorial(3)),
      () -> assertEquals(24, factorial(4)),
      () -> assertEquals(120, factorial(5))
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Factorial.java]{Factorial}
\begin{lstlisting}[language=MyJava]
class Factorial {

  public static Integer fact(Integer n) {
    return switch (n) {
      case Integer v when v == 0 -> 1;
      case Integer v when v > 0  -> v * fact(v - 1);
      default -> throw new IllegalStateException("fact: unexpected value " + n);
    };
  }
}
\end{lstlisting}
\end{cl}

Notice that we have to use the wrapper class, since Java permits only special types of pattern matching over the primitive data types, and otherwise works with objects. As an example, we could replace the first case with a match against the literal zero, since Java autounboxes the \ttt{Integer} object to a primitive \ttt{int}, e.g., \ttt{case 0 -> 1;}. Unfortunately we cannot use guard expressions over primitives.

\subsection*{Record Types}

Our perimeter pattern matcher is helpful and convenient, but what is not-so-convenient is that we have to write a lot of boilerplate code to design, for example, a class that represents a rectangle. Each subtype of \ttt{IShape} needs instance variables, a constructor, and accessors at a minimum. Moreover, we need to manually extract the fields from the object that is bound by the variable binding. In modern Java, we can utilize \textit{record types}, which are immutable classes whose boilerplate code (as described previously) is generated by the compiler. We can also add our own methods to the record type, but we cannot add instance or static variables.

\example{Using record types, let's write a small interpreter for a simple language that supports arithmetic expressions and boolean expressions. Instead of the interface approach that we took before, we will use records and pattern matching to evaluate the expressions. With this, our interpreter will make use of \ttt{var}: a new keyword for a variable whose type is inferred from the type of the expression on the right-hand side of the assignment operator. This allows us to omit long and complex types such as \ttt{BigDecimal}.} 

\begin{cl}[EvaluatorTester.java]{Testing the Evaluator}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class EvaluatorTest {

  @Test
  void eval() {
    assertAll(
      () -> assertEquals(new BigDecimal("42"),
                         Evaluator.eval(new Number(42))),
      () -> assertEquals(new BigDecimal("42"),
                         Evaluator.eval(new Add(new Number(41), new Number(1))))
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[IExpr.java]{Expression Interface}
\begin{lstlisting}[language=MyJava]
interface IExpr {}
\end{lstlisting}
\end{cl}

\begin{cl}[Number.java]{``Number'' Record Type}
\begin{lstlisting}[language=MyJava]
record Number(BigDecimal value) implements IExpr {
  
  public Number(int value) { this(new BigDecimal(value)); }
}
\end{lstlisting}
\end{cl}

\begin{cl}[Add.java]{``Add'' Record Type}
\begin{lstlisting}[language=MyJava]
interface Add(IExpr left, IExpr right) implements IExpr {}
\end{lstlisting}
\end{cl}

\begin{cl}[Evaluator.java]{Evaluator}
\begin{lstlisting}[language=MyJava]
class Evaluator {

  /**
   * Evaluates a given expression using records and pattern matching.
   *
   * @param exp the expression to evaluate as a subtype IExpr.
   * @return result of evaluating the expression: a BigDecimal.
   */
  public static BigDecimal eval(IExpr exp) {
    return switch (exp) {
      case Number(var n)               -> n;
      case Add   (var left, var right) -> eval(left).add(eval(right));
      default -> throw new IllegalArgumentException("eval: unknown expression " + exp);
    }
  }
}
\end{lstlisting}
\end{cl}

In the interpreter, we pattern match on the constructors of our record types. For example, in the \ttt{eval} method, when pattern matching on the \ttt{Add} constructor. We create temporary bindings for the identifiers \ttt{left} and \ttt{right} that are bound to the respective \ttt{Expr} objects that are passed into the constructor. We then recursively call \ttt{eval} on these objects and add the results together. We do the same for the other constructors of \ttt{Expr}. To make testing the program easier, we designed a secondary constructor for \ttt{Number} that receives an integer and converts it to a \ttt{BigDecimal}. Note that self-defined constructors of a record can only reference other constructors via \ttt{this(...)}.
