\section{Pattern Matching}

Pattern matching is a powerful tool for working with data. It allows the programmer to create temporary bindings for identifiers that match a given pattern. This is useful for extracting data from a data structure, or for testing whether a data structure matches a given pattern. Java added support for pattern matching inside \ttt{switch} expressions in Java 21. Prior to this version, the best that could be done was to use \ttt{instanceof} to test whether an object was an instance of a given class or interface, and then cast the object to that type. Pattern matching is significantly more concise.

\example{Suppose we want to write a method that uses pattern matching to compute the perimeter of an \ttt{IShape}. We can do this by matching on the shape and then computing the perimeter for each type of shape.}

\begin{cl}[]{Example of Pattern Matching}
\begin{lstlisting}[language=MyJava]
class PatternMatchingTester {

  @Test
  void patternMatchingTest() {
    IShape circle = new Circle(5);
    IShape rectangle = new Rectangle(5, 10);
    IShape triangle = new Triangle(5);

    assertAll(
      () -> assertEquals(31.41592653589793, perimeter(circle)),
      () -> assertEquals(30, perimeter(rectangle)),
      () -> assertEquals(15, perimeter(triangle)));
  }
}
\end{lstlisting}
\end{cl}

The definitions of \ttt{Rectangle}, \ttt{Circle}, \ttt{Triangle}, and \ttt{IShape} are trivial and have been shown in previous chapters. The \ttt{perimeter} method, which is static inside \ttt{PatternMatching}, is shown below. We return the result of a \ttt{switch} expression, which matches against the possible subtypes of \ttt{IShape}. We create a temporary binding for the identifier \ttt{shape} that is bound to the \ttt{IShape} object passed into the method. This, in effect, casts the \ttt{IShape} to the subtype that is pattern matched, and we can then access the respective public methods and fields of the specific subtype rather than being restricted to only members of the \ttt{IShape} interface.

\begin{cl}[]{Pattern Matching}
\begin{lstlisting}[language=MyJava]
class PatternMatching {

  /**
   * Computes the perimeter of a given shape.
   * @param shape the IShape whose perimeter to compute.
   * @return the perimeter of the shape.
   */
  public static double perimeter(IShape s) {
    return switch (s) {
      case Rectangle r -> 2 * r.getWidth() + 2 * r.getHeight();
      case Circle c    -> 2 * Math.PI * c.getRadius();
      case Triangle t  -> 3 * t.getSideLength();
      default -> throw new IllegalArgumentException("perimeter: bad shape " + s);
    };
  }
}
\end{lstlisting}
\end{cl}

We can also use ``guard expressions'' when constructing patterns to only match a pattern if a condition holds for that pattern.

\example{Suppose that we want to write a factorial method using pattern matching. We can do this by matching on the argument to the factorial method. If the argument is zero, we return one. Otherwise, we return the argument multiplied by the factorial of the argument minus one. We can use a guard expression to ensure that the argument is non-negative.}

\begin{cl}[]{Example of Guard Expressions} 
\begin{lstlisting}[language=MyJava]
class FactorialTester {

  @Test
  void factorialTest() {
    assertAll(
      () -> assertEquals(1, factorial(0)),
      () -> assertEquals(1, factorial(1)),
      () -> assertEquals(2, factorial(2)),
      () -> assertEquals(6, factorial(3)),
      () -> assertEquals(24, factorial(4)),
      () -> assertEquals(120, factorial(5)));
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[]{Factorial}
\begin{lstlisting}[language=MyJava]
class Factorial {

  public static Integer fact(Integer n) {
    return switch (n) {
      case Integer v when v == 0 -> 1;
      case Integer v when v > 0  -> v * fact(v - 1);
      default -> throw new IllegalStateException("fact: unexpected value " + n);
    };
  }
}
\end{lstlisting}
\end{cl}

Notice that we have to use the wrapper class, since Java permits only special types of pattern matching over the primitive data types, and otherwise works with objects. As an example, we could replace the first case with a match against the literal zero, since Java autounboxes the \ttt{Integer} object to a primitive \ttt{int}, e.g., \ttt{case 0 -> 1;}. Unfortunately we cannot use guard expressions over primitives.

Pattern matching is not restricted to switch-case expressions. We can also use pattern matching in cases where we check the instance of an object, namely in the \ttt{equals} method. As an example, traditional \ttt{equals} methods look like the following:

\par{
\begin{verbatim}
@Override
public boolean equals(Object o) {
  if (o instanceof MyClass) {
    MyClass other = (MyClass) o;
    return this.field1.equals(other.field1) &&
           this.field2.equals(other.field2) &&
           ...
           this.fieldN.equals(other.fieldN);
  } else { return false; }
}
\end{verbatim}
}

The need to cast the object to the type of the class on its own separate line is tedious. Pattern matching allows us to write the \ttt{equals} method in a more concise manner by providing an identifier to the pattern that is bound to the object being tested. We can wrap this in either an \ttt{if} statement or as a logical AND, because the pattern matching expression returns a boolean and fails to match if the object is not an instance of the stated class.

\par{
\begin{verbatim}
@Override
public boolean equals(Object o) {
  return (o instanceof MyClass other)     &&
         this.field1.equals(other.field1) &&
         this.field2.equals(other.field2) &&
         ...
         this.fieldN.equals(other.fieldN);
}
\end{verbatim}
}

\example{Suppose that we want to override the \ttt{equals} method inside \ttt{Rectangle} using pattern matching. It's possible to use an \ttt{if} statement rather than resolving the \ttt{instanceof} check in an expression, but the latter is much more concise and solves the same problem.}

\begin{cl}[]{Rectangle Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class RectangleTester {

  @Test
  void equalsTest() {
    Rectangle r1 = new Rectangle(5, 10);
    Rectangle r2 = new Rectangle(5, 10);
    Rectangle r3 = new Rectangle(10, 5);

    assertAll(
      () -> assertEquals(r1, r2),
      () -> assertNotEquals(r1, r3),
      () -> assertNotEquals(r1, "Hello!"));
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[]{Rectangle}
\begin{lstlisting}[language=MyJava]
class Rectangle implements IShape {

  private final double WIDTH;
  private final double HEIGHT;

  public Rectangle(double width, double height) {
    this.WIDTH = width;
    this.HEIGHT = height;
  }

  @Override
  public boolean equals(Object o) {
    return (o instanceof Rectangle r) &&
           this.WIDTH == r.WIDTH &&
           this.HEIGHT == r.HEIGHT;
  }

  public double getWidth() { return this.WIDTH; }

  public double getHeight() { return this.HEIGHT; }
}
\end{lstlisting}
\end{cl}


\subsection*{Record Types}

Our perimeter pattern matcher is helpful and convenient, but what is not-so-convenient is that we have to write a lot of boilerplate code to design, for example, a class that represents a rectangle. Each subtype of \ttt{IShape} needs instance variables, a constructor, and accessors at a minimum. Moreover, we need to manually extract the fields from the object that is bound by the variable binding. In modern Java, we can utilize \textit{record types}, which are immutable classes whose boilerplate code (as described previously) is generated by the compiler. We can also add our own methods to the record type, but we cannot add instance or static variables.

\example{Using record types, let's write a small interpreter for a simple language that supports arithmetic expressions and boolean expressions. Instead of the interface approach that we took before, we will use records and pattern matching to evaluate the expressions. With this, our interpreter will make use of \ttt{var}: a new keyword for a variable whose type is inferred from the type of the expression on the right-hand side of the assignment operator. This allows us to omit long and complex types such as \ttt{BigDecimal}.} 

\begin{cl}[]{Testing the Evaluator}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class EvaluatorTest {

  @Test
  void eval() {
    assertAll(
      () -> assertEquals(new BigDecimal("42"),
                         Evaluator.eval(new Number(42))),
      () -> assertEquals(new BigDecimal("42"),
                         Evaluator.eval(new Add(new Number(41), new Number(1)))));
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[]{Expression Interface}
\begin{lstlisting}[language=MyJava]
interface IExpr {}
\end{lstlisting}
\end{cl}

\begin{cl}[]{``Number'' Record Type}
\begin{lstlisting}[language=MyJava]
record Number(BigDecimal value) implements IExpr {
  
  public Number(int value) { this(new BigDecimal(value)); }
}
\end{lstlisting}
\end{cl}

\begin{cl}[]{``Add'' Record Type}
\begin{lstlisting}[language=MyJava]
record Add(IExpr left, IExpr right) implements IExpr {}
\end{lstlisting}
\end{cl}

\begin{cl}[]{Evaluator}
\begin{lstlisting}[language=MyJava]
class Evaluator {

  /**
   * Evaluates a given expression using records and pattern matching.
   * @param exp the expression to evaluate as a subtype IExpr.
   * @return result of evaluating the expression: a BigDecimal.
   */
  public static BigDecimal eval(IExpr exp) {
    return switch (exp) {
      case Number(var n)               -> n;
      case Add   (var left, var right) -> eval(left).add(eval(right));
      default -> throw new IllegalArgumentException("eval: bad expr " + exp);
    }
  }
}
\end{lstlisting}
\end{cl}

In the interpreter, we pattern match on the constructors of our record types. For example, in the \ttt{eval} method, when pattern matching on the \ttt{Add} constructor. We create temporary bindings for the identifiers \ttt{left} and \ttt{right} that are bound to the respective \ttt{Expr} objects that are passed into the constructor. We then recursively call \ttt{eval} on these objects and add the results together. We do the same for the other constructors of \ttt{Expr}. To make testing the program easier, we designed a secondary constructor for \ttt{Number} that receives an integer and converts it to a \ttt{BigDecimal}. Note that self-defined constructors of a record can only reference other constructors via \ttt{this(...)}.

\section{Reflection}

Reflection\index{reflection}, while not a necessarily new computer science concept, is a powerful way for programming languages to interpret and potentially modify its own structure. We made an example of reflection in our chapter on classes and objects to pass around a class type as a parameter. 

\example{Suppose that we want to be able to search, then invoke, a method based on its name. Reconsider the primitive calculator example from many chapters ago, where we utilize a case dispatch on the operator received as a terminal argument. As we add functions to the system, we must proportionally add code in the \ttt{main} method to account for the new case, which is tiresome at best. Java allows us to lookup a method, at runtime, using its reflection API, and pass parameters accordingly. As a substitute for terminal arguments (and the \ttt{main} method in general), we will pass an ``argument array'' to a static \ttt{calculate} method, so we can easily run unit tests.}

\begin{cl}[]{Reflective Calculator Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;
import static ReflectiveCalculator.calculate;

class ReflectiveCalculatorTester {

  private static final double DELTA = 0.0001;

  @Test
  void testCalculator() {
    assertAll(
      () -> assertEquals(5, calculate(new String[] {"add", "2", "3"}), DELTA),
      () -> assertEquals(5, calculate(new String[] {"subtract", "10", "5"}), DELTA),
      () -> assertEquals(10, calculate(new String[] {"multiply", "2", "5"}), DELTA),
      () -> assertEquals(2, calculate(new String[] {"divide", "10", "5"}), DELTA));
  }
}
\end{lstlisting}
\end{cl}

To retrieve a method at runtime, we first need to retrieve the class in which it lives through the \ttt{Class.forName} method. In this case we pass \ttt{ReflectiveCalculator}, as that is the name of our class. Note that the return value is of type \ttt{Class<?>}, denoting that it is a reflective class type.

With the class type object in hand, we must now get the method object to call. To do so we need two values: its identifier, and its parameter types. We will assume that the arguments to the calculator functions are strings, which can be converted inside the respective methods. This approach makes it significantly easier to inform the reflection API of our parameter type(s). Therefore we use the \ttt{getDeclaredMethod} method, which takes the name of the method as a string, and a variadic number of \ttt{Class<?>} objects that represent the parameter types. In our case, the parameter type is a \ttt{String[]}, so we pass \ttt{String[].class}. Because we might attempt to reference a non-existent method, we must wrap this in a \ttt{try-catch} block.

Finally, we invoke the method encapsulated by the \ttt{Method} using the conveniently named \ttt{invoke} method, which receives the object on which to invoke the method (in this case, \ttt{null} because the method is static), and the necessary arguments. The return value is an \ttt{Object}, so we must cast it to the appropriate type. There are several issues that may arise when calling a method, such as the method being inaccessible due to its access modifier, the method throwing a checked exception, or passing the wrong number of arguments. We must handle these issues accordingly via \ttt{try-catch} blocks.\footnote{Our code uses the Java 7 feature of the vertical pipe `\ttt{|}' to catch/handle multiple exceptions at once, removing duplicate code.} The four calculator methods are trivial and have been omitted; all they do is convert the string arguments to numbers and perform, then return, the corresponding operation.

There is one small intricacy with how Java handles variadic arguments and passing arrays to reflective methods. Passing an array to a variadic argument method unwraps the arguments and passes them individually. For example, if we have a method \ttt{foo(String... args)}, and we pass \ttt{foo(new String[] \string{"Hello", "World"\string})}, the method receives two arguments: \ttt{"Hello"} and \ttt{"World"}. In our case this is problematic, since we want our computation methods to receive the entire array of arguments. To accomplish this, we can cast the array to an \ttt{Object} and pass it to \ttt{invoke} as a single argument.

\begin{cl}[]{Reflective Calculator}
\begin{lstlisting}[language=MyJava]
import java.lang.reflect.Method;
class ReflectiveCalculator {

  /**
   * Calculates the result of a given operation on two numbers.
   * @param args the operation to perform, and the two numbers.
   * @return the result of the operation.
   */
  static double calculate(String[] args) {
    Class<?> cls = ReflectiveCalculator.class;
    try {
      Method mtd = cls.getMethod(args[0], String[].class);
      return (double) mtd.invoke(null, args);
    } catch (NoSuchMethodException
           | InvocationTargetException
           | IllegalAccessException ex) {
      throw new RuntimeException(ex);
    }
  }
}
\end{lstlisting}
\end{cl}


