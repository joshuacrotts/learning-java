\section{Design Patterns}

\subsection*{Command}

The \textit{command} pattern is a simple pattern that encapsulates a request, of sorts, to some type of handler. The handler knows nothing about the request itself, only that the handler acts as a dispatch for invoking the request.

\example{Suppose that we're writing a game that involves moving a player around an environment. We want to write a class that handles moving the player, but remains independent of the player implementation. First, we will say that the player executes some type of \ttt{Command}, which is an interface containing a sole \ttt{execute} method. Then, we will write a \ttt{Player} class containing \ttt{move} and \ttt{jump} methods, where the former increments their $x$ coordinate and jump increments their $y$ coordinate, starting from the origin.}

\begin{cl}[Command.java]{Command Interface Definition}
\begin{lstlisting}[language=MyJava]
interface Command {

  void execute();
}
\end{lstlisting}
\end{cl}

\begin{cl}[Player.java]{Player Class Definition}
\begin{lstlisting}[language=MyJava]
class Player {
  
  private int x;
  private int y;

  public Player() { this.x = 0; this.y = 0; }

  // Getters and setters omitted.
}
\end{lstlisting}
\end{cl}

Now, we will write two subtypes of \ttt{Command}, namely \ttt{MoveCommand} and \ttt{JumpCommand}, that each implement \ttt{execute}, the only difference being the intended behavior. The \ttt{MoveForward} command receives the \ttt{Player} instance and a direction, whereas \ttt{JumpCommand} only needs to receives a \ttt{Player} instance. 

\begin{cl}[MoveCommand.java]{Move Command Implementation}
\begin{lstlisting}[language=MyJava]
class MoveCommand implements Command {

  private Player player;

  public MoveCommand(Player p) { this.player = p; }

  @Override
  public void execute() {
    this.player.setX(this.player.getX() + 1);
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[JumpCommand.java]{Jump Command Implementation}
\begin{lstlisting}[language=MyJava]
class JumpCommand implements Command {
  
  private Player player;

  public JumpCommand(Player p) { this.player = p; }

  @Override
  public void execute() {
    this.player.setY(this.player.getY() + 1);
  }
}
\end{lstlisting}
\end{cl}

Lastly, we must implement a ``command dispatch handler'', of sorts, which we might envision to be a controller. In particular, we will write \ttt{InputHandler} to store two commands that respond to presses to an `X button' and presses to a `Y button'. The methods to `press' each button correspond to invoking \ttt{execute} on the respective commands. The general idea behind the command pattern is that we can pass any arbitrary implementation of a command to this handler to change/update the behavior of a button press or action in the handler. 

\begin{cl}[InputHandler.java]{...}
\begin{lstlisting}[language=MyJava]
class InputHandler {

  private Command xButton;
  private Command yButton;

  public InputHandler(Command xButton, Command yButton) {
    this.xButton = xButton;
    this.yButton = yButton;
  }

  public void pressXButton() {
    this.xButton.execute();
  }

  public void pressYButton() {
    this.yButton.execute();
  }
}
\end{lstlisting}
\end{cl}

Now, we can test the system. Under other circumstances we would write JUnit tests before writing the separate commands, but we needed to write the handler before writing coherent tests. 

\begin{cl}[CommandTester.java]{Command Tester}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class CommandTester {

  @Test
  void testCommand() {
    Player p = new Player();
    InputHandler handler = new InputHandler(new MoveCommand(p), new JumpCommand(p));
    assertAll(
      () -> assertEquals(0, p.getX()),
      () -> assertEquals(0, p.getY()),
      () -> handler.pressXButton(),
      () -> assertEquals(1, p.getX()),
      () -> handler.pressYButton(),
      () -> assertEquals(1, p.getY())
    );
  }
}
\end{lstlisting}
\end{cl}

As shown, we have decoupled the player from the handler, and the handler from the implementation of the commands. This, consequently, allows us to alter or modify the behavior of commands without redesigning the handler or player classes.

\subsection*{Factory}

\example{To showcase our next pattern, we will design the \ttt{Fraction} class to represent mathematical fractions containing integer numerators and denominators. This example greatly resembles the rational number class in a previous chapter, but we introduce a twist to exemplify the benefits of the \textit{factory} pattern.}

\begin{cl}[FractionTester.java]{}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class FractionTester {

  @Test
  void testFraction() {
    assertAll(
      () -> assertEquals("1/1", new Fraction(1, 1).toString()),
      () -> assertEquals("1/2", new Fraction(1, 2).toString()),
      () -> assertEquals("17/312", new Fraction(17, 312).toString()),
      () -> assertEquals("321/199", new Fraction(321, 199).toString())
    );

    // Test random allocations of 1/2.
    for (int i = 0; i < 500_000; i++) {
      assertEquals("1/2", new Fraction(1, i).toString());
    }
  } 
}
\end{lstlisting}
\end{cl}

\begin{cl}[Fraction.java]{}
\begin{lstlisting}[language=MyJava]
class Fraction {

  private int num;
  private int den;

  public Fraction(int num, int den) {
    this.num = num;
    this.den = den;
  }

  @Override
  public String toString() { return String.format("%d/%d", this.num, this.den); }
}
\end{lstlisting}
\end{cl}

Notice that one of our test cases loops five hundred thousand times, repeatedly allocating the same fraction, namely $1/2$. It is almost certainly true that, whatever application uses the \ttt{Fraction} class, will not need separate/distinct instances of a fraction. Accordingly, we are unnecessarily allocating \ttt{Fraction} instances, taking a lot of CPU time and memory. The solution is to introduce a form of caching, wherein we create a lookup table of the most ``common'' fractions and, whenever someone wants to construct a \ttt{Fraction}, we first determine if it can be polled from the table. If not, we have no choice but to allocate the fraction. We call this the \textit{factory} pattern, because we have a class that represents and processes the creation of \ttt{Fraction} objects, rather than allowing the user to directly instantiate one themselves. 

In designing the \ttt{FractionFactory} class, we declare a five-hundred element array to store the fractions $1/n$, where $n$ is an integer such that $1 \leq n \leq 500$. Its constructor allocates the fraction ``cache''. We now need a method to take the role of building fractions; namely a \ttt{Fraction create(int num, int den)} method, which either looks up and returns the shared instance of a common fraction, or allocates a new instance.

\begin{cl}[FractionFactoryTester]{}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;
import static Assertions.assertTrue;

class FractionFactoryTester {

  @Test
  void testFractionFactory() {
    FractionFactory ff = new FractionFactory();
    assertAll(
      () -> assertEquals("1/1", ff.create(1, 1).toString()),
      () -> assertEquals("1/2", ff.create(1, 2).toString()),
      () -> assertEquals("17/312", ff.create(17, 312).toString()),
      () -> assertEquals("321/199", ff.create(321, 199).toString())
    );

    // Check to see that all of the allocations are the same.
    Fraction f1 = ff.create(1, 2);
    for (int i = 0; i < 500_000; i++) {
      assertEquals("1/2", ff.create(1, 2).toString());
      assertTrue(f1 == ff.create(1, 2));
    }
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[FractionFactory]{}
\begin{lstlisting}[language=MyJava]
class FractionFactory {

  private static final int LIMIT = 500;
  
  private static final Fraction[] CACHE;

  public FractionFactory() {
    this.CACHE = new Fraction[LIMIT];
  }

  /**
   * Creates a new Fraction instance, or looks it up in the cache.
   * @param num numerator of fraction.
   * @param den denominator of fraction.
   * @return a new instance of Fraction, or a shared instance if it was cached.
   */
  public Fraction create(int num, int den) {
    return den >= 1 && den <= LIMIT ? this.CACHE[den - 1] : new Fraction(num, den);
  }
}
\end{lstlisting}
\end{cl}

\example{Person DB....}

\subsection*{Builder}

\subsection*{Visitor}

Explain how it works...

\example{Let's write a visitor that prints out a programming language expression in a human-readable format. In particular, we will use a simplified version of the interpreter from Chapter~\ref{chapter-advanced-oop}. First, we need to write the visitor interface, which contains a \ttt{visit} method for each type of expression, namely \ttt{NumNode}, \ttt{PrimNode}, \ttt{VarNode}, and \ttt{LetNode}. Each \ttt{visit} method takes an expression of the corresponding type as an argument and returns a string.}

\begin{cl}[ExpressionVisitor.java]{The \ttt{ExpressionVisitor} Interface}
\begin{lstlisting}[language=MyJava]
interface ExpressionVisitor {
  
  String visit(NumNode node);
  String visit(PrimNode node);
  String visit(VarNode node);
  String visit(LetNode node);
}
\end{lstlisting}
\end{cl}

Next, we need to modify the \ttt{AstNode} class to include an abstract \ttt{visit} method that receives a \ttt{Visitor} object and calls the appropriate \ttt{visit} method using polymorphic dispatch. 

\begin{cl}[AstNode.java]{The \ttt{AstNode} Class}
\begin{lstlisting}[language=MyJava]
class AstNode {
  // ... other methods and variables not shown.

  abstract String visit(ExpressionVisitor visitor);
}
\end{lstlisting}
\end{cl}

Now, we update each subclass to override the \ttt{visit} method and call the appropriate \ttt{visit} method. Fortunately this is trivial, since all we must do is add the method signature and call \ttt{visit} with \ttt{this} as the argument to represent that the visitor is visiting the current node. Because this is consistently redundant, we will only show the implementation of the \ttt{NumNode} class, but the remaining classes are identical with respect to this method.

\begin{cl}[NumNode.java]{The \ttt{NumNode} Class}
\begin{lstlisting}[language=MyJava]
class NumNode extends AstNode {
  // ... other methods and variables not shown.

  public String visit(ExpressionVisitor visitor) {
    return visitor.visit(this);
  }
}
\end{lstlisting}
\end{cl}

From here, we need to design a variant of the interface that implements the expression printing behavior. Thus we will write the \ttt{ExpressionPrinterVisitor} class, which implements the \ttt{ExpressionVisitor} interface. The \ttt{ExpressionPrinterVisitor} class overrides the respective methods from the \ttt{ExpressionVisitor} interface to prints out the expression, to standard output, in a ``stringified'' format.

The corresponding tester is nothing different from previous tests; we instantiate an instance of \ttt{ExpressionVisitor} to \ttt{ExpressionPrinterVisitor}, followed by a call to \ttt{visit} on the root node of the expression tree. The result is a string representation of the expression, which we then verify.

\begin{cl}[ExpressionPrinterVisitorTester.java]{The \ttt{ExpressionPrinterVisitorTester} Class}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class ExpressionPrinterVisitorTester {

  @Test
  void testPrimExprPrint() {
    AstNode expr = new PrimNode("+", 
                        new NumNode(1), 
                        new PrimNode("*", 
                          new NumNode(2), 
                          new NumNode(3)));
    String result = expr.visit(new ExpressionPrinterVisitor());
    assertAll(
      () -> assertEquals("(+ 1 (* 2 3))", result)
    );
  }

  @Test
  void testLetExprPrint() {
    AstNode expr = new LetNode("x", 
                        new NumNode(1), 
                        new PrimNode("+", 
                          new VarNode("x"), 
                          new NumNode(2)));
    String result = expr.visit(new ExpressionPrinterVisitor());
    assertAll(
      () -> assertEquals("(let ([x 1])\n  (+ x 2))", result)
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[ExpressionPrinterVisitor.java]{The \ttt{ExpressionPrinterVisitor} Class}
\begin{lstlisting}[language=MyJava]
class ExpressionPrinterVisitor implements ExpressionVisitor {

  @Override
  public String visit(NumNode node) {
    return String.valueOf(node.getValue());
  }
  
  @Override
  public String visit(PrimNode node) {
    StringBuilder sb = new StringBuilder();
    sb.append("(");
    sb.append(node.getOperator() + " ");
    sb.append(node.getChildren().stream()
                                .map(c -> c.visit(this))
                                .collect(Collectors.joining(" ")));
    sb.append(")");
    return sb.toString();
  }
  
  @Override
  public String visit(VarNode node) {
    return node.getValue();
  }
  
  @Override
  public String visit(LetNode node) {
    StringBuilder sb = new StringBuilder();
    sb.append("(let ([" + node.getVar() + " ");
    sb.append(node.value.visit(this));
    sb.append(")]\n  ");
    sb.append(node.body.visit(this));
    sb.append(")");
    return sb.toString();
  }
  
  @Override
  public String visit(IfNode node) {
    StringBuilder sb = new StringBuilder();
    sb.append("(if ");
    sb.append(node.condition.visit(this));
    sb.append(" ");
    sb.append(node.thenExpr.visit(this));
    sb.append(" ");
    sb.append(node.elseExpr.visit(this));
    sb.append(")");
    return sb.toString();
  }
}
\end{lstlisting}
\end{cl}

\subsection*{Observer}
