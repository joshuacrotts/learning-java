\section{Design Patterns}

\subsection*{Command}

The \textit{command} pattern is a simple pattern that encapsulates a request, of sorts, to some type of handler. The handler knows nothing about the request itself, only that the handler acts as a dispatch for invoking the request.

\example{Suppose that we're writing a game that involves moving a player around an environment. We want to write a class that handles moving the player, but remains independent of the player implementation. First, we will say that the player executes some type of \ttt{Command}, which is an interface containing a sole \ttt{execute} method. Then, we will write a \ttt{Player} class containing \ttt{move} and \ttt{jump} methods, where the former increments their $x$ coordinate and jump increments their $y$ coordinate, starting from the origin.}

\begin{cl}[Command.java]{Command Interface Definition}
\begin{lstlisting}[language=MyJava]
interface Command {

  void execute();
}
\end{lstlisting}
\end{cl}

\begin{cl}[Player.java]{Player Class Definition}
\begin{lstlisting}[language=MyJava]
class Player {
  
  private int x;
  private int y;

  public Player() { this.x = 0; this.y = 0; }

  // Getters and setters omitted.
}
\end{lstlisting}
\end{cl}

Now, we will write two subtypes of \ttt{Command}, namely \ttt{MoveCommand} and \ttt{JumpCommand}, that each implement \ttt{execute}, the only difference being the intended behavior. The \ttt{MoveForward} command receives the \ttt{Player} instance and a direction, whereas \ttt{JumpCommand} only needs to receives a \ttt{Player} instance. 

\begin{cl}[MoveCommand.java]{Move Command Implementation}
\begin{lstlisting}[language=MyJava]
class MoveCommand implements Command {

  private Player player;

  public MoveCommand(Player p) { this.player = p; }

  @Override
  public void execute() {
    this.player.setX(this.player.getX() + 1);
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[JumpCommand.java]{Jump Command Implementation}
\begin{lstlisting}[language=MyJava]
class JumpCommand implements Command {
  
  private Player player;

  public JumpCommand(Player p) { this.player = p; }

  @Override
  public void execute() {
    this.player.setY(this.player.getY() + 1);
  }
}
\end{lstlisting}
\end{cl}

Lastly, we must implement a ``command dispatch handler'', of sorts, which we might envision to be a controller. In particular, we will write \ttt{InputHandler} to store two commands that respond to presses to an `X button' and presses to a `Y button'. The methods to `press' each button correspond to invoking \ttt{execute} on the respective commands. The general idea behind the command pattern is that we can pass any arbitrary implementation of a command to this handler to change/update the behavior of a button press or action in the handler. 

\begin{cl}[InputHandler.java]{...}
\begin{lstlisting}[language=MyJava]
class InputHandler {

  private Command xButton;
  private Command yButton;

  public InputHandler(Command xButton, Command yButton) {
    this.xButton = xButton;
    this.yButton = yButton;
  }

  public void pressXButton() {
    this.xButton.execute();
  }

  public void pressYButton() {
    this.yButton.execute();
  }
}
\end{lstlisting}
\end{cl}

Now, we can test the system. Normally we would write JUnit tests before writing the separate commands, but we needed to write the handler before writing coherent tests. 

\subsection*{Fraction}

\example{Fraction caching...}

\example{Person DB....}

\subsection*{Builder}

\subsection*{Visitor}

Explain how it works...

\example{Let's write a visitor that prints out a programming language expression in a human-readable format. In particular, we will use a simplified version of the interpreter from Chapter~\ref{chapter-advanced-oop}. First, we need to write the visitor interface, which contains a \ttt{visit} method for each type of expression, namely \ttt{NumNode}, \ttt{PrimNode}, \ttt{VarNode}, and \ttt{LetNode}. Each \ttt{visit} method takes an expression of the corresponding type as an argument and returns a string.}

\begin{cl}[ExpressionVisitor.java]{The \ttt{ExpressionVisitor} Interface}
\begin{lstlisting}[language=MyJava]
interface ExpressionVisitor {
  
  String visit(NumNode node);
  String visit(PrimNode node);
  String visit(VarNode node);
  String visit(LetNode node);
}
\end{lstlisting}
\end{cl}

Next, we need to modify the \ttt{AstNode} class to include an abstract \ttt{visit} method that receives a \ttt{Visitor} object and calls the appropriate \ttt{visit} method using polymorphic dispatch. 

\begin{cl}[AstNode.java]{The \ttt{AstNode} Class}
\begin{lstlisting}[language=MyJava]
class AstNode {
  // ... other methods and variables not shown.

  abstract String visit(ExpressionVisitor visitor);
}
\end{lstlisting}
\end{cl}

Now, we update each subclass to override the \ttt{visit} method and call the appropriate \ttt{visit} method. Fortunately this is trivial, since all we must do is add the method signature and call \ttt{visit} with \ttt{this} as the argument to represent that the visitor is visiting the current node. Because this is consistently redundant, we will only show the implementation of the \ttt{NumNode} class, but the remaining classes are identical with respect to this method.

\begin{cl}[NumNode.java]{The \ttt{NumNode} Class}
\begin{lstlisting}[language=MyJava]
class NumNode extends AstNode {
  // ... other methods and variables not shown.

  public String visit(ExpressionVisitor visitor) {
    return visitor.visit(this);
  }
}
\end{lstlisting}
\end{cl}

From here, we need to design a variant of the interface that implements the expression printing behavior. Thus we will write the \ttt{ExpressionPrinterVisitor} class, which implements the \ttt{ExpressionVisitor} interface. The \ttt{ExpressionPrinterVisitor} class overrides the respective methods from the \ttt{ExpressionVisitor} interface to prints out the expression, to standard output, in a ``stringified'' format.

The corresponding tester is nothing different from previous tests; we instantiate an instance of \ttt{ExpressionVisitor} to \ttt{ExpressionPrinterVisitor}, followed by a call to \ttt{visit} on the root node of the expression tree. The result is a string representation of the expression, which we then verify.

\begin{cl}[ExpressionPrinterVisitorTester.java]{The \ttt{ExpressionPrinterVisitorTester} Class}
\begin{lstlisting}[language=MyJava]
import static Assertions.assertAll;
import static Assertions.assertEquals;

class ExpressionPrinterVisitorTester {

  @Test
  void testPrimExprPrint() {
    AstNode expr = new PrimNode("+", 
                        new NumNode(1), 
                        new PrimNode("*", 
                          new NumNode(2), 
                          new NumNode(3)));
    String result = expr.visit(new ExpressionPrinterVisitor());
    assertAll(
      () -> assertEquals("(+ 1 (* 2 3))", result)
    );
  }

  @Test
  void testLetExprPrint() {
    AstNode expr = new LetNode("x", 
                        new NumNode(1), 
                        new PrimNode("+", 
                          new VarNode("x"), 
                          new NumNode(2)));
    String result = expr.visit(new ExpressionPrinterVisitor());
    assertAll(
      () -> assertEquals("(let ([x 1])\n  (+ x 2))", result)
    );
  }
}
\end{lstlisting}
\end{cl}

\begin{cl}[ExpressionPrinterVisitor.java]{The \ttt{ExpressionPrinterVisitor} Class}
\begin{lstlisting}[language=MyJava]
class ExpressionPrinterVisitor implements ExpressionVisitor {

  @Override
  public String visit(NumNode node) {
    return String.valueOf(node.getValue());
  }
  
  @Override
  public String visit(PrimNode node) {
    StringBuilder sb = new StringBuilder();
    sb.append("(");
    sb.append(node.getOperator() + " ");
    sb.append(node.getChildren().stream()
                                .map(c -> c.visit(this))
                                .collect(Collectors.joining(" ")));
    sb.append(")");
    return sb.toString();
  }
  
  @Override
  public String visit(VarNode node) {
    return node.getValue();
  }
  
  @Override
  public String visit(LetNode node) {
    StringBuilder sb = new StringBuilder();
    sb.append("(let ([" + node.getVar() + " ");
    sb.append(node.value.visit(this));
    sb.append(")]\n  ");
    sb.append(node.body.visit(this));
    sb.append(")");
    return sb.toString();
  }
  
  @Override
  public String visit(IfNode node) {
    StringBuilder sb = new StringBuilder();
    sb.append("(if ");
    sb.append(node.condition.visit(this));
    sb.append(" ");
    sb.append(node.thenExpr.visit(this));
    sb.append(" ");
    sb.append(node.elseExpr.visit(this));
    sb.append(")");
    return sb.toString();
  }
}
\end{lstlisting}
\end{cl}

\subsection*{Observer}
